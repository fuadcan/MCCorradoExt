/*
**   fastbayes.src    FASTBAYES - Bayesian Inference from Weighted
**                    Likelihood Bootstrap Likelihood Bootstrap using
**                    FASTMAX
**
** (C) Copyright 1995-2005  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
**-------------------**------------------**-------------------**-----------**
**-------------------**------------------**-------------------**-----------**
**
**> FastBayes
**
**  Purpose  generates simulated posterior distribution of parameters
**
**  Format: { x,f,g,cov,retcode } = FastBayes(data,vars,&fct,start)
**
**  Input:    data         matrix containing data
**
**            vars         Kx1 vector or scalar zero.  vector of column
**                         numbers in data of variables selected for analysis.
**                         If scalar zero, all columns are selected.
**
**            fct          the name of a procedure that returns either
**                         the log-likelihood for one observation or a
**                         vector of log-likelihoods for a matrix of
**                         observations
**
**            start        Kx1 vector, start values
**
**
**  Output:   b            Kx1 vector of mean of posterior distribution
**                         of parameters
**
**            f            scalar, mean weighted bootstrap log-likelihood
**
**            g            Kx1 vector, mean gradient of weighted bootstrap
**
**            cov          KxK covariance matrix of simulated posterior
**
**            retcode      return code:
**
**                            0   normal convergence
**                            1   forced exit
**                            2   maximum number of iterations exceeded
**                            3   function calculation failed
**                            4   gradient calculation failed
**                            5   Hessian calculation failed
**                            6   step length calculation failed
**                            7   function cannot be evaluated at initial
**                                parameter values
**                            8   number of elements in the gradient vector
**                                inconsistent with number of starting values
**                            9   gradient function returned a column vector
**                                rather than the required row vector
**                           10   secant update failed
**                           11   maximum time exceeded
**                           12   weights could not be found
**                           20   Hessian failed to invert
**                           34   data set could not be opened
**                           99   termination condition unknown
**
**
**  Globals:
**
**   _max_BayesAlpha   exponent of the Dirichlet random variates used in
**                     the weights for the weighted bootstrap. See
**                     Newton and Raftery, "Approximate Bayesian Inference
**                     with the Weighted Likelihood Bootstrap",  J.R.Statist.
**                     Soc. B (1994), 56:3-48.  Default = 1.4.
**
**    _max_PriorProc   pointer to proc for computing prior.  This proc
**                     takes the parameter vector as its only argument,
**                     are returns a scalar probability.  If a proc is not
**                     provided, a uniform prior is assumed.
**
**    _max_NumSample   scalar, number of re-samples in the weighted likelihood
**                     bootstrap.
**
**    _max_BootFname   string, file name of GAUSS dataset (do not include
**                     the .DAT extension) containing simulated posterior
**                     of the parameters.  If not specified, MAXBayes
**                     will select the file name, BOOTxxxx where xxxx is
**                     0000 incremented by 1 until a name is found that
**                     doesn't exist on the current directory.
**
**
**     _max_RandType   scalar, if nonzero, pseudo-random numbers of the linear
**                     congruential type are generated, otherwise, they are
**                     generated by Marsaglia's "Kiss-Monster" method.  The
**                     latter method is slower but has a much larger period.
**
**     _max_state      scalar or vector, state vector for pseudorandom number
**                     generators containing seed.  By default it is set to
**                     345678.  If you wish to select a seed, set to a
**                     different value.
**
**
**   FASTMAX globals are relevant.  See FASTMAX.SRC for their description.
*/

#include maxlik.ext


proc (5) = fastbayes(dataset,var,lfct,start);
    local x,f,g,h,retcode,prior,isPrior,alpha,oldt,lg,ii,jj,tme,itdta,it0,
          nobs,tt0,fhandle,fout,mm,mn,gg,iter,title0,i,j,f0,ncase,ttime,
          np,fhat,terrell,num,ch,datx,datf,ofname,L1,wgt,zz,iter0;

    alpha = _max_BayesAlpha;

    if not scalmiss(_max_PriorProc);
        prior = _max_PriorProc;
        local prior:proc;
        isPrior = 1;
    else;
        isPrior = 0;
    endif;

    if _max_GradMethod == 0;
        _max_eps2 = __macheps^(1/3);
    else;
        _max_eps2 = __macheps^(1/2);
    endif;
    _max_eps3 = __macheps^(1/3);

    if type(dataset) == 13;
        if dataset $/= "";
            open fhandle = ^dataset;
            if fhandle == -1;
                errorlog dataset $+ " could not be opened";
                retp(start,error(0),error(0),error(0),error(34));
            endif;
            nobs = rowsf(fhandle);
            fhandle = close(fhandle);
        else;
            errorlog "data set not specified";
            retp(start,error(0),error(0),error(0),error(34));
        endif;
    else;
        nobs = rows(dataset);
    endif;

    tme = 0;
    ttime = date;
    datx = zeros(_max_NumSample,rows(start));
    datf = zeros(_max_NumSample,1);
    tt0 = ftos(_max_NumSample,"%0*.*lf",1,0);
    title0 = __title;
    clear mn,gg,itdta,it0;

    for iter(1,_max_NumSample,1);
        if tme > _max_MaxTime;
            break;
        endif;

        if _max_RandType;
            { zz, _max_state } = rndLCu(nobs,1,_max_state);
        else;
            { zz, _max_state } = rndKMu(nobs,1,_max_state);
        endif;

        if __weight == 0;
            wgt = (-ln(zz))^alpha;
        else;
            wgt = __weight .* (-ln(zz))^alpha;
        endif;

         { x,f,g,L1,retcode,L1,it0,L1,L1,_max_NumObs,_max_dsn } =
         _fastmax(dataset,var,lfct,start,_max_Algorithm,_max_LineSearch,
         0,_max_GradMethod,_max_GradStep,_max_Delta,_max_Extrap,
         _max_GradProc,_max_GradTol,_max_HessProc,_max_Interp,
         _max_MaxIters,_max_MaxTime,_max_MaxTry,_max_NumObs,
         _max_RandRadius,_max_Options,_max_Switch,_max_Active,_max_dat,
         _max_dsn,__altnam,wgt);


        if retcode == 0;
            datx[iter,.] = x';
            datf[iter] = f;
            mn = mn + x;
            gg = gg + g;
            start = mn / iter;
            itdta = itdta + it0;
        else;
            datx[iter,.] = miss(zeros(1,cols(datx)),0);
            datf[iter] = error(0);
        endif;

        tme = ethsec(ttime,date)/6000;
        iter0 = iter;
    endfor;
    datx = packr(datx);
    datf = packr(datf);
    mm = vcx(datx);
    f0 = meanc(datf);
    gg = g / rows(datf);

    itdta[1:2] = itdta[1:2] / iter0;
    itdta[3] = "BAYES";
    _max_IterData = itdta;
    if tme >= _max_MaxTime;
        retcode = 11;
    else;
        retcode = 0;
    endif;


    np = rows(start);
    terrell = ( ((np+8)^((np+6)/2)) /
                (16*rows(datx)*(np+2)*gamma((np+8)/2)) )^(2/(np+4));

    oldt = trapchk(1);
    trap 1,1;
    ch = inv(chol(mm*terrell));
    trap oldt,1;
    if scalmiss(ch);
         errorlog "estimated covariance matrix not positive definite";
         retp(start,error(0),error(0),error(0),error(20));
    endif;
    fhat = zeros(rows(datx),1);
    for i(1,rows(datx),1);
        if isPrior;
            f0 = rows(datx)*datf[i]*prior(datx[i,.]');
        else;
            f0 = rows(datx)*datf[i];
        endif;
        if abs(f0) > 1e-16;
            f0 = sumc(exp(sumc((-.5 * ((datx[i,.] - datx)*ch)^2)'))/f0);
            if abs(f0) > 1e-16;
                fhat[i] = 1 / f0;
            else;
                fhat[i] = 0;
            endif;
        else;
            fhat[i] = 0;
        endif;
    endfor;
    fhat = fhat / sumc(fhat);

    if _max_BootFname $== "";
        ofname = tempname("","boot",".dat");
        if ofname $== "";
            errorlog "ERROR:  file name selection for bootstrap dataset"\
                               " failed";
            retp(start,error(0),error(0),error(0),error(34));
        endif;
        _max_BootFname = ofname;
    else;
        ofname = _max_BootFname;
    endif;

    if _max_ParNames $== "";
        create fout = ^ofname with PAR_,rows(start),8;
    else;
        create fout = ^ofname with ^_max_ParNames,0,8;
    endif;
    mm = 0;
    mn = 0;
    ncase = 0;
    for i(1,rows(fhat),1);
        if _max_RandType;
            { num, _max_state } = rndLCp(1,1,fhat[i]*rows(datx),_max_state);
        else;
            { num, _max_state } = rndKMp(1,1,fhat[i]*rows(datx),_max_state);
        endif;

        for j(1,num,1);
            call writer(fout,datx[i,.]);
            ncase = ncase + 1;
            mn = mn + datx[i,.];
            mm = mm + moment(datx[i,.],0);
        endfor;
    endfor;
    mn = mn' / ncase;
    mm = mm / ncase - mn * mn';
    fout = close(fout);
    retp(mn,f0,gg,mm,0);
endp;



