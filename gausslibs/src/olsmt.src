/*
** olsmt.src - Least Squares Regression
** (C) Copyright 2004-2006 by Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
** { vnam,m,b,stb,vc,stderr,sigma,cx,rsq,resid,dwstat } =
**                                    olsmt(oc0,dataset,depvar,indvars);
**
**> olsmt
**
**  Purpose:    To compute least squares regression.
**
**  Format:     oout = olsmt(struct olsmtControl oc1,dataset,depvar,indvars);
**
**  Input:  oc0     an instance of an olsmtControl structure containing the
**					following members:
** 
**					oc0.altnam -- string array, default "".
**
**							This can be a (K+2)x1 or (K+1)x1 string
**							array of alternate variable names for the
**							output. If oc0.con is 1, this must be (K+2)x1.
**							The dependent variable is the last element.
**							This has an effect only if the data are passed
**							in as matrices.
**
**					oc0.con -- scalar, default 1.
**
**							1   a constant term will be added, D = K+1.
**
**							0   no constant term will be added, D = K.
**
**							A constant term is always used in
**							constructing the moment matrix m.
**
**					oc0.fcmptol -- scalar, default 1e-12.
**
**							Tolerance used to fuzz the comparison operations 
**							to allow for round off error.
**
**					oc0.maxvec -- scalar, default 20000. 
**
**							The largest number of elements allowed in any
**							one matrix.
**
**					oc0.miss -- scalar, default 0.
**
**							0   there are no missing values (fastest).
**
**							1   listwise deletion, drop any cases in
**								which missings occur.
**
**							2   pairwise deletion, this is equivalent to
**								setting missings to 0 when calculating m.
**								The number of cases computed is equal to
**								the total number of cases in the data set.
**
**					oc0.output -- scalar, default 1.
**
**							1   print the statistics.
**
**							0   do not print statistics.
**
**					oc0.res -- scalar, default 0.
**
**							1   compute residuals (resid) and Durbin-
**								Watson statistic (dwstat).
**
**							0   resid = 0, dwstat = 0.
**
**					oc0.rnam -- string, default "_olsmtres".
**
**							If the data is taken from a data set, a new 
**							data set will be created for the residuals, 
**							using the name in oc0.rnam. 
**
**					oc0.row -- scalar, the number of rows to read 
**							per iteration of the read loop. Default 0.
**
**							If 0, the number of rows will be calculated
**							internally. If you get an "Insufficient 
**							memory" error while executing OLS you can 
**							supply a value for oc0.row that works on your 
**							system.
**
**							The answers may vary slightly due to rounding
**							error differences when a different number of
**							rows is read per iteration. You can use 
**							oc0.row to control this if you want to get 
**							exactly the same rounding effects between 
**							several runs.
**
**					oc0.vpad -- scalar, default 1.
**
**							If 0, internally created variable names are not
**							padded to the same length (e.g. "X1, X2,..., X10").
**
**							If 1, they are padded with zeros to the same
**							length (e.g., "X01, X02,..., X10").
**
**          dataset     string, name of data set.
**
**                         If this is a null string, the procedure assumes
**                         that the actual data has been passed in the
**                         next two arguments.
**
**          depvar      dependent variable.
**
**                        If dataset contains the name of a data set, this is
**                        interpreted as:
**
**                            string, name of dependent variable
**                                or
**                            scalar, index of dependent variable. If scalar 0,
**                            the last column of the data set will be used.
**
**                        If dataset is a null string or 0, this is
**                        interpreted as:
**
**                            Nx1 vector, the dependent variable
**
**          indvars      independent variables.
**
**                         If dataset contains the name of a data set, this is
**                         interpreted as:
**
**                             Kx1 string array, names of independent
**                             variables
**                                  or
**                             Kx1 numeric vector, indices of independent
**                             variables
**
**                             These can be any size subset of the variables in
**                             the data set, and can be in any order.  If a
**                             scalar 0 is passed, all columns of the data set
**                             will be used except for the one used for the
**                             dependent variable.
**
**                         If dataset is a null string or 0, this is
**                         interpreted as:
**
**                             NxK matrix, the independent variables
**
**  Output:  oout0   an instance of an olsmtControl structure containing the
**					following members:
** 
**					oout0.vnam -- (K+2)x1 or (K+1)x1 string array, the variable
**							names used in the regression. If a constant term
**							is used this vector will be (K+2)x1, and the first
**							name will be "CONSTANT". The last name will be the
**							name of the dependent variable.
**
**					oout0.m -- MxM matrix, where M = K+2, the moment matrix
**							constructed by calculating x'x where x is a matrix
**							containing all useable observations and having 
**							columns in the order:
**
**							constant   ~     indvars        ~        depvar
**							------------------------------------------------------
**							(1.0) ~ (independent variables) ~ (dependent variable)
**
**							A constant term is always used in computing m.
**
**					oout0.b -- Dx1 vector, the least squares estimates of 
**							parameters.
**
**							Error handling is controlled by the low order bit
**							of the trap flag.
**
**								TRAP 0     terminate with error message
**
**								TRAP 1     return scalar error code in b
**
**									30  system singular
**									31  system underdetermined
**									32  same number of columns as rows
**									33  too many missings
**									34  file not found
**									35  no variance in an independent variable
**
**							The system can become underdetermined if you use 
**							listwise deletion and have missing values. In that 
**							case it is possible to skip so many cases that there 
**							are fewer useable rows than columns in the data set.
**
**					oout0.stb -- Kx1 vector, the standardized coefficients.
**
**					oout0.vc -- DxD matrix, the variance-covariance matrix of
**							estimates.
**
**					oout0.stderr -- Dx1 vector, the standard errors of the 
**							estimated parameters.
**
**					oout0.sigma -- scalar, standard deviation of residual.
**
**					oout0.cx -- (K+1)x(K+1) matrix, correlation matrix of 
**							variables in the order:
**
**								independent variables ~ dependent variable
**
**					oout0.rsq -- scalar, R square, coefficient of determination.
**
**					oout0.resid -- residuals, resid = y - x * b
**
**							If oc0.res = 1, the residuals will be computed.
**
**							If the data is taken from a data set, a new data
**							set will be created for the residuals, using the
**							name in the rnam member of the olsmtControl
**							structure. The residuals will be saved in this 
**							data set as an Nx1 column. The resid return value 
**							will be a string containing the name of the new 
**							data set containing the residuals.
**
**							If the data is passed in as a matrix, the
**							oout0.resid return value will be the Nx1 vector of
**							residuals.
**
**					oout0.dwstat -- scalar, Durbin-Watson statistic.
**
**  Remarks:    No output file is modified, opened, or closed by this
**              procedure.  If you want output to be placed in a file
**              you need to open an output file before calling olsmt.
**              If a column of constant value has been included among
**              the independent variables, this variable will be
**              deleted.
**
**              You must include olsmt.sdf at the beginning of any program
**              that calls olsmt to enable GAUSS to find the definition
**              of the olsmtControl structure. You should also call 
**              olsmtControlCreate before calling olsmt to set the members
**              of the olsmtControl structure to default values. 
**
**  Examples:  
**              // Example 1
**
**              #include olsmt.sdf
**              struct olsmtControl oc1;
**              oc1 = olsmtControlCreate;
**              
**              y = { 2,
**                    3,
**                    1,
**                    7,
**                    5 };
**
* *             x = { 1 3 2,
**                    2 3 1,
**                    7 1 7,
**                    5 3 1,
**                    3 5 5 };
**
**              output file = olsmt.out reset;
**              call olsmt(oc1,0,y,x);
**              output off;
**
**              In this example, the output from olsmt was put into a
**              file called olsmt.out as well as being printed on the
**              screen.  This example will to compute a least squares
**              regression of y on x.  The returned values were
**              discarded by using a call statement.
**
**              // Example 2
**
**              #include olsmt.sdf
**              struct olsmtControl oc1;
**				struct olsmtOut oout1;
**              oc1 = olsmtControlCreate;
**              
**              data = "olsdat";
**              depvar = { score };
**              indvars = { region,age,marstat };
**              oc1.res = 1;
**              output file = lpt1 on;
**              oout1 = olsmt(oc1,data,depvar,indvars);
**              output off;
**
**              In this example the data set, olsdat.dat was used
**              to compute a regression. The dependent variable
**              is "score". The independent variables are:
**              "region", "age", and "marstat".  The residuals
**              and Durbin-Watson statistic will be computed.
**              The output will be sent to the printer as well as
**              the screen and the returned values are assigned
**              to variables.
**
**  Globals:    indexcat(), dotfeqmt(), indicesf(), satostrC(), strcombine()
**
**  See Also:   olsqr
*/

#include olsmt.sdf

#ifDLLCALL
external proc indicesf;
#else
external proc indicesf,indexcat;
#endif

proc olsmt(struct olsmtControl oc0,dataset, depvar, indvars);

    dataset = "" $+ dataset;

    if dataset $== "";
        retp(_olsxmt(oc0, depvar, indvars));
    else;
        retp(_olsdmt(oc0, dataset, depvar, indvars));
    endif;

endp;

/*
** olsmtControlCreate
**
** Purpose: Sets the members of an olsmtControl structure to default values.
**
** Format:  oc1 = olsmtControlCreate;
**
** Input:      none
**
** Output:     oc1 -- an instance of an olsmtControl structure with its
**						members set to default values.  
**
** Remarks:  olsmtControlCreate should be called before any call to olsmt. 
**
*/

proc olsmtControlCreate;
	struct olsmtControl oc0;

	oc0.altnam = "";
	oc0.con = 1;
	oc0.miss = 0;
	oc0.row = 0;
	oc0.vpad = 1;
	oc0.output = 1;
	oc0.res = 0;
	oc0.rnam = "_olsmtres";
	oc0.fcmptol = 1e-12; 
	oc0.maxvec = 20000; 
	oc0.maxbytes = 1e9;

	retp(oc0);
endp;

proc _olsxmt(struct olsmtControl oc0, depvar, indvars);

    local const,fin,tobs,nvar,k,dta,y0,mn,nc,cy,
        i,constflg,constvlu,std,vnames,cxx,cxxi,cxy,cyy,df,
        sse,nobs,mobs,be,b,vc,stderr,t,rsq,rbsq,fstat,pvf,pvt,ms,
        omat,fmt,dwstat,mss,nvar1,cvec,old,m,cor,constant,
        stdb,fout,u,str,tv,oldtrp,u0,cov,stdest,indvarnms,depvarnm,
		colwid,ostr,j;
	struct olsmtOut oout0;

    clear constflg,mobs,constant;
    const = oc0.con;
    constvlu = 1;
    mss = { . };
    fin = -1;
    fout = -1;

    if rows(indvars) /= rows(depvar);
        errorlog "ERROR: Matrices X and Y have different numbers of rows";
        end;
    endif;

    dta = indvars~depvar;
    tobs = rows(dta);
    nobs = tobs;
    nvar1 = cols(dta);
    nvar = nvar1-1;
    indvarnms = "X"$+ftocv(seqa(1,1,nvar),oc0.vpad*(floor(log(nvar))+1),0);
    depvarnm = "Y";
    vnames = indvarnms$|depvarnm;

    if oc0.miss == 2;
        old = ndpcntrl(0,0);
        call ndpcntrl(1,1);
        clear mn,nc,m,i,nobs;
        constflg = ones(1,nvar1);
        do until i == tobs;
            i = i+1;
            y0 = dta[i,.];
            cy = (y0 .> 0 .or y0 .< 1);
            y0 = missrv(y0,0);
            m = m+y0'*y0;
            mn = mn + y0'*cy;
            nc = nc+cy'*cy;
            nobs = nobs+(cy /= 0);
        endo;
        call ndpcntrl(old,0xffff);
        if nc == 0;
            goto errout(31);
        endif;
        mobs = tobs-nobs;
        mn = mn./nc;
        m = m./nc;
    else;
        if oc0.miss == 0 and ismiss(dta);
            errorlog "missing data found - using listwise deletion";
            oc0.miss = 1;
        endif;
        if oc0.miss == 1;
            dta = packr(dta);
            if scalmiss(dta);
                goto errout(31);
            endif;
            nobs = rows(dta);
            mobs = tobs-nobs;
        endif;
        mn = meanc(dta);
        m = moment(dta,0)/nobs;
    endif;

    if m[rows(m),rows(m)] == dta[1,cols(dta)];
        errorlog "dependent variable has no variation";
        end;
    endif;


    if oc0.miss == 2;
        constflg = indexcat(dotfeqmt(diag(m),diag(mn)^2,oc0.fcmptol),1);
    else;
        constflg = indexcat(dotfeqmt(diag(m),mn^2,oc0.fcmptol),1);
    endif;

    if scalmiss(constflg);
        constflg = 0;
    elseif rows(constflg) > 1;
        goto errout(35);
    endif;

    if constflg;
        cvec = packr(miss(seqa(1,1,rows(mn)),constflg));
        if oc0.miss == 2;
            constvlu = mn[constflg,constflg];
            mn = mn[cvec,cvec];
        else;
            constvlu = mn[constflg];
            mn = mn[cvec];
        endif;
        m = m[cvec,cvec];
        nvar1 = rows(cvec);
        nvar = nvar1 - 1;
        indvarnms = "X"$+ftocv(seqa(1,1,nvar),
            oc0.vpad*(floor(log(nvar))+1),0);
    endif;

    if oc0.miss == 2;
        mn = diag(mn);
    endif;

    if const == 1 and constflg;
        const = 0;
    endif;

    if const or constflg;
      cov = m - mn*mn';
    else;
      cov = m;
    endif;

    k = diag(cov);
    cyy = k[nvar1];
    std = sqrt(k);
    cxy = cov[1:nvar,nvar1];
    cxx = cov[1:nvar,1:nvar];
    cor = cov./std./std';

    oldtrp = trapchk(1);
    trap 1,1;
    cxxi = invpd(cxx);
    trap oldtrp,1;
    if scalmiss(cxxi);
        goto errout(30);
    endif;

    b = cxxi*cxy;

    if const or constflg;
        constant = (mn[nvar1]-mn[1:nvar]'*b)/constvlu;
        if constflg == 0;
            indvarnms = "CONSTANT"$|indvarnms;
        endif;
    endif;
    if oc0.altnam $/= "";
        vnames = oc0.altnam;
        if const == 0 and constflg;
            k = packr(miss(seqa(1,1,rows(vnames)),constflg));
            vnames = vnames[constflg]$|vnames[k];
        endif;
        depvarnm = vnames[rows(vnames)];
        indvarnms = vnames[1:rows(vnames)-1];
    endif;

    if rows(indvarnms) == nvar and (const or constflg);
        indvarnms = "CONSTANT"$|indvarnms;
    endif;

    if const or constflg;
       df = nobs-nvar-1;
    else;
       df = nobs-nvar;
    endif;

    if df == 0;
        goto errout(32);
    elseif df<0;
        goto errout(31);
    endif;

    sse = cyy-b'*cxy;
    if const or constflg;
        k = -cxxi*mn[1:nvar]/constvlu;
        vc = (sse/df)*(((1/constvlu-mn[1:nvar]'*k)/constvlu|k)~(k'|cxxi));
        stderr = sqrt(diag(vc));
        t = (constant|b)./stderr;
        tv = nobs*cyy;
    else;
        vc = (sse/df)*cxxi;
        stderr = sqrt(diag(vc));
        t = b./stderr;
        tv = nobs*(cyy - mn[nvar1]^2);
    endif;
    sse = nobs*sse;
    rsq = (tv - sse)/tv;
    rbsq = 1-(1-rsq)*((nobs-1)/df);
    fstat = (rsq/(1-rsq))*(df/nvar);
    if fstat>0;
        pvf = cdffc(fstat,nvar,df);
    else;
        pvf = mss;
    endif;
    pvt = 2*cdftc(abs(t),df);

    if sse > 0;
      stdest = sqrt(sse/df);
    else;
      stdest = error(0);
    endif;

    stdb = b.*(std[1:nvar]/std[nvar1]);     /* Standardized coefficients  */
    if const or constflg;
        stdb = mss|stdb;
    endif;

    if oc0.res;
        old = ndpcntrl(0,0);
        call ndpcntrl(1,1);
        if constflg;
            dta = dta[.,cvec];
        endif;
        u = dta[.,nvar1]-dta[.,1:nvar]*b - constant*constvlu;
        ndpclex;
        if oc0.miss;
            u0 = packr(u);
        else;
            u0 = u;
        endif;
        dwstat = sumc((trimr(u0,1,0)-trimr(u0,0,1))^2)/(u0'*u0);
        clear u0;
        call ndpcntrl(old,0xffff);
    else;
        u = 0;
        dwstat = 0;
    endif;
    if const or constflg;
        b = constant|b;
    endif;

    if oc0.output;
		colwid = maxc(maxc(strlen(indvarnms)+1)|9);
        print ftos(nobs,"Valid cases:  %*.*f",20,0);;
        print "      Dependent variable:" strcombine(satostrC(depvarnm,"%20.18s"),"",0);

        print ftos(mobs,"Missing cases:%*.*f",20,0);;
        print "      Deletion method:               ";;
        if oc0.miss == 0;
            print "    None";
        elseif oc0.miss == 2;
            print "Pairwise";
        else;
            print "Listwise";
        endif;

        print ftos(tv,"Total SS:     %*.*f",20,3);;

        print ftos(df,"      Degrees of freedom:%*.*f",20,0);

        print ftos(rsq,"R-squared:    %*.*f",20,3);;
        print ftos(rbsq,"      Rbar-squared:      %*.*f",20,3);
        print ftos(sse,"Residual SS:  %*.*f",20,3);;
        print ftos(stdest,"      Std error of est:  %*.*f",20,3);
        str = ftos(nvar,"F(%*.*f,",1,0) $+ ftos(df,"%*.*f):             "
            ,1,0);
        str = strsect(str,1,15) $+ ftos(fstat,"%*.*f",19,3);
        print str;;
        print ftos(pvf,"      Probability of F:  %*.*f",20,3);

        if oc0.res;
            print ftos(dwstat,"Durbin-Watson:%*.*f",20,3);
        endif;
        print;
        print chrs(32*ones(colwid,1))$+"                Standard                 Prob   Sta"\
            "ndardized  Cor with";
        print "Variable"$+chrs(32*ones(colwid-8,1))$+"    Estimate      Error      t-value"\
			"     >|t|     Estimate    Dep Var";

        print chrs(45*ones(70+colwid,1));;
        omat = b~stderr~t~pvt~stdb;
        if const or constflg;
            omat = omat~(mss|cor[1:nvar,nvar1]);
        else;
            omat = omat~cor[1:nvar,nvar1];
        endif;
        ms = ftos(mss,"%*.*f",1,0);
        msym "---  ";
		fmt = ("%-"$+ftos(colwid,"%*.*f",1,0)$+"."$+ftos(colwid,"%*.*f",1,0)$+"s") $|
				"%12.6f" $| "%12.6f" $| "%12.6f" $| "%10.3f" $| "%12.6f" $| "%12.6f";
		ostr = satostrC(indvarnms,fmt[1]) $~ ftostrC(omat,fmt[2:7]);
		ostr = strcombine(ostr,"",0);
		print ostr;
        msym ^ms;
    endif;
    if fin > 0;
        fin = close(fin);
    endif;
    if fout > 0;
        fout = close(fout);
    endif;

    m = (1~mn')|(mn~m);

	oout0.vnam = vnames;
	oout0.m = nobs*m;
	oout0.b = b;
	oout0.stb = stdb;
	oout0.vc = vc;
	oout0.stderr = stderr;
	oout0.sigma = stdest;
	oout0.cx = cor;
	oout0.rsq = rsq;
	oout0.resid = u;
	oout0.dwstat = dwstat;
    retp(oout0);

ERROUT:
        pop be;
    if be == 30;
        errorlog "ERROR: covariance matrix of independent variables is sing"\
            "ular.";
    elseif be == 31;
        errorlog "ERROR: system underdetermined";
    elseif be == 32;
        errorlog "ERROR: same number columns as rows";
    elseif be == 33;
        errorlog "ERROR: too many missings";
    elseif be == 35;
        errorlog "ERROR: no variation in at least one independent variable";
    else;
        errorlog "Coefficients vector is an error code: " $+ ftos(be,"%*.*l"\
            "f",1,0);
    endif;
    if fin > 0;
        fin = close(fin);
    endif;
    if fout > 0;
        fout = close(fout);
    endif;

	oout0.vnam = 0;
	oout0.m = 0;
	oout0.b = 0;
	oout0.stb = error(be);
	oout0.vc = 0;
	oout0.stderr = 0;
	oout0.sigma = 0;
	oout0.cx = 0;
	oout0.rsq = 0;
	oout0.resid = 0;
	oout0.dwstat = 0;
    retp(oout0);

endp;

proc _olsdmt(struct olsmtControl oc0, dataset, depvar, indvars);

    local const,fin,tobs,depindx,indindx,nvar,nr,k,y0,mn,nc,cy,
        i,constflg,constvlu,vardx,std,vnames,cxx,cxxi,cxy,cyy,df,
        sse,nobs,mobs,be,b,vc,stderr,t,rsq,rbsq,fstat,pvf,pvt,ms,
        omat,fmt,dwstat,mss,prcn,nvar1,cvec,old,u2,m,cor,constant,
        stdb,fout,u,str,tv,oldtrp,cov,stdest,dd,cnstname,tmpnm,
		colwid,ostr,indvarnms,depvarnm,j;
	struct olsmtOut oout0;

    clear constflg,mobs,constant;
    const = oc0.con;
    constvlu = 1;
    mss = { . };
    fin = -1;
    fout = -1;

    dataset = "" $+ dataset;

    /* open file using name in variable DATASET */
    open fin = ^dataset;
    if fin == -1;
        goto errout(34);
    endif;
    tobs = rowsf(fin);

	if type(depvar) == 6;
        if round(depvar) == depvar and depvar >= 1 and depvar < 131072;
            { depvarnm, depindx } = indicesf(fin, "", depvar);
		elseif depvar == 0;
			depvarnm = getnamef(fin);
			depindx = rows(depvarnm);
			depvarnm = depvarnm[depindx];
		else;
			depvar = "" $+ depvar;
			{ depvarnm, depindx } = indicesf(fin,depvar,0);	
		endif;
	else;
		{ depvarnm,depindx } = indicesf(fin,depvar,0);
	endif;

	if type(indvars) == 6;
        if round(indvars) == indvars and indvars >= 1 and indvars < 131072;
            { indvarnms, indindx } = indicesf(fin, "", indvars);
		elseif indvars == 0;
			indvarnms = getnamef(fin);
			indindx = seqa(1,1,rows(indvarnms));
			indindx = packr(miss(indindx,depindx));
			indvarnms = indvarnms[indindx];
		else;
			indvars = "" $+ indvars;
			{ indvarnms,indindx } = indicesf(fin,indvars,0);
		endif;
	else;
		{ indvarnms,indindx } = indicesf(fin,indvars,0);
	endif;

    vardx = indindx|depindx;
    nobs = tobs;
    nvar = rows(indindx);
    nvar1 = nvar+1;

    /* Computation of max number of rows to read at one time */
    if oc0.row;
        nr = oc0.row;
    else;
        k = colsf(fin);
        nr = floor(minc(maxbytes/(k*8*3.5)|oc0.maxvec/(k+1)));
    endif;

    if oc0.miss == 2;
        old = ndpcntrl(0,0);
        call ndpcntrl(1,1);
        clear mn,nc,m,i,nobs;
        constflg = ones(1,nvar1);
        do until i == tobs;
            i = i+1;
            y0 = readr(fin,1);
            y0 = y0[vardx];
            cy = (y0 .> 0 .or y0 .< 1);
            ndpclex;
            y0 = missrv(y0,0);
            m = m+y0'*y0;
            mn = mn + y0'*cy;
            nc = nc+cy'*cy;
            nobs = nobs+(cy /= 0);
        endo;
        call ndpcntrl(old,0xffff);
        if nc == 0;
            goto errout(31);
        endif;
        mobs = tobs-nobs;
        mn = mn./nc;
        m = m./nc;
    else;
        clear mn,m,nc;
        do until eof(fin);
            y0 = readr(fin,nr);
            y0 = y0[.,vardx];
            if oc0.miss == 1;
                y0 = packr(y0);
                nc = nc+rows(y0);
            elseif ismiss(y0);
                errorlog "missing data found - using listwise deletion";
                oc0.miss = 1;
                y0 = packr(y0);
                nc = nc+rows(y0);
            endif;
            if not scalmiss(y0);
                m = m+moment(y0,0);
                mn = mn + sumc(y0);
            endif;
        endo;
        if oc0.miss == 1;
            if nc == 0;
                goto errout(31);
            endif;
            nobs = nc;
            mobs = tobs-nobs;
        endif;
        mn = mn/nobs;
        m = m/nobs;
    endif;


    if m[rows(m),rows(m)] == y0[1,cols(y0)];
        errorlog "dependent variable has no variation";
        end;
    endif;


    if oc0.miss == 2;
        constflg = indexcat(dotfeqmt(diag(m),diag(mn)^2,oc0.fcmptol),1);
    else;
        constflg = indexcat(dotfeqmt(diag(m),mn^2,oc0.fcmptol),1);
    endif;

    if scalmiss(constflg);
        constflg = 0;
    elseif rows(constflg) > 1;
        goto errout(35);
    endif;

    if constflg;
        cvec = packr(miss(seqa(1,1,rows(mn)),constflg));
        if oc0.miss == 2;
            constvlu = mn[constflg,constflg];
            mn = mn[cvec,cvec];
        else;
            constvlu = mn[constflg];
            mn = mn[cvec];
        endif;
        m = m[cvec,cvec];
        nvar1 = rows(cvec);
        nvar = nvar1 - 1;
        cnstname = indvarnms[constflg];
        indvarnms = indvarnms[packr(miss(seqa(1,1,rows(indvarnms)),constflg))];
    endif;

    if oc0.miss == 2;
        mn = diag(mn);
    endif;

    if const == 1 and constflg;
        const = 0;
    endif;

    if const or constflg;
      cov = m - mn*mn';
    else;
      cov = m;
    endif;

    k = diag(cov);
    cyy = k[nvar1];
    std = sqrt(k);
    cxy = cov[1:nvar,nvar1];
    cxx = cov[1:nvar,1:nvar];
    cor = cov./std./std';

    oldtrp = trapchk(1);
    trap 1,1;
    cxxi = invpd(cxx);
    trap oldtrp,1;
    if scalmiss(cxxi);
        goto errout(30);
    endif;

    b = cxxi*cxy;

    if const or constflg;
        constant = (mn[nvar1]-mn[1:nvar]'*b)/constvlu;
        if constflg == 0;
            indvarnms = "CONSTANT"$|indvarnms;
        endif;
    endif;

    vnames = indvarnms$|depvarnm;

    if rows(indvarnms) == nvar and (const or constflg);
        indvarnms = cnstname$|indvarnms;
    endif;

    if const or constflg;
       df = nobs-nvar-1;
    else;
       df = nobs-nvar;
    endif;

    if df == 0;
        goto errout(32);
    elseif df<0;
        goto errout(31);
    endif;

    sse = cyy-b'*cxy;
    if const or constflg;
        k = -cxxi*mn[1:nvar]/constvlu;
        vc = (sse/df)*(((1/constvlu-mn[1:nvar]'*k)/constvlu|k)~(k'|cxxi));
        stderr = sqrt(diag(vc));
        t = (constant|b)./stderr;
        tv = nobs*cyy;
    else;
        vc = (sse/df)*cxxi;
        stderr = sqrt(diag(vc));
        t = b./stderr;
        tv = nobs*(cyy - mn[nvar1]^2);
    endif;
    sse = nobs*sse;
    rsq = (tv - sse)/tv;
    rbsq = 1-(1-rsq)*((nobs-1)/df);
    fstat = (rsq/(1-rsq))*(df/nvar);
    if fstat>0;
        pvf = cdffc(fstat,nvar,df);
    else;
        pvf = mss;
    endif;
    pvt = 2*cdftc(abs(t),df);

    if sse > 0;
      stdest = sqrt(sse/df);
    else;
      stdest = error(0);
    endif;

    stdb = b.*(std[1:nvar]/std[nvar1]);     /* Standardized coefficients  */
    if const or constflg;
        stdb = mss|stdb;
    endif;

    if oc0.res;
        old = ndpcntrl(0,0);
        call ndpcntrl(1,1);
        prcn = 8;
        if oc0.res == 4;
            prcn = 4;
        endif;
		tmpnm = oc0.rnam;
        create fout = ^tmpnm with u,1,prcn;
        if fout == -1;
            errorlog "Can't open temporary file for residuals";
            end;
        endif;
        call seekr(fin,1);
        clear dwstat,u2,i;
        do until eof(fin);
            i = i + 1;
            y0 = readr(fin,nr);
            y0 = y0[.,vardx];
            if oc0.miss == 2;
                y0 = missrv(y0,0);
            endif;
            if constflg;
                y0 = y0[.,cvec];
            endif;
            u = y0[.,nvar1]-y0[.,1:nvar]*b - constant*constvlu;
            ndpclex;
            if writer(fout,u) /= rows(u);
                errorlog "ERROR - disk full, Durbin-Watson statistic no"\
                    "t computed";
                end;
            endif;
            if oc0.miss;
                u = packr(u);
            endif;
            u2 = u2+u'*u;
            if nr > 1;
              dwstat = dwstat+sumc((trimr(u,1,0)-trimr(u,0,1))^2);
            endif;
            if i > 1 and i < tobs;
              dwstat = dwstat + (u[1] - dd)^2;
            endif;
            dd = u[rows(u)];
        endo;
        dwstat = dwstat/u2;
        call ndpcntrl(old,0xffff);
    else;
        u = 0;
        dwstat = 0;
    endif;
    if const or constflg;
        b = constant|b;
    endif;

    if oc0.output;
		colwid = maxc(maxc(strlen(indvarnms)+1)|9);
        print ftos(nobs,"Valid cases:  %*.*f",20,0);;
        print "      Dependent variable:" strcombine(satostrC(depvarnm,"%20.18s"),"",0);

        print ftos(mobs,"Missing cases:%*.*f",20,0);;
        print "      Deletion method:               ";;
        if oc0.miss == 0;
            print "    None";
        elseif oc0.miss == 2;
            print "Pairwise";
        else;
            print "Listwise";
        endif;

        print ftos(tv,"Total SS:     %*.*f",20,3);;

        print ftos(df,"      Degrees of freedom:%*.*f",20,0);

        print ftos(rsq,"R-squared:    %*.*f",20,3);;
        print ftos(rbsq,"      Rbar-squared:      %*.*f",20,3);
        print ftos(sse,"Residual SS:  %*.*f",20,3);;
        print ftos(stdest,"      Std error of est:  %*.*f",20,3);
        str = ftos(nvar,"F(%*.*f,",1,0) $+ ftos(df,"%*.*f):             "
            ,1,0);
        str = strsect(str,1,15) $+ ftos(fstat,"%*.*f",19,3);
        print str;;
        print ftos(pvf,"      Probability of F:  %*.*f",20,3);

        if oc0.res;
            print ftos(dwstat,"Durbin-Watson:%*.*f",20,3);
        endif;
        print;
        print chrs(32*ones(colwid,1))$+"                Standard                 Prob   Sta"\
            "ndardized  Cor with";
        print "Variable"$+chrs(32*ones(colwid-8,1))$+"    Estimate      Error      t-value"\
			"     >|t|     Estimate    Dep Var";

        print chrs(45*ones(70+colwid,1));;
        omat = b~stderr~t~pvt~stdb;
        if const or constflg;
            omat = omat~(mss|cor[1:nvar,nvar1]);
        else;
            omat = omat~cor[1:nvar,nvar1];
        endif;
        ms = ftos(mss,"%*.*f",1,0);
        msym "---  ";
		fmt = ("%-"$+ftos(colwid,"%*.*f",1,0)$+"."$+ftos(colwid,"%*.*f",1,0)$+"s") $|
				"%12.6f" $| "%12.6f" $| "%12.6f" $| "%10.3f" $| "%12.6f" $| "%12.6f";
		ostr = satostrC(indvarnms,fmt[1]) $~ ftostrC(omat,fmt[2:7]);
		ostr = strcombine(ostr,"",0);
		print ostr;
        msym ^ms;
    endif;
    if fin > 0;
        fin = close(fin);
    endif;
    if fout > 0;
        fout = close(fout);
    endif;

    m = (1~mn')|(mn~m);

	oout0.vnam = vnames;
	oout0.m = nobs*m;
	oout0.b = b;
	oout0.stb = stdb;
	oout0.vc = vc;
	oout0.stderr = stderr;
	oout0.sigma = stdest;
	oout0.cx = cor;
	oout0.rsq = rsq;
	oout0.resid = u;
	oout0.dwstat = dwstat;
    retp(oout0);

ERROUT:
        pop be;
    if be == 34;
        errorlog "ERROR: File not found: " $+ dataset;
    elseif be == 30;
        errorlog "ERROR: covariance matrix of independent variables is sing"\
            "ular.";
    elseif be == 31;
        errorlog "ERROR: system underdetermined";
    elseif be == 32;
        errorlog "ERROR: same number columns as rows";
    elseif be == 33;
        errorlog "ERROR: too many missings";
    elseif be == 35;
        errorlog "ERROR: no variation in at least one independent variable";
    else;
        errorlog "Coefficients vector is an error code: " $+ ftos(be,"%*.*l"\
            "f",1,0);
    endif;
    if fin > 0;
        fin = close(fin);
    endif;
    if fout > 0;
        fout = close(fout);
    endif;
	oout0.vnam = 0;
	oout0.m = 0;
	oout0.b = 0;
	oout0.stb = error(be);
	oout0.vc = 0;
	oout0.stderr = 0;
	oout0.sigma = 0;
	oout0.cx = 0;
	oout0.rsq = 0;
	oout0.resid = 0;
	oout0.dwstat = 0;
    retp(oout0);

endp;


/*
**> olsqrmt
**
**  Purpose:    Computes ols coefficients using qr decomposition.
**
**  Format:     b = olsqrmt(y,x,tol);
**
**  Input:      y       Nx1 vector containing dependent variable.
**
**              x       NxP matrix containing independent variable.
**
**              tol     scalar, the tolerance for testing if
**                      diagonal elements are approaching zero. 
**
**  Output:     b       Px1 vector of least squares estimates of
**                      regression of y on x. If x does not have full
**                      rank, then the coefficients that cannot be
**                      estimated will be zero.
**
**  Remarks:    This provides an alternative to y/x for computing
**              least squares coefficients.
**
**              This procedure is slower than the / operator.
**              However, for near singular matrices it may
**              produce better results.
**
**              olsqrmt handles matrices that do not have full rank
**              by returning zeros for the coefficients that can
**              not be estimated.
**
**  See Also:   olsqr, olsqr2, orth, qr
*/

proc olsqrmt(y,x,tol);
    local flag,n,p,qraux,work,pvt,job,b,k,
        rsd,xb,info,qy,qty,rd;

    /* check for complex input */
    if iscplx(x);
        if hasimag(x);
            errorlog "ERROR: Not implemented for complex matrices.";
            end;
        else;
            x = real(x);
        endif;
    endif;

    if iscplx(y);
        if hasimag(y);
            errorlog "ERROR: Not implemented for complex matrices.";
            end;
        else;
            y = real(y);
        endif;
    endif;

    n = rows(x);
    p = cols(x);
    qraux = zeros(p,1);
    work = qraux;
    pvt = qraux;
    flag = 1;       /* Use pivoting */
        /* compute matrix dimensions and other inputs to qrsl subroutine  */
    if rows(y) ne n;
        errorlog "ERROR: OLSQR - X and Y must have same length";
        end;
    elseif n < p;
        errorlog "ERROR: OLSQR - Problem is underdetermined (N < P)";
        end;
    endif;

    b = zeros(p,1);         /* Vector to hold ols coeffs */
    rsd = zeros(n,1);       /* Vector to hold residuals */
    xb = rsd;       /* Vector to hold predicted values */
    info = 0;
    job = 111;      /* compute b, rsd, xb */
    qy = rsd;
    qty = rsd;

    k = minc(n|p);

    x = x';

    dllcall qrdc(x,n,n,p,qraux,pvt,work,flag);

    rd = abs(diag(trimr(x',0,n-p)));        /* abs of diagonal of R  */
    k = sumc( rd .> tol*rd[1,1] );     /* number of diagonal elements of
                                            :: R that are greater than
                                            :: tolerance
                                            */

    dllcall qrsl(x,n,n,k,qraux,y,qy,qty,b,rsd,xb,job,info);

    /* sort b to put it in correct order */
    b = submat( sortc(b~pvt,2),0,1);

    retp(b);
endp;

