/*
** gdt_impute_ems.src
**
**
** (C) Copyright 2003  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** if you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
**-------------------**------------------**-------------------**-----------**
**-------------------**------------------**-------------------**-----------**
**
**
**> _gdt_impute_ems
**
**  Purpose:    generates simulated data based on logit model
**
**  Format:     { r,s } = _gdt_impute_ems(args,names,types);
**
**  Input:      args     string array, keywords for simulation options
**
**                         use    list of variables, default is all.
**                        mult    multiplicity for multiple imputation, default = 1.
**                         tol    tolerance for convergence, default = 1e-4.
**                    maxiters    maximum number of iterations.
**                      geninv    generalized inverse used
**                        seed    random number generator seed. Default = 345678.
**
**
**  Output:     r           scalar, return code.  Normal return = 0.
**              s           vector, variable types of output data set
**
*/


#include gdttools.ext

proc (2) = _gdt_impute_ems(args,names,types);

    local useVars,keep,mult,tol,b1,b2,geninv,maxiters,allmissing,
        nv,nv2,syy,mn,di0,diff,it,syy1,y,y1,c,d,ssyi,x1,v,s1,syyi,s2,
        k,k1,wi,wi2,dw1,dw2,mn1,mn2,oldt,csyy,rnd,st0,gdt,selv,yh,mx1,mx2;

    if not ismiss(_gdt_impute_data);
        errorlog "Error: no missing values in data";
        retp(-1,0);
    endif;

    useVars = {};
    keep = {};
    mult = 1;
    tol = 1e-4;
    b1 = 2;
    b2 = 1.25;
    geninv = 0;
    maxiters = 500;
    st0 = 345678;

    for i(1,rows(args),1);

        if args[i] $/= "";

            { s1,s2 } = token(args[i]);
            if lower(s1) $== "use";
                 useVars = strsplit(s2)';
            elseif lower(strsect(s1,1,4)) $== "mult";
                 mult = stof(s2);
            elseif lower(strsect(s1,1,3)) $== "tol";
                 tol = stof(s2);
            elseif lower(strsect(s1,1,3)) $== "max";
                 maxiters = stof(s2);
            elseif lower(strsect(s1,1,5)) $== "geninv";
                 geninv = 1;
            elseif lower(s1) $== "seed";
                 st0 = stof(s2);
            endif;
        endif;
     endfor;

    b2 = b2^2;
    mult = mult - 1;
    if mult < 0;
        mult = 0;
    endif;

    if not scalmiss(useVars);
        selv = indsav(useVars,names);
    else;
        selv = seqa(1,1,rows(names));
    endif;

    for i(1,rows(names),1);
        if types[i] == 0;
            types[i] = 1;
            errorlog "WARNING: variable No. "$+ftos(i,"*.*lf",1,0)$+" may be categorical.  Analysis\n"\
                     "will continue with this variable coded to a sequence,\n"\
                     "However, it may not conform to the assumptions of the\n"\
                     "missing data model which requires Normality.";
            yh = unique(_gdt_impute_data[.,i],0);
            _gdt_impute_data[.,i] = sumc(seqa(1,1,rows(yh)).*(_gdt_impute_data[.,i]' .$== yh));
        endif;
    endfor;

    allmissing = {};
    for i(1,rows(_gdt_impute_data),1);
        if _gdt_impute_data[i,.] == error(0);
            allmissing = allmissing | i;
        endif;
    endfor;

    mx1 = maxc(_gdt_impute_data);
    mx2 = minc(_gdt_impute_data);
    mx2 = mx1 + mx2;
    mx1 = 2*mx1 - mx2;

    _gdt_impute_data = (2*_gdt_impute_data - mx1') ./ mx2';

    if selv > 0;
        nv = rows(selv);
    else;
        nv = cols(_gdt_impute_data);
    endif;
    syy = eye(nv);
    mn = zeros(nv,1);
    di0 = sqrt(nv) + b1/2;
    diff = ones(nv,1);
    clear it;

    do until diff < tol or it > maxiters;

        it = it + 1;

        clear syy1, mn1, mn2, dw1, dw2;

        for i(1,rows(_gdt_impute_data),1);

            if not(i /= allmissing);
                continue;
            endif;

            y = _gdt_impute_data[i,selv];
            y1 = y ./= error(0);

            c = delif(seqa(1,1,cols(y1)),y1');
            d = selif(seqa(1,1,cols(y1)),y1');

            if not scalmiss(c);

                oldt = trapchk(1);
                trap 1,1;
                syyi = invpd(syy[d,d]);
                trap oldt,1;
                if scalerr(syyi);
                    if geninv;
                        ssyi = invswp(syy[d,d]);
                    else;
                        errorlog "ERROR: inverse failed for row "$+ftos(i,"*.*lf",1,0);
                        retp(-1,0);
                    endif;
                endif;

                x1 = mn[c,1] + syy[c,d] * syyi * (y[1,d]'-mn[d,1]);
                v = zeros(nv,nv);
                v[c,c] = syy[c,c] - syy[c,d] * syyi * syy[d,c];
                y[1,c] = x1';
                mn1 = mn1 + y';
                syy1 = syy1 + moment(y,0) + v;
            else;
                mn1 = mn1 + y';
                syy1 = syy1 + moment(y,0);
            endif;

        endfor;

        mn1 = mn1 / rows(_gdt_impute_data);
        syy1 = syy1 / rows(_gdt_impute_data);
        diff = abs((diag(syy1)-diag(syy))./diag(syy));
        syy = syy1;
        mn = mn1;

    endo;

    oldt = trapchk(1);
    trap 1,1;
    csyy = chol(syy);
    trap oldt,1;

    for i(1,rows(_gdt_impute_data),1);

        y = _gdt_impute_data[i,selv];
        y1 = y ./= error(0);
        c = delif(seqa(1,1,cols(y1)),y1');
        d = selif(seqa(1,1,cols(y1)),y1');

        if scalmiss(d);

            if scalerr(csyy);
                errorlog "ERROR: Cholesky factorization failed for entire estimated\n"\
                         "covariance matrix.  This factorization required only for\n"\
                         "observation "$+ftos(i,"*.*lf",1,0)$+" which is missing on\n"\
                         "all variables.";
                retp(-1,0);
            endif;

            { rnd,st0 } = rndKMu(1,nv,st0);
            _gdt_impute_data[i,selv] = mn' + rnd * csyy;

            for j(1,mult,1);
               { rnd,st0 } = rndKMu(1,nv,st0);
               _gdt_impute_data = _gdt_impute_data | (mn' + rnd * csyy);
            endfor;

        elseif not scalmiss(c);

            oldt = trapchk(1);
            trap 1,1;
            ssyi = invpd(syy[d,d]);
            trap oldt,1;
            if scalerr(ssyi);
                if geninv;
                    ssyi = invswp(syy[d,d]);
                else;
                    errorlog "ERROR: inverse failed for row "$+ftos(i,"*.*lf",1,0);
                    retp(-1,0);
                endif;
            endif;

            syy1 = syy[c,c] - syy[c,d]*ssyi*syy[d,c];

            oldt = trapchk(1);
            trap 1,1;
            csyy = chol(syy1);
            trap oldt,1;
            if scalmiss(csyy);
                if geninv;
                    csyy = invswp(syy1);
                else;
                    errorlog "ERROR: Cholesky failed for row "$+ftos(i,"*.*lf",1,0);
                    retp(-1,0);
                endif;
            endif;

            mn1 = syy[c,d]*ssyi*y[1,d]';
            { rnd,st0 } = rndKMu(1,rows(csyy),st0);
            _gdt_impute_data[i,selv[c]] = mn1' + rnd * csyy;
            if mult;
                gdt = _gdt_impute_data[i,.];
                for j(1,mult,1);
                    { rnd,st0 } = rndKMu(1,rows(csyy),st0);
                    gdt[i,selv[c]] = mn1' + rnd * csyy;
                    _gdt_impute_data = _gdt_impute_data | gdt;
                endfor;
            endif;
        endif;
    endfor;

    _gdt_impute_data = 0.5*(_gdt_impute_data.*mx2' + mx1');

    retp(0,types);

endp;





proc(0) = _gdt_impute_ems_help;

    local s1;

    s1 = "
Purpose: imputes missing data using the EMS algorithm

Format:  impute ems
         [options]

Code Example: 

         impute ems
         file test
         use x1,x2,x3

Options: use       list of variables, default is all 
         mult      multiplicity for multiple imputation, default = 1
         tol       tolerance for convergence, default = 1e-4
         maxiters  maximum number of iterations
         geninv    use generalized inverse 
         seed      random number generator seed. Default = 345678";

   print s1;

endp;
