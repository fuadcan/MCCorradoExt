
/*
** fastcutil.src    Fast CML procedures
**
**
** (C) Copyright 1994-2001  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
**-------------------**------------------**-------------------**-----------**
**-------------------**------------------**-------------------**-----------**
*/

#include cml.ext

proc(11) = _fastcml( dataset,var,&lfct,start, Lcmlalgr, Lcmlcovp, Lcmldelta,
    Lcmlextrp, Lcmlgdmd, Lcmlgdprc, Lcmlgtol, Lcmlhsprc, Lcmlintrp, 
    Lcmlmiter, Lcmlmtime, Lcmlmxtry, Lcmlnobs, Lcmlparnm,Lcmlswch,LcmlGS,
    Lcmlgsradius,Lcmltrust,Lcmltrustradius,Lcmlstep, Lcmloption, LcmlActive, 
    Lcmlgrdh, Lcmlgrdord, LLaltnam, LLweight );

    local Lcmlfhess, Lcmlhsvcp, LcmlCpvcp, Lcmlitdta, Lcmldiag;
    local oldfmt,x,g,s,h,iter,ky,old,vof,x0,fhandle,parnms,bksteps,dx,z,
        algrm,stepm,covpm,gradm,outm,algr0,step0,covp0,grad0,out0,stout,
        smallval,pg,k0,k1,k2,lr,lf,ll,np,tme,f0,tstart,w0,w1,w2,w3,w4,w5,
        w6,w7,w8,w9,w10,h1,ttime,isctu,mask,fmt,omat,row,oldt,dfct,ib,dd,
        wgts,dum,cpmeth,y,htype,q1,q2,vnames,vindx,ret,isConstraints,nobs,
        tmpop,ok,jsw,ksw,msw,isw,grdprc,hsprc,g0,dontstop,lfct:proc;

    local numeq,qp_e,qp_t,qp_xl,qp_xu,qp_ret,qp_maxit,lagr1,lagr2,
        _c,_lg,ia,qp_a,qp_b,qp_d,qp_lql,lg_b,lg_xl,lg_xu,_eps,gcoefs;
    local Lcmllagr;
    local numNlinEqC,numNlinIneqC,numLinEqC;
    local eqproc,ineqproc,eqjacob,ineqjacob;

    clear Lcmllagr,lagr1,lagr2,qp_ret,qp_e,ib,nobs;
    clear bksteps,s,dfct,fhandle,h,iter,dontstop;
    clear numeq,numLinEqC,numNlinEqC,numNlinIneqC;
    cpmeth = "";

    if dataset $== 0;
        dataset = error(0);
    endif;

    start = vec(start);
    Lcmlfhess = { . };
    Lcmlitdta = { . , . , . };
    Lcmlcpvcp = { . };
    Lcmlhsvcp = { . };

    dx = 1;
    isctu = 1;
    smallval = 1e-15;
    isw = 1;
    ksw = 1;
    msw = 1;

    algrm = { BFGS, DFP, NEWTON, BHHH, BFGS-SC, DFP-SC, NR };
    algr0 = { 1, 2, 3, 4, 5, 6, 3 };
    stepm = { 1.0, STEPBT, HALF, BRENT, BHHHSTEP, 1, ONE, GOLDEN };
    step0 = { 1, 2, 3, 4, 5, 1, 1, 4 };
    covpm = { NOCOVP, INFO, XPROD, HETCON, NOCOV, HESS, QML };
    covp0 = { 0, 1, 2, 3, 0, 1, 3 };
    gradm = { CENTRAL, FORWARD, BACKWARD };
    grad0 = { 0, 1, 2 };

    old = ndpcntrl(0,0);
    call ndpcntrl(1,1);

    Lcmlalgr = _cml_check(Lcmloption,Lcmlalgr,algrm,algr0,3);
    Lcmlstep = _cml_check(Lcmloption,Lcmlstep,stepm,step0,2);
    Lcmlcovp = _cml_check(Lcmloption,Lcmlcovp,covpm,covp0,1);
    Lcmlgdmd = _cml_check(Lcmloption,Lcmlgdmd,gradm,grad0,1);

    _eps = zeros(2,1);
    if _cml_GradMethod == 0;
        _eps[1] = __macheps^(1/3);
    else;
        _eps[1] = __macheps^(1/2);
    endif;
    _eps[2] = __macheps^(1/3);

    if _cml_GradOrder > 0;
        gcoefs = _cml_GetGradCoefs(Lcmlgrdord);
    else;
        gcoefs = _cml_GetGradCoefs(1);
    endif;

    if lcmlgdprc /= 0;
        grdprc = &_fastcml_grdusr;
    elseif Lcmlgrdord == 0;
        if lcmlgdmd == 0;
            grdprc = &_fastcml_grdcd;
        elseif lcmlgdmd == 1;
            grdprc = &_fastcml_grdfd;
        else;
            grdprc = &_fastcml_grdbd;
        endif;
    else;
        if lcmlgdmd == 0;
            grdprc = &_fastcml_mpgrdcd;
        elseif lcmlgdmd == 1;
            grdprc = &_fastcml_mpgrdfd;
        else;
            grdprc = &_fastcml_mpgrdbd;
        endif;
    endif;
    local grdprc:proc;

    if lcmlhsprc /= 0;
        hsprc = &_fastcml_hsusr;
    elseif lcmlgdprc /= 0;
        if lcmlgrdord == 0;
            if lcmlgdmd == 0;
                hsprc = &_fastcml_hsgdcd;
            elseif lcmlgdmd == 1;
                hsprc = &_fastcml_hsgdfd;
            else;
                hsprc = &_fastcml_hsgdbd;
            endif;
        else;
            if lcmlgdmd == 0;
                hsprc = &_fastcml_mphsgdcd;
            elseif lcmlgdmd == 1;
                hsprc = &_fastcml_mphsgdfd;
            else;
                hsprc = &_fastcml_mphsgdbd;
            endif;
        endif;
    else;
        if lcmlgrdord == 0;
            hsprc = &_fastcml_hssp;
        else;
            hsprc = &_fastcml_mphssp;
        endif;
    endif;
    local hsprc:proc;

    if not scalmiss(Lcmlswch);
        if rows(Lcmlswch) < 4;
            if cols(Lcmlswch) == 1;
                Lcmlswch = Lcmlswch[1,1];
                Lcmlswch = Lcmlswch | .001 | 10 | .001;
            else;
                Lcmlswch = Lcmlswch[1,.];
                Lcmlswch = Lcmlswch | (.001~.001) | (10~10) | (.001~.001);
            endif;
        endif;
    endif;

    if not(LcmlActive == 1) and (rows(LcmlActive) /= rows(start));
        if not trapchk(4);
            errorlog "ERROR:  _cml_Active not conformable to start vector";
        endif;
        retp(start,error(0),error(0),error(0),10,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                Lcmlhsvcp,Lcmlnobs,Lcmllagr);
    endif;

    qp_maxit = 1000;
    qp_e = eye(rows(start))|-eye(rows(start));
    qp_t = 1e+256*ones(rows(start),1);

    Lcmllagr = vput(Lcmllagr,error(0),"lineq");
    Lcmllagr = vput(Lcmllagr,error(0),"linineq");
    Lcmllagr = vput(Lcmllagr,error(0),"nlineq");
    Lcmllagr = vput(Lcmllagr,error(0),"nlinineq");
    Lcmllagr = vput(Lcmllagr,error(0),"bounds");
    Lcmllagr = vput(Lcmllagr,error(0),"eqcov");
    Lcmllagr = vput(Lcmllagr,error(0),"ineqcov");

    if not(LcmlActive /= 0);
        ib = packr(miss(seqa(1,1,rows(LcmlActive)).*(LcmlActive .== 0),0));
        dd = trimr(design(ib|rows(LcmlActive)),0,1);
        ib = packr(miss(seqa(1,1,rows(LcmlActive)).*(LcmlActive ./= 0),0));
        numEq = rows(dd);
        numLinEqC = numEq;
    endif;

    if not scalmiss(_cml_A);
        numEq = numEq + rows(_cml_A);
        numLinEqC = numEq;
    endif;

    if not scalmiss(_cml_EqProc);
        eqproc = _cml_EqProc;
        local eqproc:proc;
        numNlinEqC = rows(EqProc(start));
        numEq = numEq + numNlinEqC;
    endif;

    if not scalmiss(_cml_IneqProc);
        ineqproc = _cml_IneqProc;
        local ineqproc:proc;
        numNlinIneqC = rows(IneqProc(start));
    endif;

    if not scalmiss(_cml_EqJacobian);
        eqjacob = _cml_EqJacobian;
        local eqjacob:proc;
    endif;

    if not scalmiss(_cml_IneqJacobian);
        ineqjacob = _cml_IneqJacobian;
        local ineqjacob:proc;
    endif;

    if not scalmiss(_cml_Bounds);
        if cols(_cml_Bounds) /= 2 or (rows(_cml_Bounds) /= rows(start) and
            rows(_cml_Bounds) /= 1);
            if not trapchk(4);
                errorlog "ERROR:  _cml_Bounds is not correctly defined";
            endif;
            retp(start,error(0),error(0),error(0),9,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                        Lcmlhsvcp,Lcmlnobs,Lcmllagr);
        endif;
        if not(_cml_Bounds[.,1] < _cml_Bounds[.,2]);
            if not trapchk(4);
                errorlog "ERROR:  an upper bound is less than a lower bound";
            endif;
            retp(start,error(0),error(0),error(0),9,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                       Lcmlhsvcp,Lcmlnobs,Lcmllagr);
        endif;
    endif;

    if type(var) == 13;
        var = stof(var);
    endif;

    if type(LLweight) == 13;
        LLweight = stof(LLweight);
    endif;

    wgts = error(0);
    if type(dataset) == 13 and dataset $/= "";
        fhandle = -1;
        open fhandle = ^dataset;
        _cml_dsn = dataset;
        if fhandle == -1;
            if not trapchk(4);
                errorlog dataset $+ " could not be opened";
            endif;
            retp(start,error(0),error(0),error(0),34,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                       Lcmlhsvcp,Lcmlnobs,Lcmllagr);
        endif;
        if var $== 0;
            vindx = 0;
        else;
            { vnames,vindx } = indices(dataset,var);
        endif;
        if not(LLweight $== 0);
            if rows(LLweight) == 1;
                { dum, wgts } = indices(dataset,LLweight);
                if scalmiss(wgts);
                    if not trapchk(4);
                        errorlog "weights could not be found in "$+dataset;
                    endif;
                    retp(start,error(0),error(0),error(0),12,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                            Lcmlhsvcp,Lcmlnobs,Lcmllagr);
                endif;
                nobs = 0;
            else;
                wgts = LLweight;
                if rows(wgts) /= rowsf(fhandle);
                    if not trapchk(4);
                        errorlog "weight vector not conformable";
                    endif;
                    retp(start,error(0),error(0),error(0),12,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                                Lcmlhsvcp,Lcmlnobs,Lcmllagr);
                endif;
                nobs = sumc(wgts);
            endif;
        else;
            nobs = rowsf(fhandle);
        endif;
        k1 = getnr(6,rows(var));

        if k1 >= rowsf(fhandle);
            call seekr(fhandle,1);
            dataset = { };

            k1 = getnr(6,colsf(fhandle));
            do until eof(fhandle);
                y = readr(fhandle,k1);
                dataset = dataset|y[.,vindx];
                if not(LLweight $== 0) and rows(LLweight) == 1;
                    nobs = nobs + sumc(y[.,wgts]);
                endif;
            endo;
            clear y;
            if LLweight $== 0 or rows(LLweight) /= 1;
                nobs = rows(dataset);
            endif;
            if fhandle > 0;
                fhandle = close(fhandle);
            endif;
        else;

            if not trapchk(4);
                errorlog "ERROR: dataset could not be read into memory";
            endif;
            retp(start,error(0),error(0),error(0),12,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                           Lcmlhsvcp,Lcmlnobs,Lcmllagr);

        endif;
    elseif not scalmiss(dataset);
        if LLaltnam[1] $/= "" and var $/= "";
            if not(LLweight == 0) and rows(LLweight) == 1;
                wgts = dataset[.,indcv(var,LLweight)];
                nobs = sumc(wgts);
            endif;
            dataset = dataset[.,indcv(var,LLaltnam)];
        elseif var $/= "";
            if not(LLweight == 0) and rows(LLweight) == 1;
                wgts = dataset[.,LLweight];
                nobs = sumc(wgts);
            endif;
            dataset = dataset[.,var];
        endif;
        if not(LLweight == 0) and rows(LLweight) > 1;
            wgts = LLweight;
            nobs = sumc(wgts);
        else;
            wgts = error(0);
            nobs = rows(dataset);
        endif;
    endif;
    clear LLweight;

    if scalmiss(lcmlnobs) or lcmlnobs <= 1;
        if nobs < 1;    
            nobs = rows(lfct(x0,dataset));
            if nobs <= 1;
                if not trapchk(4);
                    errorlog "ERROR:  Number of observations not set";
                endif;
                retp(start,error(0),error(0),error(0),35,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                           Lcmlhsvcp,Lcmlnobs,Lcmllagr);
            else;
                lcmlnobs = nobs;
                wgts = error(0);
                Lcmlcovp = 1;
                if lcmlalgr == 2;
                    lcmlalgr = 1;
                endif;
            endif;
        else;
            Lcmlnobs = nobs;
        endif;
    endif;

    x0 = start;


/*****************************************************************/
/*****************************************************************/

    if Lcmlparnm $/= 0 and rows(Lcmlparnm) /= rows(x0);
        if not trapchk(4);
            if not trapchk(4);
                errorlog "vector of parameter labels does not conform to ve"\
                    "ctor of starting values";
            endif;
        endif;
        parnms = 0;
    else;
        parnms = Lcmlparnm;
    endif;
    if parnms $== 0;
        let mask[1,3] = 1 1 1;
        let fmt[3,3] = "lf " 8 0 "lf" 18 4 "lf" 18 4;
    else;
        let mask[1,3] = 0 1 1;
        let fmt[3,3] = "s " 8 8 "lf" 18 4 "lf" 18 4;
    endif;

/****************************************************************************/
/*                     BEGIN OPTIMIZATION                                   */
/****************************************************************************/
    tstart = date;

    if scalmiss(wgts);
         vof = sumc(packr(-lfct(x0,dataset)))/lcmlnobs;
    else;  
         vof = sumc(packr(-wgts.*lfct(x0,dataset)))/lcmlnobs;
    endif;

    if scalInfNanMiss(vof);
        if not trapchk(4);
            if not trapchk(4);
                errorlog "ERROR:  function cannot be computed at initial pa"\
                    "rameter values";
            endif;
        endif;
        retp(start,error(0),error(0),error(0),7,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                Lcmlhsvcp,Lcmlnobs,Lcmllagr);
    endif;

    np = rows(x0);          /* Number of parameters to estimate */

    g0 = grdprc(&lfct,x0,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);

    if isInfNanMiss(g0);
        dontStop = 1;
    else;
        dontStop = 0;
    endif;
    g = sumc(packr(g0))/lcmlnobs;
    clear g0;

    if scalmiss(g);
        if not trapchk(4);
            errorlog "gradient function failed at initial values";
        endif;
        retp(start,error(0),error(0),error(0),7,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                Lcmlhsvcp,Lcmlnobs,Lcmllagr);
    endif;

    if not(rows(x0) == 1 and rows(x0) == 1);
        if rows(g) == 1 and cols(g) == rows(x0);
            if not trapchk(4);
                if not trapchk(4);
                    errorlog "The gradient function has returned a column v"\
                        "ector rather than the required row vector";
                endif;
            endif;
            retp(start,error(0),error(0),error(0),8,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                 Lcmlhsvcp,Lcmlnobs,Lcmllagr);
        endif;
    endif;
    if rows(g) /= rows(x0);
        if not trapchk(4);
            if not trapchk(4);
                errorlog "The number of elements in the gradient function";
                errorlog "is inconsistent with the number of starting values";
            endif;
        endif;
        retp(start,error(0),error(0),error(0),8,Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
                Lcmlhsvcp,Lcmlnobs,Lcmllagr);
    endif;

    if Lcmlalgr == 3;

        h = hsprc(&lfct,x0,dataset,Lcmlgdprc,Lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts)/lcmlnobs;

    elseif Lcmlalgr == 4;

        h = moment(grdprc(&lfct,x0,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts),1)/lcmlnobs;

    endif;
    if scalmiss(h) or (Lcmlalgr /= 3 and Lcmlalgr /= 4);
        h = eye(np)*maxc(sqrt(abs(vof))|1);
    endif;

    if Lcmltrust;
        q1 = abs(g);
        qp_d = (q1./(g+(g .== 0))).*minc(q1'|.99*Lcmltrustradius.*ones(1,np));
    else;
        qp_d = .1*abs(g);
    endif;


    ttime = date;
A0:

/* ********* Start of iteration loop ********** */
    iter = iter + 1;
    f0 = vof;
    tstart = date;


#ifdef DIAG
    print;
    print;
    print "f    " vof;
    print;
    print "pars " x0';
    print;
    print "grad " g';
    print;
    print "h ";
    print;
    if Lcmlalgr <= 2;
        print h'h;
    elseif Lcmlalgr <= 4;
        print h;
    elseif Lcmlalgr <= 6;
        print h*h';
    endif;
#endif

    if Lcmlalgr <= 2;
        qp_lql = 0;
    elseif Lcmlalgr == 3 or Lcmlalgr == 4;
        qp_lql = 1;
        if Lcmldelta > 0;
            { q1,q2 } = eigrs2(h);
            if not (q1 >= 0);
                if not trapchk(4);
                    if Lcmlalgr == 3;
                        errorlog "Newton iteration failed";
                    elseif Lcmlalgr == 4;
                        errorlog "BHHH iteration failed";
                    endif;
                endif;
                q1 = q1 + Lcmldelta - minc(q1);
                h = q2*diagrv(eye(rows(q1)),q1)*q2';
            endif;
        endif;
    elseif Lcmlalgr >= 5;
        h = qr(h');
    endif;

    if not(LcmlActive /= 0);
        qp_a = dd;
        qp_b = zeros(rows(dd),1);
    else;
        qp_a = { };
        qp_b = { };
    endif;

    if not scalmiss(_cml_A);
        qp_a = qp_a | _cml_A;
        qp_b = qp_b | -_cml_A*x0 + _cml_B;
    endif;

    if not scalmiss(_cml_EqProc);
        if not scalmiss(_cml_EqJacobian);
            qp_a = qp_a | eqjacob(x0);
        else;
            qp_a = qp_a | gradp(&EqProc,x0);
        endif;
        qp_b = qp_b | -EqProc(x0);
    endif;

    if not scalmiss(_cml_C);
        qp_a = qp_a | _cml_C;
        qp_b = qp_b | -_cml_C*x0 + _cml_D;
    endif;

    if not scalmiss(_cml_IneqProc);
        if not scalmiss(_cml_IneqJacobian);
            qp_a = qp_a | ineqjacob(x0);
        else;
            qp_a = qp_a | gradp(&IneqProc,x0);
        endif;
        qp_b = qp_b | -IneqProc(x0);
    endif;

    if scalmiss(qp_a);
        qp_a = zeros(1,rows(x0));
        qp_b = -1e256;
        isconstraints = 0;
    else;
        isconstraints = 1;
    endif;

    if not scalmiss(_cml_Bounds);
        qp_xl = _cml_Bounds[.,1] - x0;
        qp_xu = _cml_Bounds[.,2] - x0;
    else;
        qp_xl = -qp_t;
        qp_xu = qp_t;
    endif;

    if Lcmltrust;
        q1 = LcmlTrustradius.*ones(1,np);
        qp_xl = maxc(qp_xl' | -q1);
        qp_xu = minc(qp_xu' | q1);
    endif;

    { lg_b,lg_xl,lg_xu,qp_d,qp_ret } = _intqpsolvfcn01(h,-g,qp_a,qp_b,
        qp_xl,qp_xu,qp_d,numeq,qp_maxit,qp_lql);

#ifdef DIAG
    print;
    print "dir " qp_d';
#endif

    if qp_ret < 0;

        x = x0;
        if not trapchk(4) and qp_ret < 0;
            errorlog "constraint no. "$+ftos(-qp_ret,"%*.*lf",1,0)$+" incon"\
                "sistent";
        endif;

        ret = error(9);
        goto A98;

    elseif qp_ret == 1;

        if not trapchk(4);
            errorlog "maximum iterations exceeded in QPSOLVE";
        endif;

    elseif qp_ret == 2;
        if not trapchk(4);
            errorlog "QPSOLVE iterations halted due to lack of precision";
        endif;
    endif;

    if not scalmiss(_cml_Bounds);
        k1 = qp_d .< (_cml_Bounds[.,1] - x0);
        qp_d = (1 - k1) .* qp_d + k1 .* (_cml_Bounds[.,1] - x0);
        k1 = qp_d .> (_cml_Bounds[.,2] - x0);
        qp_d = (1 - k1) .* qp_d + k1 .* (_cml_Bounds[.,2] - x0);
    endif;

    lagr2 = {};
    if isconstraints;
        if numeq >= 1;
            if abs(lagr1) < 1e-15;
                lagr1 = error(0);
            else;
                lagr1 = maxc(lg_b[1:numeq]);
            endif;
        else;
            lagr1 = error(0);
        endif;
        if numeq < rows(lg_b);
            lagr2 = maxc(lg_b[numeq+1:rows(lg_b)]);
        endif;
    else;
        lagr1 = error(0);
    endif;
    if not scalmiss(_cml_Bounds);
        lagr2 = maxc(lagr2|lg_xl|lg_xu);
    endif;
    if abs(lagr2) < 1e-15;
        lagr2 = error(0);
    endif;


/*  test for convergence  */

    if iter >= Lcmlmiter;
        ret = error(2);
        x = x0 + qp_d;
        x0 = x;
        goto A98;
    elseif ethsec(ttime,date)/6000 > Lcmlmtime;
        ret = error(11);
        x = x0 + qp_d;
        x0 = x;
        goto A98;
    endif;

    if not dontstop;
        if (abs(lagr1) < 1e-8 and abs(lagr2) < 1e-8);
            if (abs(g).*maxc(abs(x0)'|ones(1,rows(x0))))/ maxc(abs(vof)|1) <
                Lcmlgtol or abs(g) < smallval;
                x = x0 + qp_d;
                x0 = x;
                ret = error(0);
                goto A98;
            endif;
        else;
            if (abs(qp_d) < Lcmlgtol);
                x = x0 + qp_d;
                x0 = x;
                ret = error(0);
                goto A98;
            endif;
        endif;
    endif;  

    { s,bksteps } = _fastcml_stepl(g,x0,qp_d,&lfct,Lcmlstep,Lcmlintrp,
           Lcmlextrp,lagr1,lagr2,,dataset,Lcmlmxtry,_eps,wgts,lcmlnobs);

#ifdef DIAG
    print;
    print "s " s;
#endif

    if scalmiss(s) and LcmlGS;

        { x,vof } = _fastcml_GridSearch(&lfct,x0,f0,dataset,wgts,lcmlnobs,LcmlGSradius);
        s = error(0);
        dx = x - x0;
        qp_d = dx;
        x0 = x;

        if scalInfNanMiss(vof);
            ret = error(3);
            goto A98;
        endif;

    else;

        if scalmiss(s);
            if not trapchk(4);
                if scalerr(s) == 6;
                    errorlog "step length calculation failed";
                elseif scalerr(s) == 3;
                    errorlog "function calculation failed";
                endif;
            endif;
            ret = s;
            goto A98;
        endif;
    
        dx = s * qp_d;
        x = x0 + dx;
        x0 = x;

        if scalmiss(wgts);
             vof = sumc(packr(-lfct(x0,dataset)))/lcmlnobs;
        else;  
             vof = sumc(packr(-wgts.*lfct(x0,dataset)))/lcmlnobs;
        endif;
        if scalInfNanMiss(vof);
            ret = error(3);
            goto A98;
        endif;
    
    endif;

    if isctu;
        { g,h } = _fastcml_sctu(x0,vof,smallval,g,h,dx,qp_d,s,&lfct,
           &grdprc,&hsprc,dataset,Lcmlalgr,Lcmlgrdh,lcmlgdprc,lcmlhsprc,_eps,gcoefs,wgts,lcmlnobs);

        if Lcmlalgr <= 2;
            Lcmlfhess = h'h;
        elseif Lcmlalgr <= 4;
            lcmlfhess = h;
        elseif Lcmlalgr <= 6;
            lcmlfhess = h*h';
        endif;

        if scalmiss(g);
            ret = error(4);
            goto A98;
        elseif scalmiss(h);
            h = eye(np)*maxc(sqrt(abs(vof))|1);
        endif;
    else;

        g0 = grdprc(&lfct,x0,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts)/lcmlnobs;
    
        if isInfNanMiss(g0);
            dontStop = 1;
        else;
            dontStop = 0;
        endif;
        g = sumc(packr(g0));
        clear g0;

        if scalmiss(g);
            if not trapchk(4);
                errorlog "gradient calculation failed";
            endif;
            ret = error(4);
            goto A98;
        endif;
        isctu = 1;
    endif;

    dfct = f0 - vof;
    if not scalmiss(_cml_DFTol) and not dontstop;
        if abs(dfct) <= _cml_DFTol;
             ret = error(0);
             goto A98;
        endif;
    endif;


    if not scalmiss(Lcmlswch);
        jsw = 0;
        if ksw >= Lcmlswch[3,isw];
            jsw = 1;
        elseif dfct < Lcmlswch[2,isw] or s < Lcmlswch[4,isw];
            msw = msw + 1;
            if msw > 5;
                jsw = 1;
                msw = 1;
            else;
                jsw = 0;
            endif;
        endif;

        if jsw;
            if cols(Lcmlswch) == 2;
                if isw == 1;
                    isw = 2;
                else;
                    isw = 1;
                endif;
            endif;

            if lcmlalgr == 2;
                h = h'h;
            elseif lcmlalgr == 3;
                oldt = trapchk(1);
                trap 1,1;
                h = invpd(h'h);
                trap oldt,1;
                if scalmiss(h);
                    h = eye(np)*maxc(sqrt(abs(vof))|1);
                endif;
            elseif lcmlalgr == 7 or lcmlalgr == 8;
                h = h*h';
            endif;

            lcmlalgr = Lcmlswch[1,isw];

            oldt = trapchk(1);
            trap 1,1;
            if lcmlalgr == 1;
                h = chol(h);
            elseif lcmlalgr == 2;
                h = chol(invpd(h));
            elseif lcmlalgr >= 5;
                h = eye(np)*maxc(sqrt(abs(vof))|1);
            endif;
            trap oldt,1;
            if scalmiss(h);
                h = eye(np)*maxc(sqrt(abs(vof))|1);
            endif;

            jsw = 0;
            ksw = 1;
        else;
            ksw = ksw + 1;
        endif;
    endif;


    goto A0;

A98:

    tme = ethsec(ttime,date)/6000;
    
    ky = 1;
    if numLinEqC;
        Lcmllagr = vput(Lcmllagr,lg_b[ky:numLinEqC],"lineq");
    endif;

    if not scalmiss(_cml_EqProc);
        Lcmllagr = vput(Lcmllagr,lg_b[ky:ky+numNlinEqC-1],"nlineq");
    endif;

    if not scalmiss(_cml_C);
        Lcmllagr = vput(Lcmllagr,lg_b[ky:ky+rows(_cml_C)-1],"linineq");
    endif;

    if not scalmiss(_cml_IneqProc);
        Lcmllagr = vput(Lcmllagr,lg_b[ky:ky+numNlinIneqC-1],"nlinineq");
    endif;

    if not scalmiss(_cml_Bounds);
        Lcmllagr = vput(Lcmllagr,lg_xl~lg_xu,"bounds");
    endif;


    /* ******************** End of iteration loop ****************** */
    if Lcmlcovp == 1;
        cpmeth = "HESS";
    elseif Lcmlcovp == 2;
        cpmeth = "XPROD";
    else;
        cpmeth = "QML";
    endif;
    ok = scalerr(ret) <= 2 or scalerr(ret) == 11;
    if Lcmlcovp == 0;
        h = error(0);
        cpmeth = "NOCOVP";
    elseif ok;
        if Lcmlcovp == 2;

            h = moment(grdprc(&lfct,x0,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts),1);

        else;

            h = hsprc(&lfct,x0,dataset,Lcmlgdprc,Lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);

        endif;
        if scalmiss(h);
            cpmeth = "NOTPD";
            h = error(0);
            if Lcmlcovp == 1;
                Lcmlhsvcp = error(0);
            else;
                Lcmlcpvcp = error(0);
            endif;
        else;
            _c = { };
            _lg = { };
            if not scalmiss(_cml_Bounds);
                _c = qp_e | _c;
                if not scalmiss(vread(Lcmllagr,"bounds"));
                    _lg = vec(vread(Lcmllagr,"bounds"));
                endif;
            endif;
            if not scalmiss(_cml_IneqProc);
                _c = gradp(&IneqProc,x) | _c;
                if not scalmiss(vread(Lcmllagr,"nlinineq"));
                    _lg = vread(Lcmllagr,"nlinineq") | _lg;
                endif;
            endif;
            if not scalmiss(_cml_C);
                _c = _cml_C | _c;
                if not scalmiss(vread(Lcmllagr,"linineq"));
                    _lg = vread(Lcmllagr,"linineq") | _lg;
                endif;
            endif;
            if not scalmiss(_lg);
                ia = packr(miss(seqa(1,1,rows(_lg)).*(_lg ./= 0),0));
                if not scalmiss(ia);
                    _c = _c[ia,.];
                    Lcmllagr = vput(Lcmllagr,_cml_NumObs*invswp(_c*h*_c'),"ineq"\
                        "cov");
                else;
                    _c = {};
                endif;
            endif;

            if not scalmiss(_cml_A);
                _c = _cml_A | _c;
            endif;
            if not scalmiss(_cml_EqProc);
                _c = gradp(&EqProc,x) | _c;
            endif;
            if not scalmiss(_c);
                Lcmllagr = vput(Lcmllagr,_cml_NumObs*invswp(_c*h*_c'),"eqcov");
            endif;
            if not scalmiss(_c);
                oldt = trapchk(1);
                trap 1,1;
                z = null(_c);
                trap oldt,1;
                if not scalmiss(z);
                    oldt = trapchk(1);
                    trap 1,1;
                    h1 = solpd(eye(cols(z)),z'*h*z);
                    trap oldt,1;
                else;
                    h1 = error(0);
                endif;
                if scalmiss(h1);
                    oldt = trapchk(1);
                    trap 1,1;
                    h1 = pinv( (h~_c') | (_c~zeros(rows(_c),rows(_c))) );
                    trap oldt,1;
                    h1 = h1[1:rows(h),1:rows(h)];
                else;
                    h1 = z*h1*z';
                endif;
                h = h1;
            else;
                oldt = trapchk(1);
                trap 1,1;
                h1 = solpd(eye(rows(h)),h);
                trap oldt,1;
                h = h1;
            endif;

            if Lcmlcovp == 2;
                Lcmlcpvcp = h;
            else;
                Lcmlhsvcp = h;
            endif;
        endif;
    endif;
    if Lcmlcovp == 3 and ok and not scalmiss(Lcmlhsvcp);

        h1 = moment(grdprc(&lfct,x0,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts),1);

/*  presently don't compute inverse of cross-product
        oldt = trapchk(1);
        trap 1,1;
        h = solpd(eye(rows(h1)),h1);
        trap oldt,1;
        if scalmiss(h);
           if not trapchk(4);
              if not trapchk(4);
                  errorlog "Cross-Product calculation failed";
              endif;
           endif;
           h = error(0);
        endif;
        Lcmlcpvcp = h;
*/

        Lcmlcpvcp = h1;

        if scalmiss(Lcmlcpvcp) and scalmiss(Lcmlhsvcp);
            cpmeth = "NOTPD";
            h = error(0);
        elseif scalmiss(Lcmlcpvcp) and not scalmiss(Lcmlhsvcp);
            cpmeth = "HESS";
            h = Lcmlhsvcp;
/*
        elseif not scalmiss(Lcmlcpvcp) and scalmiss(Lcmlhsvcp);
            cpmeth = "XPROD";
            h = Lcmlcpvcp;
*/
        else;
            cpmeth = "QML";
            h = Lcmlhsvcp*h1*Lcmlhsvcp;
        endif;
    endif;

    x = x0;

    h = _cml_fix0(h);
    Lcmlhsvcp = _cml_fix0(Lcmlhsvcp);
    Lcmlcpvcp = _cml_fix0(Lcmlcpvcp);
    Lcmlitdta = iter|tme|cpmeth;

    ndpclex;
    call ndpcntrl(old,0xffff);
    retp(x,-vof,g,h,scalerr(ret),Lcmlfhess,Lcmlitdta,Lcmlcpvcp,
           Lcmlhsvcp,Lcmlnobs,Lcmllagr);

endp;


                          




/*-----------------------------------------------------*/
/*   PROC SCTU                                         */
/* This computes VOF, G & updates to inverse Hessian   */

proc(2) = _fastcml_sctu(x,vof,smallval,g,h,dx,d,s,lfct,grdprc,hsprc,
           dataset,Lcmlalgr,Lcmlgrdh,lcmlgdprc,Lcmlhsprc,_eps,gcoefs,wgts,lcmlnobs);

    local v1, v2, g0, h1, w1, w2, z, oldt;
    local lfct:proc,grdprc:proc,hsprc:proc;
    h1 = h;
    /* --- Gradient at x --- */
    g0 = g;

    g = sumc(packr(grdprc(&lfct,x,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts)))/lcmlnobs;

    if scalmiss(g);
        if not trapchk(4);
            errorlog "gradient calculation failed";
        endif;
        retp(g,h,0);
    endif;

    if abs(g) < smallval;
        retp(g,h1,0);
    endif;

    /* -- Secant Update for Inverse Hessian --- */

    if Lcmlalgr == 1;       /* BFGS update */

        v1 = g'dx - g0'dx;
        if (v1 < 1e-22);
            h1 = error(0);
        else;
            v1 = sqrt(v1);
            oldt = trapchk(1);
            trap 1,1;
            h1 = cholup(h,g/v1-g0/v1);
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
            z = -g0'd;
            if z < 0;
                retp(g,error(0));
            endif;
            oldt = trapchk(1);
            trap 1,1;
            h1 = choldn(h1,g0/sqrt(z));
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
        endif;

    elseif Lcmlalgr == 2;           /* DFP update */

        v1 = g'dx - g0'dx;
        if (v1 < 1e-22);
            h1 = error(0);
        else;
            w1 = sqrt(v1);
            oldt = trapchk(1);
            trap 1,1;
            h1 = cholup(h,g/w1 - g0/w1);
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
            z = -g0'd;
            if z < 0;
                retp(g,error(0));
            endif;
            oldt = trapchk(1);
            trap 1,1;
            h1 = choldn(h1,g0/sqrt(z));
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
            v2 = dx'*h*dx;
            w2 = g'/v1 - g0'/v1 - (dx'h)/v2;
            oldt = trapchk(1);
            trap 1,1;
            h1 = cholup(h1,w2/w1);
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
        endif;

    elseif Lcmlalgr == 3;           /* NEWTON-RAPHSON */

        h1 = hsprc(&lfct,x,dataset,Lcmlgdprc,Lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts)/lcmlnobs;

        if scalmiss(h1);
            h1 = error(0);
        endif;

    elseif Lcmlalgr == 4;           /* BHHH */

        h1 = moment(grdprc(&lfct,x,dataset,lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts),1);
        
        if scalmiss(h1);
            if not trapchk(4);
                errorlog "Cross-Product matrix failed to invert - set to id"\
                    "entity";
            endif;
            h1 = error(0);
        endif;

    elseif Lcmlalgr == 5;           /* scaled BFGS */

        v1 = g'dx - g0'dx;
        if (v1 < 1e-22);
            h1 = error(0);
        else;
            z = -v1/(g0'd);
            if z < 0;
                retp(g,error(0));
            endif;
            w1 = sqrt(z)/s;
            oldt = trapchk(1);
            trap 1,1;
            h1 = cholup(w1*h,(g-g0)/sqrt(v1));
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
            oldt = trapchk(1);
            trap 1,1;
            h1 = choldn(h1,g0*w1);
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
        endif;

    elseif Lcmlalgr == 6;           /* scaled DFP */

        v1 = g'dx - g0'dx;
        if (v1 < 1e-22);
            h1 = error(0);
        else;
            z = -v1/(g0'd);
            if z < 0;
                retp(g,error(0));
            endif;
            w1 = sqrt(z)/s;
            oldt = trapchk(1);
            trap 1,1;
            h1 = cholup(w1*h,(g-g0)/sqrt(v1));
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
            oldt = trapchk(1);
            trap 1,1;
            h1 = choldn(h1,g0*w1);
            trap oldt,1;
            if scalmiss(h1);
                retp(g,error(0));
            endif;
        endif;

    endif;
    retp(g,h1);
endp;






proc(2) = _fastcml_stepl(g,x0,d,lfct,step,intrp,extrp,lagr1,lagr2,
                 dataset,mxtry,_eps,wgts,lcmlnobs);
    
    local s, rs, ret, bksteps, vof;
    clear ret;
    bksteps = -1;

    vof = _fastcml_meritFunct(lfct,x0,dataset,lagr1,lagr2,wgts,lcmlnobs);

    if step == 2;
        s = _cml_Feasible(x0,1,d);

        rs = _fastcml_meritFunct(lfct,x0+s*d,dataset,lagr1,lagr2,wgts,lcmlnobs);
        if scalInfNanMiss(rs);
            retp(error(3),bksteps);
        endif;
        { s,ret,bksteps } = _fastcml_stepbt(s,rs,g,vof,x0,d,mxtry,lfct,
            lagr1,lagr2,dataset,wgts,lcmlnobs);
    elseif step == 3;
        { s,ret,bksteps } = _fastcml_half(vof,x0,d,mxtry,lfct,lagr1,lagr2,
            dataset,wgts,lcmlnobs);
    elseif step == 4;
        { s,ret,bksteps } = _fastcml_brent(vof,x0,d,1e-5,mxtry,lfct,
            lagr1,lagr2,dataset,_eps,wgts,lcmlnobs);
    elseif step == 5;
        { s,ret,bksteps } = _fastcml_bhhhstp(vof,x0,d,g,mxtry,intrp,extrp,lfct,
            lagr1,lagr2,dataset,wgts,lcmlnobs);
    else;
        s = _cml_Feasible(x0,1,d);
        rs = _fastcml_meritFunct(lfct,x0+s*d,dataset,lagr1,lagr2,wgts,lcmlnobs);
        if scalInfNanMiss(rs);
            retp(error(3),bksteps);
        endif;
        if rs > vof;
            ret = 1;
        endif;
    endif;

    if ret == 1;    /* not successful */
        { s,ret,bksteps } = _fastcml_brent(vof,x0,d,1e-5,mxtry,lfct,
            lagr1,lagr2,dataset,_eps,wgts,lcmlnobs);
    endif;

    if ret == 1;    /* still not successful */
        { s,ret,bksteps } = _fastcml_half(vof,x0,d,mxtry,lfct,lagr1,lagr2,
            dataset,wgts,lcmlnobs);
    endif;

    if ret == 1;
        s = error(6);
    endif;
    retp(real(s),bksteps);
endp;


proc(3) = _fastcml_bhhhstp(vof0,x0,d,g,mxtry,intrp,extrp,lfct,
            lagr1,lagr2,dataset,wgts,lcmlnobs);

    local lambda,delta,dg,up,down,upfact,downfact,vof,vofmin,lambmin,
        ll,factor,iter,converge,itermax,w;
/* ---------- INITIALIZATIONS --------------------------------------------*/
    let w = 2 1 2 9 0 7;

    itermax = mxtry;
    delta = intrp;
    factor = extrp;
    clear converge,iter,up,down;
    dg = d'g;
    downfact = dg*delta;
    upfact = dg*(1-delta);
    lambda = 1;
    vofmin = vof0;
    lambmin = 0;
/* ----------------- Iteration Loop ----------------------------------------*/
    do until converge or iter>itermax;
        iter = iter+1;

        lambda = _cml_Feasible(x0,lambda,d);
        vof = _fastcml_meritFunct(lfct,x0+lambda*d,dataset,lagr1,lagr2,wgts,lcmlnobs);
        if scalmiss(vof);
            retp(error(3),1,iter);
        endif;
        if vof < vofmin;
            lambmin = lambda;
            vofmin = vof;
        endif;

        if (vof-vof0) > downfact*lambda;
            down = 1;
            if up;
                factor = factor^0.618;
                up = 0;
            endif;
            ll = lambda/factor;
            if ll > lambmin;
                lambda = ll;
            endif;
        elseif (vof-vof0) < upfact*lambda;
            up = 1;
            if down;
                factor = factor^0.618;
                down = 0;
            endif;
            ll = lambda*factor;
            if ll > lambmin;
                lambda = ll;
            endif;
        else;
            converge = 1;
        endif;
    endo;
    retp(lambda,1-converge,iter);
endp;

proc(3) = _fastcml_stepbt(s,r1,g,vof,x0,d,mxtry,lfct,lagr1,lagr2,dataset,wgts,lcmlnobs);

    local delta,ub,lb, ret, i, cdelta, dg, g1, r2, rs, sprev, s2prev, tt, vv0,
        rprev, r2prev, sprev2, s2prev2, sp2, dsprev, vv, zz, ab, a, b, qv;

    local x,y;

/* --------------------- Initializations -------------------------  */
    delta = 1e-4;           /* This can be changed, and doing so may help  */
            /* speed convergence -- it must remain within the interval  */
            /* (0,1/2) */
    ub = 0.5;       /* Upper bound on acceptable reduction in s. */
    lb = 0.1;       /* Lower bound on acceptable reduction in s. */

    ret = 1;        /* If 0, then satisfactory value found; else 1.  */
    i = 0;          /* This counts # of backsteps taken. */

    cdelta = 1-delta;

    dg = d'*g;

        /* ------------------- Try s=1 -------------------------- */
    tt = s*dg;
    g1 = r1/tt-vof/tt;
    if g1>=delta;
        if r1 > vof;
            retp(s,1,0);
        else;
            retp(s,0,0);
        endif;
    endif;
    i = 1;
    s = -dg/(2*(r1-vof-dg));
    s = _cml_Feasible(x0,maxc(s|lb),d);

    r2 = _fastcml_MeritFunct(lfct,x0+s*d,dataset,lagr1,lagr2,wgts,lcmlnobs);

    if scalInfNanMiss(r2);
        retp(error(3),1,1);
    endif;

    tt = s*dg;
    g1 = r2/tt-vof/tt;

    if g1>=delta and g1<=cdelta;
        if r2 > vof;
            retp(s,1,1);
        else;
            retp(s,0,1);
        endif;
    endif;
    sprev = s;
    s2prev = 1;
    rprev = r2;
    r2prev = r1;
    rs = r2;
    vv0 = zeros(2,2);
    vv0[1,1] = 1;
    vv0[1,2] = -1;
    zz = zeros(2,1);

    for i(1,mxtry,1);

        sprev2 = sprev*sprev;
        s2prev2 = s2prev*s2prev;
        sp2 = sprev2~s2prev2;
        dsprev = sprev-s2prev;

        vv0[2,1] = -s2prev;
        vv0[2,2] = sprev;
        vv = vv0./sp2;

        zz[1] = rprev-vof-dg*sprev;
        zz[2] = r2prev-vof-dg*s2prev;

        ab = (1/dsprev)*vv*zz;
        a = ab[1,1];
        b = ab[2,1];

        if a == 0;          /* Cubic is actually a Quadratic in this case. */
            s = -dg/(2*b);
        else;
            qv = b*b - 3*a*dg;
            if qv < 0;
                if rs > vof;
                    retp(s,1,i);
                else;
                    retp(s,ret,i);
                endif;
            endif;          /* terminate if not real root */
            tt = 3*a;
            s = -b/tt + sqrt(qv)/tt;
        endif;

        if s > ub*sprev;
            s = _cml_Feasible(x0,ub*sprev,d);
        elseif s < lb*sprev;
            s = _cml_Feasible(x0,lb*sprev,d);
        endif;

        rs = _fastcml_MeritFunct(lfct,x0+s*d,dataset,lagr1,lagr2,wgts,lcmlnobs);

        if scalInfNanMiss(rs);
            retp(error(3),1,i);
        endif;

        tt = s*dg;
        g1 = rs/tt-vof/tt;

        if g1>=delta and g1<=cdelta;
            if rs > vof;
                retp(s,1,i);
            else;
                retp(s,0,i);
            endif;
        endif;

        s2prev = sprev;
        sprev = s;
        r2prev = rprev;
        rprev = rs;

    endfor;

    if rs > vof;
        retp(s,1,i);
    else;
        retp(s,ret,i);
    endif;

endp;


proc(2) = _fastcml_bracket(f0,x,d,lfct,dataset,mxtry,lagr1,lagr2,wgts,lcmlnobs);

    local g,r,l0,l1,f1,l2,f2;
    local t,y;
    g = 0.5*sqrt(5) - 0.5;
    r = 1 - g;
    l0 = 0;
    l1 = _cml_Feasible(x,g,d);
    f1 = _fastcml_MeritFunct(lfct,x+l1*d,dataset,lagr1,lagr2,wgts,lcmlnobs);

    if scalInfNanMiss(f1);
        retp(error(0),error(0));
    endif;

    for try(1,mxtry,1);

        if (f1 < f0);
            l2 = _cml_Feasible(x,l1+r*(l1-l0),d);
            f2 = _fastcml_MeritFunct(lfct,x+l2*d,dataset,lagr1,lagr2,wgts,lcmlnobs);
            if scalInfNanMiss(f2);
                retp(error(0),error(0));
            endif;

            if (f2 < f1);
                l0 = l1;
                f0 = f1;
                l1 = l2;
                f1 = f2;
            else;
                retp(l0,l2);
            endif;
        else;
            l2 = _cml_Feasible(x,l0+g*(l1-l0),d);
            f2 = _fastcml_MeritFunct(lfct,x+l2*d,dataset,lagr1,lagr2,wgts,lcmlnobs);
            if scalInfNanMiss(f2);
                retp(error(0),error(0));
            endif;
            if (f2 > f0);
                retp(l0,l2);
            else;
                retp(l0,l1);
            endif;
        endif;
    endfor;
    retp(error(0),error(0));
endp;





proc(3) = _fastcml_brent(vof,x0,d0,tol,mxtry,lfct,lagr1,lagr2,dataset,_eps,wgts,lcmlnobs);

    local ax,bx;
    local a,b,c,d,e,xm,p,q,r,tol1,t2,u,v,w,fu,fv,fw,fx,x,tol3;
    local f,y,w1;
    let w1 = 2 1 2 9 0 7;
    c = 0.5*(3 - sqrt(5));

    { ax,bx } = _fastcml_bracket(vof,x0,d0,lfct,dataset,mxtry,lagr1,lagr2,wgts,lcmlnobs);
    if scalmiss(ax);
        retp(ax,1,0);
    endif;
    a = ax;
    b = bx;
    v = a + c*(b - a);
    w = v;
    x = v;
    e = 0;
    fx = vof;
    fv = fx;
    fw = fx;
    tol3 = tol/3;

    for iter(1,mxtry,1);
        xm = 0.5*(a + b);
        tol1 = _eps[1]*abs(x) + tol3;
        t2 = 2*tol1;
        if (abs(x - xm) <= (t2 - .5*(b - a)));
            retp(x,0,iter);
        endif;
        clear p,q,r;
        if abs(e) <= tol1;
            goto A40;
        endif;
        r = (x-w)*(fx-fv);
        q = (x-v)*(fx-fw);
        p = (x-v)*q - (x-w)*r;
        q = 2*(q-r);
        if q <= 0;
            q = -q;
        else;
            p = -p;
        endif;
        r = e;
        e = d;
        if (abs(p) >= abs(.5*q*r));
            goto A40;
        endif;
        if (p <= q*(a-x));
            goto A40;
        endif;
        if (p >= q*(b-x));
            goto A40;
        endif;
        d = p/q;
        u = x + d;
        if ((u-a) < t2);
            if (xm - x) > 0;
                d = tol1;
            else;
                d = - tol1;
            endif;
        endif;
        if ((b-u) < t2);
            if (xm - x) > 0;
                d = tol1;
            else;
                d = - tol1;
            endif;
        endif;
        goto A50;
    A40:

        if x < xm;
            e = b-x;
        else;
            e = a-x;
        endif;
        d = c*e;
    A50:

        if abs(d) >= tol1;
            u = x + d;
        elseif d >= 0;
            u = x + tol1;
        else;
            u = x - tol1;
        endif;

        u = _cml_Feasible(x0,u,d0);
        fu = _fastcml_MeritFunct(lfct,x0+u*d0,dataset,lagr1,lagr2,wgts,lcmlnobs);

        if scalInfNanMiss(fu);
            retp(error(3),1,iter);
        endif;

        if fu <= fx;
            if u >= x;
                a = x;
            else;
                b = x;
            endif;
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        else;
            if u >= x;
                b = u;
            else;
                a = u;
            endif;
            if (fu <= fw) or (w == x);
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            elseif (fu <= fv) or (v == x) or (v == w);
                v = u;
                fv = fu;
            endif;
        endif;
    endfor;
    retp(error(6),1,mxtry);

endp;

proc(3) = _fastcml_half(f,x,d,mxtry,lfct,lagr1,lagr2,dataset,wgts,lcmlnobs);

    local ax,cx,dx,f1,t,y;

    { ax,cx } = _fastcml_bracket(f,x,d,lfct,dataset,mxtry,lagr1,lagr2,wgts,lcmlnobs);
    if scalmiss(cx);
       retp(error(0),1,0);
    endif;
    for bksteps(1,mxtry,1);

        dx = cx - ax;
        cx = _cml_Feasible(x,ax+.5*dx,d);
        f1 = _fastcml_MeritFunct(lfct,x+cx*d,dataset,lagr1,lagr2,wgts,lcmlnobs);

        if scalInfNanMiss(f1);
            retp(error(3),1,bksteps);
        endif;

        if f1 < f or dx < 1e-16;
            retp(cx,0,bksteps);
        endif;
    endfor;
    retp(error(0),1,mxtry);
endp;





proc _fastcml_grdusr(lfct,x0,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);

    local g;
    local lcmlgdprc:proc;
    if scalmiss(wgts);
         g = lcmlgdprc(x0,dataset);
    else;
         g = wgts.*lcmlgdprc(x0,dataset);
    endif;
    retp(-g);

endp;




proc 1 = _fastcml_grdfd(lfct,x0,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, arg, dax0, f0;
    local lfct:proc;
    local t1,t2,z,v;

    if scalmiss(wgts);
         f0 = lfct(x0,dataset);
    else;  
         f0 = wgts.*lfct(x0,dataset);
    endif;
    if scalInfNanMiss(f0);
        retp(error(0));
    endif;


    n = rows(f0);
    k = rows(x0);
    grdd = zeros(n,k);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    xdh = x0+dh;
    dh = xdh-x0;    /* This increases precision slightly */
    arg = diagrv(reshape(x0,k,k)',xdh);

    for i(1,k,1);

        if scalmiss(wgts);
             grdd[.,i] = lfct(submat(arg,0,i),dataset);
        else;  
             grdd[.,i] = wgts.*lfct(submat(arg,0,i),dataset);
        endif;

    endfor;
    retp(-(grdd-f0)./(dh'));

endp;






proc 1 = _fastcml_grdbd(lfct,x0,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, arg, dax0, f0;
    local lfct:proc;
    local t1,t2,z,v;

    if scalmiss(wgts);
         f0 = lfct(x0,dataset);
    else;  
         f0 = wgts.*lfct(x0,dataset);
    endif;
    if scalInfNanMiss(f0);
        retp(error(0));
    endif;


    n = rows(f0);
    k = rows(x0);
    grdd = zeros(n,k);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    arg = diagrv(reshape(x0,k,k)',x0-dh);
    for i(1,k,1);

        if scalmiss(wgts);
             grdd[.,i] = lfct(submat(arg,0,i),dataset);
        else;  
             grdd[.,i] = wgts.*lfct(submat(arg,0,i),dataset);
        endif;

    endfor;
    retp((grdd-f0)./(dh'));

endp;






proc _fastcml_grdcd(lfct,x,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);
    local k,i;
    local lfct:proc;
    local z,v,v1,v2,ax0,dax0,dh,xdh,argplus,argminus,t2,t1,grdd;

    k = rows(x);
    ax0 = abs(x);

    if x /= 0;
        dax0 = x./ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    xdh = x+dh;
    dh = xdh-x;     /* This increases precision slightly */
    argplus = diagrv(reshape(x,k,k)',xdh);
    argminus = diagrv(reshape(x,k,k)',x-dh);
    grdd = zeros(rows(dataset),k);

    for i(1,k,1);

        if scalmiss(wgts);
             grdd[.,i] = lfct(argplus[.,i],dataset) - lfct(argminus[.,i],dataset);
        else;  
             grdd[.,i] = wgts.*lfct(argplus[.,i],dataset) - wgts.*lfct(argminus[.,i],dataset);
        endif;

    endfor;
    retp(-grdd./(2*dh'));

endp;




proc 1 = _fastcml_hsgdfd(lfct,x0,dataset,lcmlgdprc,lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, arg, dax0, i, g0;
    local lcmlgdprc:proc;

    if scalmiss(wgts);
         g0 = sumc(packr(lcmlgdprc(x0,dataset)));
    else;  
         g0 = sumc(packr(wgts.*lcmlgdprc(x0,dataset)));
    endif;
    if scalInfNanMiss(g0);
        retp(error(0));
    endif;

    n = rows(g0);
    k = rows(x0);
    grdd = zeros(n,k);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    xdh = x0+dh;
    dh = xdh-x0;    /* This increases precision slightly */
    arg = diagrv(reshape(x0,k,k)',xdh);

    for i(1,k,1);
        if scalmiss(wgts);
            grdd[.,i] = sumc(packr(lcmlgdprc(submat(arg,0,i),dataset)));
        else;
            grdd[.,i] = sumc(packr(wgts.*lcmlgdprc(submat(arg,0,i),dataset)));
        endif;
    endfor;

    retp(-(grdd-g0)./(dh'));
endp;









proc 1 = _fastcml_hsgdbd(lfct,x0,dataset,lcmlgdprc,lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, arg, dax0, i, g0;
    local lcmlgdprc:proc;

    if scalmiss(wgts);
         g0 = sumc(packr(lcmlgdprc(x0,dataset)));
    else;  
         g0 = sumc(packr(wgts.*lcmlgdprc(x0,dataset)));
    endif;
    if scalInfNanMiss(g0);
        retp(error(0));
    endif;

    n = rows(g0);
    k = rows(x0);
    grdd = zeros(n,k);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    arg = diagrv(reshape(x0,k,k)',x0-dh);
    for i(1,k,1);
        if scalmiss(wgts);
            grdd[.,i] = sumc(packr(lcmlgdprc(submat(arg,0,i),dataset)));
        else;
            grdd[.,i] = sumc(packr(wgts.*lcmlgdprc(submat(arg,0,i),dataset)));
        endif;
    endfor;

    retp((grdd-g0)./(dh'));
endp;








proc _fastcml_hsgdcd(grdfct,x,dataset,lcmlgdprc,Lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local k,ax0,dax0,dh,xdh,argplus,argminus,grdd;
    local lcmlgdprc:proc;

    k = rows(x);
    ax0 = abs(x);

    if x /= 0;
        dax0 = x./ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    xdh = x+dh;
    dh = xdh-x;     /* This increases precision slightly */
    argplus = diagrv(reshape(x,k,k)',xdh);
    argminus = diagrv(reshape(x,k,k)',x-dh);

    grdd = zeros(k,k);
    for i(1,k,1);
        if scalmiss(wgts);
             grdd[.,i] = sumc(packr(lcmlgdprc(argplus[.,i],dataset) - lcmlgdprc(argminus[.,i],dataset)));
        else;
             grdd[.,i] = sumc(packr(wgts.*(lcmlgdprc(argplus[.,i],dataset) - lcmlgdprc(argminus[.,i],dataset))));
        endif;
    endfor;
    retp(-grdd./(2*dh'));
endp;








                                                        
proc 1 = _fastcml_mpgrdfd(lfct,x0,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, dax0, f0, r, r1, ee, x1, f1, m, x;
    local lfct:proc;
    local t1,t2,z,v;

    r = 0.5*rows(gcoefs);
    r1 = r + 1;

    if scalmiss(wgts);
         f1 = lfct(x0,dataset);
    else;  
         f1 = wgts.*lfct(x0,dataset);
    endif;
    if scalInfNanMiss(f1);
        retp(error(0));
    endif;


    m = rows(f1);
    k = rows(x0);
    grdd = zeros(m,k);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    xdh = x0 + dh;
    ee = eye(k).*(xdh - x0);
    f0 = zeros(m,r1);
    f0[.,1] = f1;

    for i (1,k,1);
        for j (1,r,1);

            if scalmiss(wgts);
                 f1 = lfct(x0 + j * ee[.,i],dataset);
            else;  
                 f1 = wgts.*lfct(x0 + j * ee[.,i],dataset);
            endif;
            f0[.,j+1] = f1;

        endfor;
        grdd[.,i] = f0 * gcoefs[1:r1,2];
    endfor;

    retp(-grdd./dh');

endp;



proc 1 = _fastcml_mpgrdbd(lfct,x0,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, dax0, f0, r, r1, ee, x1, f1, m, x;
    local lfct:proc;
    local t1,t2,z,v;

    r = 0.5*rows(gcoefs);
    r1 = r + 1;

    if scalmiss(wgts);
         f1 = lfct(x0,dataset);
    else;  
         f1 = wgts.*lfct(x0,dataset);
    endif;
    if scalInfNanMiss(f1);
        retp(error(0));
    endif;


    m = rows(f1);
    k = rows(x0);
    grdd = zeros(m,k);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    xdh = x0 + dh;
    ee = eye(k).*(xdh - x0);
    f0 = zeros(m,r1);
    f0[.,1] = f1;

    for i (1,k,1);
        for j (1,r,1);

            if scalmiss(wgts);
                 f1 = lfct(x0 - j * ee[.,i],dataset);
            else;  
                 f1 = wgts.*lfct(x0 - j * ee[.,i],dataset);
            endif;
            f0[.,j+1] = f1;

        endfor;
        grdd[.,i] = f0 * gcoefs[1:r1,2];
    endfor;

    retp(grdd./dh');

endp;


proc _fastcml_mpgrdcd(lfct,x,dataset,Lcmlgrdh,lcmlgdprc,_eps,gcoefs,wgts);
    local k,i;
    local lfct:proc;
    local z,v,v1,v2,ax0,dax0,dh,xdh,grdd,r,ee,m,x1,f0,f1;

    k = rows(x);
    ax0 = abs(x);
    r = 0.5*rows(gcoefs);

    if x /= 0;
        dax0 = x./ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    xdh = x + dh;
    ee = eye(k).*(xdh - x);

    if scalmiss(wgts);
         f1 = lfct(x+ee[.,1],dataset);
    else;  
         f1 = wgts.*lfct(x+ee[.,1],dataset);
    endif;

    m = rows(f1);
    grdd = zeros(m,k);
    f0 = zeros(m,2*r);
    f0[.,r+1] = f1;

    for i (1,k,1);
        for j (1,r,1);

            if i /= 1 or j /= 1;

                if scalmiss(wgts);
                    f1 = lfct(x + j*ee[.,i],dataset);
                else;  
                    f1 = wgts.*lfct(x + j*ee[.,i],dataset);
                endif;

                f0[.,r+j] = f1;
            endif;

            if scalmiss(wgts);
                f1 = lfct(x - j*ee[.,i],dataset);
            else;  
                f1 = wgts.*lfct(x - j*ee[.,i],dataset);
            endif;

            f0[.,r-j+1] = f1;
        endfor;
        grdd[.,i] = f0 * gcoefs[.,1];
    endfor;

    retp(-grdd./dh');

endp;






proc 1 = _fastcml_mphsgdfd(lfct,x0,dataset,lcmlgdprc,lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, arg, dax0, i, f0, f1, r, r1, ee;
    local lcmlgdprc:proc;

    r = 0.5*rows(gcoefs);
    r1 = r + 1;
    k = rows(x0);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    xdh = x0 + dh;
    ee = eye(k).*(xdh - x0);

    if scalmiss(wgts);
         f1 = sumc(packr(lcmlgdprc(x0,dataset)));
    else;  
         f1 = sumc(packr(wgts.*lcmlgdprc(x0,dataset)));
    endif;
    n = rows(f1);
    f0 = zeros(n,r1);
    f0[.,1] = f1;
    
    grdd = zeros(n,k);
    for i (1,k,1);
        for j (1,r,1);

            if scalmiss(wgts);
                f0[.,j+1] = sumc(packr(lcmlgdprc(x0+j*ee[.,i],dataset)));
            else;
                f0[.,j+1] = sumc(packr(wgts.*lcmlgdprc(x0+j*ee[.,i],dataset)));
            endif;

        endfor;
        grdd[.,i] = f0 * gcoefs[1:r1,2];
    endfor;

    retp(-grdd./dh');
endp;





proc 1 = _fastcml_mphsgdbd(lfct,x0,dataset,lcmlgdprc,lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local n, k, grdd, dh, ax0, xdh, arg, dax0, i, f0, f1, r, r1, ee;
    local lcmlgdprc:proc;

    r = 0.5*rows(gcoefs);
    r1 = r + 1;
    k = rows(x0);

/* Computation of stepsize (dh) for gradient */

    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0 ./ ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    ee = eye(k).*dh;

    if scalmiss(wgts);
         f1 = sumc(packr(lcmlgdprc(x0,dataset)));
    else;  
         f1 = sumc(packr(wgts.*lcmlgdprc(x0,dataset)));
    endif;

    n = rows(f1);
    f0 = zeros(n,r1);
    f0[.,1] = f1;

    grdd = zeros(n,k);
    for i (1,k,1);
        for j (1,r,1);

            if scalmiss(wgts);
                f0[.,j+1] = sumc(packr(lcmlgdprc(x0-j*ee[.,i],dataset)));
            else;
                f0[.,j+1] = sumc(packr(wgts.*lcmlgdprc(x0-j*ee[.,i],dataset)));
            endif;

        endfor;
        grdd[.,i] = -f0 * gcoefs[1:r1,2];
    endfor;

    retp(-grdd./dh');
endp;





proc _fastcml_mphsgdcd(grdfct,x,dataset,lcmlgdprc,Lcmlhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local k,ax0,dax0,dh,xdh,f0,f1,r,grdd,ee,m;
    local lcmlgdprc:proc;

    k = rows(x);
    ax0 = abs(x);
    r = 0.5*rows(gcoefs);

    if x /= 0;
        dax0 = x./ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x) and Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1];
        elseif Lcmlgrdh[.,1] /= 0;
            dh = Lcmlgrdh[.,1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[1]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    xdh = x + dh;
    ee = eye(k).*(xdh - x);


    if scalmiss(wgts);
         f1 = sumc(packr(lcmlgdprc(x+ee[.,1],dataset)));
    else;
         f1 = sumc(packr(wgts.*lcmlgdprc(x+ee[.,1],dataset)));
    endif;

    m = rows(f1);
    f0 = zeros(m,2*r);
    f0[.,r+1] = f1;

    grdd = zeros(m,k);
    for i (1,k,1);
        for j (1,r,1);

            if i /= 1 or j /= 1;

                if scalmiss(wgts);
                     f0[.,r+j] = sumc(packr(lcmlgdprc(x+j*ee[.,i],dataset)));
                else;
                     f0[.,r+j] = sumc(packr(wgts.*lcmlgdprc(x+j*ee[.,i],dataset)));
                endif;

            endif;

            if scalmiss(wgts);
                 f0[.,r-j+1] = sumc(packr(lcmlgdprc(x-j*ee[.,i],dataset)));
            else;
                 f0[.,r-j+1] = sumc(packr(wgts.*lcmlgdprc(x-j*ee[.,i],dataset)));
            endif;

        endfor;
        grdd[.,i] = f0 * gcoefs[.,1];
    endfor;

    retp(-grdd./dh');

endp;



proc _fastcml_hsusr(lfct,x0,dataset,lmaxgdprc,lmaxhsprc,lcmlgrdh,_eps,gcoefs,wgts);

    local lcmlhsprc:proc,h;

    if scalmiss(wgts);
         h = -lcmlhsprc(x0,dataset);
    else;
         h = -wgts.*lcmlhsprc(x0,dataset);
    endif;

    retp(h);

endp;




proc _fastcml_hssp(lfct,x0,dataset,lmaxgdprc,lmaxhsprc,lcmlgrdh,_eps,gcoefs,wgts);
    local k, hss, grdd, ax0, dax0, dh, xdh, ee, f0, i, j, v;
    local lfct:proc;

/* initializations */
    k = rows(x0);

        /* Computation of stepsize (dh) */
    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0./ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,2] /= 0;
            dh = Lcmlgrdh[.,2];
        elseif Lcmlgrdh[.,2] /= 0;
            dh = Lcmlgrdh[.,2]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[2]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[2]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;

    xdh = x0+dh;
    dh = xdh-x0;    /* This increases precision slightly */
    ee = eye(k).*dh;

    if scalmiss(wgts);
         f0 = lfct(x0,dataset);
    else;
         f0 = wgts.*lfct(x0,dataset);
    endif;

    /* Compute forward step */
    grdd = zeros(rows(f0),k);
    for i(1,k,1);
        if scalmiss(wgts);
             grdd[.,i] = lfct(x0+ee[.,i],dataset);
        else;
             grdd[.,i] = wgts.*lfct(x0+ee[.,i],dataset);
        endif;
    endfor;


    /* Compute "double" forward step */
    hss = zeros(k,k);
    for i(1,k,1);
        for j(i,k,1);
            if scalmiss(wgts);
                 v = lfct(x0+ee[.,i]+ee[.,j],dataset);
            else;
                 v = wgts.*lfct(x0+ee[.,i]+ee[.,j],dataset);
            endif;
            hss[i,j] = sumc(packr((v-grdd[.,i]-grdd[.,j] + f0) ./ (dh[i] * dh[j])));
            if i /= j;
                hss[j,i] = hss[i,j];
            endif;
        endfor;
    endfor;

    retp(-hss);

endp;





proc _fastcml_mphssp(f,x0,y,lmaxgdprc,lmaxhsprc,Lcmlgrdh,_eps,gcoefs,wgts);
    local k, hessian, grdd, ax0, dax0, dh, xdh, ee, f0, r, u,v,m,n,x1,f1;
    local f:proc;

/* initializations */
    k = rows(x0);
    r = 0.5*rows(gcoefs);

        /* Computation of stepsize (dh) */
    ax0 = abs(x0);
    if x0 /= 0;
        dax0 = x0./ax0;
    else;
        dax0 = 1;
    endif;

    if not scalmiss(Lcmlgrdh) and cols(Lcmlgrdh) > 1;
        if rows(Lcmlgrdh) == rows(x0) and Lcmlgrdh[.,2] /= 0;
            dh = Lcmlgrdh[.,2];
        elseif Lcmlgrdh[.,2] /= 0;
            dh = Lcmlgrdh[.,2]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        else;
            dh = _eps[2]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
        endif;
    else;
        dh = _eps[2]*maxc(ax0'|(1e-2)*ones(1,k)).*dax0;
    endif;
    dh = dh / (2*r);

    xdh = x0 + dh;
    ee = eye(k).*(xdh - x0);
    grdd = zeros(2*r,2*r);
    hessian = zeros(k,k);

    for i (1,k,1);
        for j (1,i,1);

            u = 1;
            for m(-r,r,1);

                v = 1;
                if m /= 0;

                    for n(-r,r,1);
                        if n /= 0;

                            if scalmiss(wgts);
                                f1 = f(x0 + m*ee[.,i]+n*ee[.,j],y);
                            else;
                                f1 = wgts.*f(x0 + m*ee[.,i]+n*ee[.,j],y);
                            endif;

                            grdd[u,v] = sumc(packr(f1));

                            v = v + 1;
                        endif;
                    endfor;
                    u = u + 1;

                endif;

            endfor;

            hessian[i,j] = gcoefs[.,1]'*grdd*gcoefs[.,1];
            if i /= j;
                hessian[j,i] = hessian[i,j];
            endif;

        endfor;
    endfor;

    retp( -hessian ./ (dh.*dh') );

endp;






proc _fastcml_meritFunct(lfct,x,dataset,lagr1,lagr2,wgts,lcmlnobs);

    local f0, c1, c2 , eqproc, ineqproc;
    local lfct:proc;

    if scalmiss(wgts);
         f0 = sumc(packr(-lfct(x,dataset)))/lcmlnobs;
    else;  
         f0 = sumc(packr(-wgts.*lfct(x,dataset)))/lcmlnobs;
    endif;

    if not scalmiss(lagr1);
        c1 = {};
        if not scalmiss(_cml_A);
            c1 = c1 | abs(_cml_A*x - _cml_B);
        endif;
        if not scalmiss(_cml_EqProc);
            EqProc = _cml_EqProc;
            local eqproc:proc;
            c1 = c1 | abs(EqProc(x));
        endif;
        if not scalmiss(c1);
            f0 = f0 + lagr1*sumc(abs(c1));
        endif;
    endif;

    if not scalmiss(lagr2);
        c2 = {};
        if not scalmiss(_cml_C);
            c2 = c2 | _cml_C*x - _cml_D;
        endif;
    
        if not scalmiss(_cml_IneqProc);
            ineqproc = _cml_IneqProc;
            local ineqproc:proc;
            c2 = c2 | IneqProc(x);
        endif;
    
        if not scalmiss(_cml_Bounds);
            c2 = c2 | x - _cml_Bounds[.,1];
            c2 = c2 | -x + _cml_Bounds[.,2];
        endif;
    
        if not scalmiss(c2);
            f0 = f0 - lagr2*sumc(minc(zeros(1,rows(c2))|c2'));
        endif;
    endif;

    retp(f0);

endp;




proc(2) = _fastcml_gridSearch(&fnct,x,dataset,wgts,f0,lcmlnobs,delta0);

    local x0,f,f1,x1,ff,xx,k,i1,delta;
    local fnct:proc;
    f1 = 1e256;
    x1 = x;
    delta = 1 + delta0;

    for m(1,50,1);

        k = 1;
        ff = miss(zeros(rows(x)*(rows(x)+1),1),0);
        xx = miss(zeros(rows(x)*(rows(x)+1),rows(x)),0);
        for i(1,rows(x),1);
            for j(0,rows(x),1);

                x0 = x;
                x0[i,1] = delta * x0[i,1];
                if j > 0;
                    x0[j,1] = delta * x0[j,1];
                endif;

                if _cml_isFeasible(x0);
                    xx[k,.] = x0[.,1]';
                    if scalmiss(wgts);
                         ff[k] = sumc(packr(-fnct(x0,dataset)))/lcmlnobs;
                    else;  
                         ff[k] = sumc(packr(-wgts.*fnct(x0,dataset)))/lcmlnobs;
                    endif;
                    ff[k] = sumc(fnct(x0));
                endif;

                k = k + 1;
            endfor;
        endfor;

        i1 = minindc(ff);

        if ff[i1] < f0;
            retp(xx[i1,.]',ff[i1]);
        else;
            if ff[i1] < f1;
                f1 = ff[i1];
                x1[.,1] = xx[i1,.]';
            endif;

        endif;
        delta = 1 + m*delta0;

    endfor;

    if f1 < 1e256;
        retp(x1,f1);
    else;
        retp(error(0),error(0));
    endif;
endp;

