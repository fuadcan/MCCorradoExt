/*
** dstat.src - descriptive statistics
** (C) Copyright 1988-1997 by Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
**                  Format                                  Line
** ========================================================================
**
**      { vnames,mean,var,std,min,
**        max,valid,missing } = DSTAT(dataset,vars);         31
**      { vnam,mean,var,std,min,
**        max,valid,mis }     = _DSTATD(dataset,vars);      205
**      { vnam,mean,var,std,min,
**        max,valid,mis }     = _DSTATX(x);                 354
**/

#include gauss.ext

/*
**> dstat
**
**  Purpose:    Computes descriptive statistics.
**
**  Format:     { vnam,mean,var,std,min,max,valid,mis } = dstat(dataset,vars);
**
**  Input:      dataset    string, name of data set.
**
**                         If <dataset> is a null string or 0, <vars> will
**                         be assumed to be a matrix containing the data.
**
**              vars       Kx1 charater vector, names of the variables in
**                         <dataset> to be analyzed
**                                         OR
**                         Kx1 numeric vector, the indices of the variables
**                         in <dataset> to be analyzed.
**
**                         These can be any size subset of the variables in
**                         the data set, and can be in any order.  If a
**                         scalar 0 is passed, all columns of the data set
**                         will be used.
**
**                         If <dataset> is a null string, or 0, then <vars>
**                         will be interpreted as:
**
**                         NxM matrix, the data to be analyzed.
**
**  Globals:
**            __altnam      Mx1 matrix, character vector of alternate names
**                          to be used if a matrix in memory is being analyzed.
**                          (i.e. <dataset> is a null string, or 0).
**
**                          By default, the variables names will be X1,X2,..Xm
**
**            __miss        scalar.  Determines how missing values will be
**                          handled.
**
**                                 0   there are no missing values.
**
**                                 1   listwise deletion, drop an observation
**                                     if any missings occur in it.
**
**                                 2   pairwise deletion.
**
**                          Default = 0.
**
**            __row         scalar, the number of rows of <dataset> to be read
**                          per iteration of the read loop.
**
**                          By default the number of rows to be read will be
**                          calculated internally.
**
**           __output       scalar, controls output.
**
**                              1   print output table.
**
**                              0   do not print output.
**
**                          Default = 1.
**
**          __vtype         Mx1 vector,  or scalar, of 0's and 1's used to
**                          indicate whether the columns of <dataset> are
**                          character or numeric.  Set this global only if you
**                          are not following the upper/lower case convention.
**
**                          If you are not following this convention, and have
**                          mixed character-numeric data, then set __vtype as
**                          follows:  If __vtype is a vector, each element
**                          should be set to 0 is the corresponding column in
**                          <dataset> is character, and to 1 if the
**                          corresponding column in <dataset> is numeric.  If
**                          __vtype is a scalar, it is assumed that <dataset>
**                          is either all character (__vtype = 0) or all numeric
**                          (__vtype = 1).
**
**                          By default, __vtype = -1.  That is, if data to be
**                          analyzed is passed in a data set to dstat (<dataset>
**                          is the name of a data), then data type will
**                          be determined by looking at each variable name,
**                          following the upper/lower case convention.
**
**                          If a matrix in memory is passed to dstat, then
**                          either __vtype or __altnam (using the upper/lower
**                          case convention) will be used to determine the
**                          case. If __vtype = -1, and __altnam is not set,
**                          then it will be assumed that all data is numeric.
**
**  Output:     vnames      Kx1 character vector, the names of the variables
**                          used in the statistics.
**
**               mean       Kx1 vector, means.
**
**               var        Kx1 vector, variance.
**
**               std        Kx1 vector, standard deviation.
**
**               min        Kx1 vector, minima.
**
**               max        Kx1 vector, maxima.
**
**               valid      Kx1 vector, the number of valid cases.
**
**               missing    Kx1 vector, the number of missing cases.
**
**  Remarks:    If pairwise deletion is used, the minima and maxima will be
**              the true values for the valid data.  The means and standard
**              deviations will be computed using the correct number of
**              valid observations for each variable.
**
**
**  dstat
**
*/

external proc indices;

proc (8) = dstat(dataset,vars);
    local n,omat,vnames,mean,var,std,min,max,valid,missing,fmt,mask;
    dataset = "" $+ dataset;
    if type(vars) == 13;
         vars = stof(vars);
    endif;
    /* check for complex input */
    if iscplx(vars);
        if hasimag(vars);
            errorlog "ERROR: Matrix must be real.";
            end;
        else;
            vars = real(vars);
        endif;
    endif;
    if dataset $== "";
        { vnames, mean,var,std,min,max,valid,missing } = _dstatx(vars);
    else;
        { vnames,mean,var,std,min,max,valid,missing } = _dstatd(dataset,vars);
    endif;
    if vnames $== -99 or (scalerr(missing));
        retp(0,0,0,0,0,0,0,0);
    endif;
    msym "-----";
    n = rows(mean);
    if rows(missing) == 1;
        missing = missing*ones(n,1);
    endif;
    if rows(valid) == 1;
        valid = valid*ones(n,1);
    endif;
    if __output;
        print;
        print chrs(45*ones(79,1));
        print "Variable       Mean   Std Dev    Variance   Minimum   Maximum  "\
            "   Valid Missing" ;
        print chrs(45*ones(79,1));
        omat = vnames~mean~std~var~min~max~valid~missing;
        mask = 0~1~1~1~1~1~1~1;     /* mask to print first column as strings */
        let fmt[8,3]=
            "-*.*s "  8 8  /* format info for variable names column */
            "*.*lf" 10 4   /* format info for mean column           */
            "*.*lf" 10 4   /* format info for std deviation column  */
            "*.*lf" 12 4   /* format info for variance column       */
            "*.*lf" 10 4   /* format info for min column            */
            "*.*lf" 10 4   /* format info for max column            */
            "*.*lf" 10 0   /* format info for valid column          */
            "*.*lf" 5 0    /* format info for missing column        */;
        if not printfm(omat,mask,fmt);
            errorlog "ERROR: Can't write table";
            end;
        endif;
    endif;
    msym ".";
    retp(vnames,mean,var,std,min,max,valid,missing);
endp;

/*
**> _dstatd
**
**  Purpose:  This is used if the data is passed in a dataset.
**
**  Format:  { vnames,mean,var,std,min,max,valid,missing } =
**                                   _dstatd(dataset,vars);
**
**  Input:      dataset   string, the name of the dataset to be analyzed.
**
**              vars      Kx1 charater vector, names of the variables.
**                                       OR
**                        Kx1 numeric vector, indices of variables.
**
**  Output:     vnam      Kx1 character vector, the names of the variables
**                        used in the statistics.
**
**              mean      Kx1 vector, means.
**
**              var       Kx1 vector, variance.
**
**              std       Kx1 vector, standard deviation.
**
**              min       Kx1 vector, minima.
**
**              max       Kx1 vector, maxima.
**
**              valid     Kx1 vector, the number of valid cases.
**
**              mis       Kx1 vector, the number of missing cases.
**
*/

proc (8) = _dstatd(dataset,vars);
    local i,fin,vnames,indx,kk,k,nr,tobs,valid,var,mean,std,max,min,missing,
        sum,sumsq,z,fac,old,vtype,vlbl;
    old = ndpcntrl(0,0);
    call ndpcntrl(1,1);
    /* open file using name in variable DATASET */
    dataset = "" $+ dataset;
    open fin = ^dataset;
    if fin == -1;
        if not trapchk(1);
            errorlog "Can't open file: " $+ dataset;
            end;
        else;
            retp(0,0,0,0,0,0,0,error(99));
        endif;
    endif;
    if iscplxf(fin);
        errorlog "ERROR: Not implemented for complex data sets.";
        end;
    endif;

    if (rows(__vtype) /= colsf(fin)) and (rows(__vtype) /= 1);
        errorlog "Invalid number of rows in __VTYPE";
        retp(-99,0,0,0,0,0,0,0);
    endif;

    /* process variables */

    { vnames,indx } = indices(dataset,vars);
    { vlbl,vtype } = nametype(getname(dataset),__vtype);
    vtype = vtype[indx];


    /* Computation of max number of rows to read at one time */
    if __row;
        nr = __row;
    else;
        k = colsf(fin);
        if __miss == 2;
            fac = 4;
        else;
            fac = 3;
        endif;
        nr = floor(minc(coreleft/(k*8*fac)|maxvec/(k+1)));
    endif;
    tobs = rowsf(fin);
    kk = rows(indx);
    k = colsf(fin);
    min = reshape(__INFp,kk,1);       /* positive infinity */
    max = reshape(__INFn,kk,1);       /* negative infinity */
    clear sum,sumsq,valid;
    do until eof(fin);
        z = readr(fin,nr);
        z = z[.,indx];
        if __miss == 1;     /* listwise deletion */
            z = packr(z);
            if scalmiss(z);
                continue;
            endif;
            min = minc(z|min');
            max = maxc(z|max');
            valid = valid + rows(z);
            ndpclex;
        elseif __miss == 2;         /* pairwise deletion */
            missing = zeros(kk,1);
            i = 1;
            do until i > kk;
                missing[i] = missing[i] + counts(z[.,i],error(0));
                i = i+1;
            endo;
            min = minc(missrv(z,__INFp)|min');
            max = maxc(missrv(z,__INFn)|max');
            valid = valid + rows(z) - missing;
            z = missrv(z,0);
            ndpclex;
        else;
            min = minc(z|min');
            max = maxc(z|max');
            valid = valid + rows(z);
        endif;
        sum = sumc(z) + sum;
        sumsq = sumc(z.*z) + sumsq;
    endo;

    fin = close(fin);
    if valid $== 0;
        if not trapchk(1);
            errorlog "Too many missings - no data left after packing";
        else;
            call ndpcntrl(old,0xffff);
            ndpclex;
            retp(0,0,0,0,0,0,0,error(99));
        endif;
    endif;
    mean = sum./valid;
    var = (sumsq-valid.*(mean.*mean))./( valid + (valid .== 1) - 1 );
    var = missex(var,valid.==1);
    var = maxc(var'|zeros(1,rows(var)));
    std = sqrt(var);
    missing = tobs-valid;

    mean = missex(mean,(.not vtype));
    var = missex(var,(.not vtype));
    var = missex(var,var .== 0);
    std = missex(std,(.not vtype));
    std = missex(std,std .== 0);
    min = missex(min,(.not vtype));
    max = missex(max,(.not vtype));

    call ndpcntrl(old,0xffff);
    ndpclex;
    retp(vnames,mean,var,std,min,max,valid,missing);
    clear vlbl;   /* never executed */
endp;


/*
**> _dstatx
**
**  Purpose:  This is used if a matrix in memory is passed into dstat.
**
**  Format:  { vnames,mean,var,std,min,max,valid,missing } = _dstatx(x);
**
**  Input:      x         NxK matrix, the matrix in memory.
**
**  Output:     vnam      Kx1 character vector, the names of the variables
**                        used in the statistics.
**
**              mean      Kx1 vector, means.
**
**               var      Kx1 vector, variance.
**
**               std      Kx1 vector, standard deviation.
**
**               min      Kx1 vector, minima.
**
**               max      Kx1 vector, maxima.
**
**             valid      Kx1 vector, the number of valid cases.
**
**               mis      Kx1 vector, the number of missing cases.
**
*/

proc (8) = _dstatx(x);
    local i,vnames,k,tobs,valid,var,mean,std,max,min,missing,sum,
        sumsq,old,vtype;
    tobs = rows(x);
    k = cols(x);
    if __altnam $/= 0;
        if rows(__altnam) $/= k;
            errorlog "Invalid number of rows in __ALTNAM";
            ndpclex;
            retp(-99,0,0,0,0,0,0,0);
        else;
            vnames = __altnam;
        endif;
    else;
        vnames = 0 $+ "X" $+ ftocv(seqa(1,1,k),floor(log(k)),0);
    endif;

    if (rows(__vtype) /= k) and (rows(__vtype) /= 1);
        errorlog "Invalid number of rows in __VTYPE";
        retp(-99,0,0,0,0,0,0,0);
    endif;

    { vnames,vtype } = nametype(vnames,__vtype);

    old = ndpcntrl(0,0);
    call ndpcntrl(1,1);
    missing = zeros(k,1);
    if __miss == 1;         /* listwise deletion */
        x = packr(x);
        if scalmiss(x);
            if not trapchk(1);
                errorlog "Too many missings - no data left after packing";
            else;
                retp(0,0,0,0,0,error(99));
            endif;
        endif;
        min = minc(x);
        max = maxc(x);
        valid = rows(x);
        ndpclex;
    elseif __miss == 2;     /* pairwise deletion */
        i = 1;
        do until i > k;
            missing[i] = missing[i] + counts(x[.,i],error(0));
            i = i+1;
        endo;
        min = minc(missrv(x,__INFp));
        max = maxc(missrv(x,__INFn));
        valid = rows(x) - missing;
        x = missrv(x,0);
        ndpclex;
    else;
        min = minc(x);
        max = maxc(x);
        valid = rows(x);
    endif;
    sum = sumc(x);
    sumsq = sumc(x.*x);
    mean = sum./valid;
    var = (sumsq-valid.*(mean.*mean))./( valid + (valid .== 1) - 1);
    var = maxc(var'|zeros(1,rows(var)));
    std = sqrt(var);
    missing = tobs - valid;

    mean = missex(mean,(.not vtype));
    var = missex(var,valid.==1);
    var = missex(var,(.not vtype));
    var = missex(var,var .== 0);
    std = missex(std,(.not vtype));
    std = missex(std,std .== 0);
    min = missex(min,(.not vtype));
    max = missex(max,(.not vtype));

    ndpclex;
    call ndpcntrl(old,0xffff);
    retp(vnames,mean,var,std,min,max,valid,missing);
endp;
