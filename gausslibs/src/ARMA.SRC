proc(12) = hant(y,maxlag,qmax,pt,select,x,choose,ny);
    local zi,bhat,ss,zz,l,dep,z,so,postodd,b,ahat,ehat;
    local yy,picnp,jp,jpp,jq,jqq,zh,armahat,psel,qsel,q;
    local pmax,hhat,vv,nn,vmat,st,trat;
    local g,pk,zj,yt,ytt,sig2,ferror,pred,nnn,nx,yf,fev,alag;
    local aa1,aa2,a1,a2,a3,a4,a5,bic,b2,b3,b4,b5;
    zi = zeros(maxlag+1,1);
    l = maxlag+1;
    do until l<1;
        { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,pt,l-1);
        zi[l] = bic;
        l = l-1;
    endo;
    picnp = minindc(zi)-1;
    zj = zeros(pt+2,1);
    pk = 1;
    do until pk > pt+2;
        { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,pk-2,picnp);
        zj[pk] = bic;
        pk = pk+1;
    endo;
    pt = minindc(zj)-2;
    g = pt+2;
    qsel = 0;
    if select == 0;         @ employ AR models for postodd @
        hhh:
        q=qsel;
        psel=picnp;
        { dep,z,sig2,bic,postodd,bhat,ahat,ehat } = ppadfbic(y,pt,psel);
        { vmat,st,trat } = sterr(bhat,z,sig2);
        if choose == 1;    @ adjust for unit case @
            yy = y;
            if postodd < 1.00;
                {bhat,fev,pred,sig2,ferror}=adjust(x,ny,pt,psel,q);
            else;
                {ferror,fev,pred,nnn} = ferrfev(x,ny,pt,psel,q);
            endif;
        else;
            {ferror,fev,pred,nnn} = ferrfev(x,ny,pt,psel,q);
        endif;
    else;          @ select=1, ARMA case @
        pmax = picnp + 2;  @ add extra AR lags before ARMA model selection @
        { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,pt,pmax);
            zh = zeros(pmax+1,qmax+1);
            jp = 1;
            do until jp>pmax+1;
                jq = 1;
                do until jq>qmax+1;
                    { armahat,aa2,b2,bic,b4,b5,zz } = armamayy(dep,ehat,
                        jp-1,jq-1,pt);
                    zh[jp,jq] = bic;
                    jq = jq+1;
                endo;
                jp = jp+1;
            endo;
        {psel,qsel} = ppmax(-zh);
        psel = psel - 1;
        qsel = qsel - 1;
        if qsel == 0;
            goto hhh;
        else;
            q=qsel;
            { dep,z,sig2,bic,postodd,bhat,ahat }=armamayy(dep,ehat,psel,q,pt);
            { vmat,st,trat } = sterr(bhat,z,sig2);
            if choose == 1;
               if postodd < 1.00;
                 {bhat,fev,pred,sig2,ferror}=adjust(x,ny,pt,z,y,psel,q);
               else;
                 {ferror,fev,pred,nnn} = ferrfev(x,ny,pt,psel,q);
               endif;
            else;
              {ferror,fev,pred,nnn} = ferrfev(x,ny,pt,pmax,q);
            endif;
        endif;
    endif;
    retp(psel,qsel,bhat,fev,ahat,sig2,postodd,ferror,pt,vmat,st,trat);
endp;

proc(9) = hanrisst(y,maxlag,qmax,pt,select,x,choose,ny);
local psel,qsel,bhat,fev,ahat,sig2,postodd,ferror,vmat,
      st,trat;
{ psel,qsel,bhat,fev,ahat,sig2,postodd,ferror,pt,vmat,st,trat }
= hant(y,maxlag,qmax,pt,select,x,choose,ny);
retp(psel,qsel,bhat,fev,ahat,sig2,postodd,ferror,pt);
endp;

proc(3) = bsplit(d,p,q,pt);
local a,b,c;
    if pt > -1;
       c = d[1:pt+1];
    elseif pt == -1;
       c = 0;
    endif;
    pt = pt + 1;
    if p > 0;
       a = d[pt+1:pt+p];
       if q > 0;
            b = d[pt+p+1:pt+p+q];
       else;
            b = 0;
       endif;
    elseif p == 0;
       a = 0;
       if q > 0;
            b = d[pt+1:pt+q];
       elseif q == 0;
            b = 0;
       endif;
    endif;
retp(a,b,c);   @ AR,MA,Tr coefficients  @
endp;

proc  reorgld(a);
local kg,g1,g2,g3,gg,h,hx,kk;
    kk = rows(a);
    kg = kk-1;
    g1 = zeros(1,kg);
    g2 = -ones(kg,kg);
    g3 = lowmat(g2);
    gg = g1|g3;
    h  = ones(kk,1)~gg;
retp(h'a);
endp;

proc  reorgdl(phi);
local kg,g1,g2,g3,gg,h,hx,kk;
    kk = rows(phi);
    kg = kk-1;
    g1 = zeros(1,kg);
    g2 = -ones(kg,kg);
    g3 = lowmat(g2);
    gg = g1|g3;
    h  = ones(kk,1)~gg;
    hx = inv(h);
retp(hx'phi);
endp;

proc(2) = ppso(y,p,q,pt,d);
local y0,e0,etilde1,etilde2,ah,bh,so,j,yy,a,b,c,xmat;
   if p > 0;
     y0 = zeros(p,1);
   endif;
   if q > 0;
     e0 = zeros(q,1);
   endif;
   { a,b,c } = bsplit(d,p,q,pt);
   xmat      = pptrend(rows(y),pt);
   y = y - xmat*c;
   if p >= 1;
      if p >= 2;
         a  = reorgdl(a);
      endif;
      ah = a;
      yy = y;
      j  = 1;
      do until j > p;
     yy = yy-(ah[j]*lagn(y,j));
         j = j + 1;
      endo;
      etilde1 = missrv(yy,0);
   else;
      etilde1 = missrv(y,0);
   endif;
   if q >= 1;
      bh = b;
      etilde1 = missrv(etilde1,0);
      etilde2 = recserar(etilde1,e0,-bh);
   else;
      etilde2 = etilde1;
   endif;
   etilde2 = missrv(etilde2,0);
   so = etilde2'etilde2/(rows(etilde2)-p-q);
retp(so,etilde2);
endp;

proc chekarma(d,p,q,pt);
local a,b,c,a1,b1,dd;
   { a,b,c } = bsplit(d,p,q,pt);
   a1 = polyroot(1|(-a));
   b1 = polyroot(1|b);
   a1 = maxc(abs(a1[.,1]));
   b1 = maxc(abs(b1[.,1]));
   if a1 > 0.95 or b1 > 0.95;
      " Third stage is unstable: recursion curtailed at second stage ";
      dd = 1;
   else;
      dd = 0;
   endif;
retp(dd);
endp;

proc(6) = han3(y,etilde,ehat,p,q,pt,d);
local acoeff,bcoeff,start,eta,ett,jx,xi,xit,eps,a,b,c,chek3,dep,
      bic,postodd,ahat,
      xmat,z,errcoeff,sig2,vmat,st,trat,kk,sig21,sig22;
  { sig2,etilde } = ppso(y,p,q,pt,d);
  { d,vmat,st,trat,sig2 }
  = haniter3(y,etilde,p,q,pt,d);
  chek3 = chekarma(d,p,q,pt);
  if chek3 == 1;
    { dep,z,sig2,bic,postodd,d,ahat }
    = armamay(y,ehat,p,q,pt) ;
    { vmat,st,trat } = sterr(d,z,sig2);
    retp(d,vmat,st,d./st,sig2,ehat);
  endif;
  kk    = 1;
  herexx1:
  sig21 = sig2;
  { sig2,etilde } = ppso(y,p,q,pt,d);
  { d,vmat,st,trat,sig22 }
  = haniter3(y,etilde,p,q,pt,d);
  chek3 = chekarma(d,p,q,pt);
  if chek3 == 1;
    { dep,z,sig2,bic,postodd,d,ahat }
    = armamay(y,ehat,p,q,pt) ;
    { vmat,st,trat } = sterr(d,z,sig2);
    retp(d,vmat,st,d./st,sig2,ehat);
  endif;
  kk    = kk + 1;
  if sig22-sig21< 0.001*sig21 or kk > 10;
     retp(d,vmat,st,d./st,sig2,etilde);
  else;
     goto herexx1;
  endif;
endp;

proc(5) = haniter3(y,etilde,p,q,pt,d);
local acoeff,bcoeff,start,eta,ett,jx,xi,xit,eps,a,b,c,chek3,
      xmat,z,errcoeff,ehat,sig2,vmat,st,trat,res,izz;
eps = etilde;
if q == 0;
   " Error: q must be > 0 ";
   retp(d,0,0,0,0,etilde);
endif;
{ a,b,c } = bsplit(d,p,q,pt);
if p >= 1;
    acoeff = a;
    start  = zeros(p,1);
    eta    = recserar(eps,start,acoeff);
    eta    = lagn(eta,1);
    ett    = eta;
    jx     = 1;
    do until jx > p-1;
       ett = ett~lagn(eta,jx);
       jx  = jx+1;
    endo;
    eta    = ett;
endif;
if q >= 1;
    bcoeff = b;
    start  = zeros(q,1);
    xi     = recserar(eps,start,-bcoeff);
    xi     = lagn(xi,1);
    xit    = xi;
    jx     = 1;
    do until jx > q-1;
       xit = xit~lagn(xi,jx);
       jx  = jx+1;
    endo;
    xi     = xit;
endif;
if p >= 1;
    z      = eta;
    if q >=1;
        z  = z~xi;
    endif;
else;
    if q >=1;
        z   = xi;
    endif;
endif;
if  p > 0 or q > 0;
   if pt >= 0;
      xmat = pptrend(rows(z),pt);
      z    = xmat~z;
   endif;
   eps      = missrv(eps,0);
   z        = missrv(z,0);
   errcoeff = eps/z;
   d        = d + errcoeff;
   res      = eps - z*errcoeff;
   sig2     = res'res/(rows(eps)-cols(z));
endif;
{vmat,st,trat}  = sterr(errcoeff,z,sig2);
retp(d,vmat,st,d./st,sig2);
endp;

proc (8) = ppadfbic(x,pt,l) ;
     local cn,timep,t,m,xmat,nobs,dep,ch,z,k,kx,b,g,ss;
     local so,bic,postodd,bhat,ahat,res,nreg,zo,vv,hhat;
     if (pt < -1);
       "Error: p cannot be < -1";
        retp(zeros(8,1));
     endif ;
     nobs    = rows(x);
     if (nobs - (2*l) + 1 < 1) ;
       "Error: l is too large; negative degrees of freedom.";
        retp(zeros(8,1));
     endif ;
     cn        = ones(nobs,1) ;
     if pt > 0 ;
       timep    = zeros(nobs,pt) ;
       t        = seqa(1,1,nobs)/nobs ;
       m        = 1 ;
       do while m <= pt ;
          timep[.,m] = t^m ;
          m = m + 1 ;
       endo ;
       xmat     = cn~timep ;
     elseif pt==0 ;
       xmat = cn ;
     endif ;
     dep     = trimr(x,1,0);
     if pt>=0;
         xmat = trimr(xmat,1,0);
     endif;
     ch      = trimr(x,1,0)-trimr(lagn(x,1),1,0) ;
     z       = trimr(lagn(x,1),1,0) ;
     if l > 1;
        k=2 ;
        do until k > l ;
           kx=k-1;
       z = z~lagn(ch,kx) ;
           k = k + 1 ;
        endo ;
        if pt >= 0;
           z       = xmat~z ;
        endif;
        z       = trimr(z,k-2,0) ;
        dep     = trimr(dep,k-2,0) ;
     elseif l==1;
          if pt >= 0;
             z       = xmat~z ;
          endif;
     else;
          if pt == -1;
             goto hhh;
          else;
             z  = xmat;
          endif;
     endif;
     b       = dep/z ;
     res     = dep - z*b ;
     nreg    = cols(z);
     so      = (res'res)/(rows(dep)-nreg);
     zo      = z'z;
     bic     = ln(so)+cols(z)*cols(dep)*ln(rows(dep))/rows(dep);
     if l>0;
        g       = pt+2;
        ahat    = b[g];
        hhat    = ahat - 1;
        vv      = so*inv(zo);
        vv      = vv[g,g];
        postodd = exp(0.5*(hhat^2)/vv)/(1/vv)^0.5;
     else;
        ahat    = 0;
        postodd = 1.1;
     endif;
     goto hhx;
     hhh:
     b      =  0;
     ahat   =  0;
     z      =  0;
     res    =  dep;
     so     =  res'res/(rows(dep));
     bic    = ln(so);
     postodd= 1.1;
     hhx:
retp(dep,z,so,bic,postodd,b,ahat,res);
endp ;

proc (4) = adftr(x,p,pt);
local dep,z,sig2,bic,postodd,b,ahat,res,
      vmat,st,trat;
  { dep,z,sig2,bic,postodd,b,ahat,res }
  = ppadfbic(x,pt,p) ;
  {vmat,st,trat}  = sterr(b,z,sig2);
retp(b,st,trat,vmat);
endp;

proc (8) = ppadfbit(x,pt,l) ;
/************  ppadfbic with no scaling of time trend *******************/
     local cn,timep,t,m,xmat,nobs,ch,k,kx,b,g,ss;
     local dep,z,so,bic,postodd,bhat,ahat,res,nreg,zo,vv,hhat;
     if (pt < -1);
        "Error: p cannot be < -1";
         retp(zeros(8,1));
     endif ;
     nobs    = rows(x);
     if (nobs - (2*l) + 1 < 1) ;
       "Error: l is too large; negative degrees of freedom.";
        retp(zeros(8,1));
     endif ;
     cn        = ones(nobs,1) ;
     if pt > 0 ;
       timep    = zeros(nobs,pt) ;
       t        = seqa(1,1,nobs);
       m        = 1 ;
       do while m <= pt ;
          timep[.,m] = t^m ;
          m = m + 1 ;
       endo ;
       xmat     = cn~timep ;
     elseif pt==0 ;
       xmat = cn ;
     endif ;
     dep     = trimr(x,1,0);
     if pt>=0;
         xmat = trimr(xmat,1,0);
     endif;
     ch      = trimr(x,1,0)-trimr(lagn(x,1),1,0) ;
     z       = trimr(lagn(x,1),1,0) ;
     if l > 1;
        k=2 ;
        do until k > l ;
           kx=k-1;
       z = z~lagn(ch,kx) ;
           k = k + 1 ;
        endo ;
        if pt >= 0;
           z       = z~xmat ;
        endif;
        z       = trimr(z,k-2,0) ;
        dep     = trimr(dep,k-2,0) ;
     elseif l==1;
          if pt >= 0;
             z       = z~xmat ;
          endif;
     else;
          if pt == -1;
             goto hhh;
          else;
             z  = xmat;
          endif;
     endif;
     b       = dep/z ;
     res     = dep - z*b ;
     nreg    = cols(z);
     so      = (res'res)/(rows(dep)-nreg);
     zo      = z'z;
     bic     = ln(so)+cols(z)*cols(dep)*ln(rows(dep))/rows(dep);
     if l>0;
        g       = pt+2;
        ahat    = b[g];
        hhat    = ahat - 1;
        vv      = so*inv(zo);
        vv      = vv[g,g];
        postodd = exp(0.5*(hhat^2)/vv)/(1/vv)^0.5;
     else;
        ahat    = 0;
        postodd = 1.1;
     endif;
     goto hhx;
     hhh:
     b      =  0;
     ahat   =  0;
     z      =  0;
     res    =  dep;
     so     =  res'res/(rows(dep));
     bic    = ln(so);
     postodd= 1.1;
     hhx:
retp(dep,z,so,bic,postodd,b,ahat,res);
endp ;

proc (7) = armamay(x,e,p,q,pt) ;
    local cn,timep,t,m,xmat,nobs,dep,ch,nreg,res,vv,hhat,ahat,zo;
    local z,so,bic,postodd,b,bhat,g,k,j,kj,pq,zod;
    if (pt < -1);
        print "Error: pt cannot be < -1";
        retp(0,0,0,0,0,0);
    endif ;
    nobs = rows(x);
    if (nobs - (p+q) + 1 < 1) ;
        print "Error: p+q is too large; negative degrees of freedom.";
        retp(0,0,0,0,0,0);
    endif ;
    cn = ones(nobs,1) ;
    if pt > 0 ;
        timep = zeros(nobs,pt) ;
        t = seqa(1,1,nobs)/nobs ;
        m = 1 ;
        do while m <= pt ;
            timep[.,m] = t^m ;
            m = m + 1 ;
        endo ;
        xmat = cn~timep ;
    elseif pt==0;
        xmat = cn ;
    endif ;
    dep = trimr(x,1,0);
    if pt>=0;
        xmat = trimr(xmat,1,0) ;
    endif;
    ch = trimr(x,1,0)-trimr(lagn(x,1),1,0) ;
    z = trimr(lagn(x,1),1,0);
    e = trimr(lagn(e,1),1,0);
    if p > 0;
        pq = 2;
        k = 1;
        if p > 1;
            do until k >= p ;
        z = z~lagn(ch,k) ;
                k = k + 1 ;
            endo ;
        else;
            z = z;
        endif;
        if q > 0;     @ p>0 and q>0 @
            z = z~e;
            j = 1;
            do until j >= q;
        z = z~lagn(e,j);
                j = j + 1;
            endo;
            kj = maxc(k|j)-1;
            z = trimr(z,kj,0) ;
            dep = trimr(dep,kj,0) ;
            if pt>=0;
                xmat = trimr(xmat,kj,0) ;
            endif;
        else;        @ p>0 and q=0 @
            kj = k-1;
            z = trimr(z,kj,0) ;
            dep = trimr(dep,kj,0) ;
            if pt>=0;
                xmat = trimr(xmat,kj,0) ;
            endif;
        endif;
    else;       @ p == 0 @
        if q > 0;    @ p=0 and q>0 @
            pq = 1;
            z = e;
            j = 1;
            do until j >= q;
        z = z~lagn(e,j);
                j = j + 1;
            endo;
            kj = j-1;
            z = trimr(z,kj,0) ;
            dep = trimr(dep,kj,0) ;
            if pt>=0;
                xmat = trimr(xmat,kj,0) ;
            endif;
        else;    @ p=0 and q=0 @
            pq = 0;
        endif;
    endif;
    g = pt + 2;
    if pq > 1;
        if pt > -1;
            z = xmat~z;
        endif;
        b = dep/z ;
        res = dep - z*b ;
        nreg = cols(z);
        so = (res'res)/(rows(dep)-nreg);
        bic = ln(so)+cols(z)*(cols(dep)^2)*ln(rows(dep))/rows(dep);
        zod = z'z;
        ahat = b[g];
        hhat = ahat - 1;
        vv = so*invpd(zod);
        vv = vv[g,g];
        postodd = exp(0.5*(hhat^2)/vv)/(1/vv)^0.5;
    elseif pq==1;
        postodd = 1.1;
        ahat = 1;
        if pt > -1;
            z = xmat~z;
        endif;
        b = dep/z ;
        res = dep - z*b ;
        nreg = cols(z);
        so = (res'res)/(rows(dep)-nreg);
        bic = ln(so)+cols(z)*(cols(dep)^2)*ln(rows(dep))/rows(dep);
    else;
        postodd = 1.1;
        ahat = 0;
        if pt > -1;
            z = xmat;
            b = dep/z;
            res = dep - z*b ;
            so = (res'res)/(rows(dep)-cols(z));
            bic = ln(so)+cols(z)*(cols(dep)^2)*ln(rows(dep))/rows(dep);
        else;       /* pt = -1 */
            b = 0;
            res = dep;
            so = res'res/rows(res);
            bic = ln(so);
        endif;
    endif;
    retp(dep,z,so,bic,postodd,b,ahat);
endp ;

proc pptrend(nobs,pt);
local cn,xmat,m,timep,t;
    if (pt < -1);
      "Error: pt cannot be < -1";
      retp(0,0,0,0,0,0);
    endif ;
    cn = ones(nobs,1) ;
    if pt > 0 ;
        timep = zeros(nobs,pt) ;
        t = seqa(1,1,nobs)/nobs ;
        m = 1 ;
        do while m <= pt ;
            timep[.,m] = t^m ;
            m = m + 1 ;
        endo ;
        xmat = cn~timep ;
    elseif pt== 0;
        xmat = cn ;
    elseif pt == -1;
        xmat = 0;
    endif ;
    retp(xmat);
endp;

proc detrend(data,p) ;
    local t, u, m, timep, it, iit, xmat, invx, beta, resid, nobs ;
    if (p == -1) ;
        retp(data);
    endif ;
    nobs = rows(data) ;
    u = ones(nobs,1) ;
    if p > 0 ;
        timep = zeros(nobs,p) ;
        t = seqa(1,1,nobs)/nobs ;
        m = 1 ;
        do while m <= p ;
            timep[.,m] = t^m ;
            m = m + 1 ;
        endo ;
        xmat = u~timep ;
    else ;
        xmat = u ;
    endif ;
    invx = inv(xmat'xmat) ;
    beta = invx*(xmat'data) ;
    resid = data - xmat*beta ;
    retp(resid) ;
endp ;

proc (7) = armamayy(x,e,p,q,pt) ;
@******* includes Kavalieris(1991) estimate of s^2(p,q) in BIC *********@
    local cn,timep,t,m,xmat,nobs,dep,ch,nreg,res,vv,hhat,ahat,zo;
    local z,so,bic,postodd,b,bhat,g,k,j,kj,pq,zod,etilde;
    if (pt < -1);
        print "Error: pt cannot be < -1";
        retp(0,0,0,0,0,0);
    endif ;
    nobs = rows(x);
    if (nobs - (p+q) + 1 < 1) ;
        print "Error: p+q is too large; negative degrees of freedom.";
        retp(0,0,0,0,0,0);
    endif ;
    cn = ones(nobs,1) ;
    if pt > 0 ;
        timep = zeros(nobs,pt) ;
        t = seqa(1,1,nobs)/nobs ;
        m = 1 ;
        do while m <= pt ;
            timep[.,m] = t^m ;
            m = m + 1 ;
        endo ;
        xmat = cn~timep ;
    elseif pt==0;
        xmat = cn ;
    endif ;
    dep = trimr(x,1,0);
    if pt>=0;
        xmat = trimr(xmat,1,0) ;
    endif;
    ch = trimr(x,1,0)-trimr(lagn(x,1),1,0) ;
    z = trimr(lagn(x,1),1,0);
    e = trimr(lagn(e,1),1,0);
    if p > 0;
        pq = 2;
        k = 1;
        if p > 1;
            do until k >= p ;
                z = z~lagn(ch,k) ;
                k = k + 1 ;
            endo ;
        else;
            z = z;
        endif;
        if q > 0;     @ p>0 and q>0 @
            z = z~e;
            j = 1;
            do until j >= q;
                z = z~lagn(e,j);
                j = j + 1;
            endo;
            kj = maxc(k|j)-1;
            z = trimr(z,kj,0) ;
            dep = trimr(dep,kj,0) ;
            if pt>=0;
                xmat = trimr(xmat,kj,0) ;
            endif;
        else;        @ p>0 and q=0 @
            kj = k-1;
            z = trimr(z,kj,0) ;
            dep = trimr(dep,kj,0) ;
            if pt>=0;
                xmat = trimr(xmat,kj,0) ;
            endif;
        endif;
    else;       @ p == 0 @
        if q > 0;    @ p=0 and q>0 @
            pq = 1;
            z = e;
            j = 1;
            do until j >= q;
                z = z~lagn(e,j);
                j = j + 1;
            endo;
            kj = j-1;
            z = trimr(z,kj,0) ;
            dep = trimr(dep,kj,0) ;
            if pt>=0;
                xmat = trimr(xmat,kj,0) ;
            endif;
        else;    @ p=0 and q=0 @
            pq = 0;
        endif;
    endif;
    g = pt + 2;
    if pq > 1;
        if pt > -1;
            z = xmat~z;
        endif;
        b = dep/z ;
        res = dep - z*b ;
        nreg = cols(z);
        if q > 0;
          { so,etilde } = ppso(dep,p,q,pt,b);
        elseif q == 0;
          so = (res'res)/(rows(dep)-nreg);
        endif;
        bic = ln(so)+cols(z)*(cols(dep))*ln(rows(dep))/rows(dep);
        zod = z'z;
        ahat = b[g];
        hhat = ahat - 1;
        vv = so*invpd(zod);
        vv = vv[g,g];
    elseif pq==1;
        ahat = 1;
        if pt > -1;
            z = xmat~z;
        endif;
        b = dep/z ;
        res = dep - z*b ;
        nreg = cols(z);
        if q > 0;
          { so,etilde } = ppso(dep,p,q,pt,b);
        elseif q == 0;
          so = (res'res)/(rows(dep)-nreg);
        endif;
        bic = ln(so)+cols(z)*(cols(dep))*ln(rows(dep))/rows(dep);
    else;
        ahat = 0;
        if pt > -1;
            z = xmat;
            b = dep/z;
            res = dep - z*b ;
            so = (res'res)/(rows(dep)-cols(z));
            bic = ln(so)+cols(z)*(cols(dep))*ln(rows(dep))/rows(dep);
        else;       /* pt = -1 */
            b = 0;
            res = dep;
            so = res'res/rows(res);
            bic = ln(so);
        endif;
    endif;
        postodd = 1.1;
    retp(dep,z,so,bic,postodd,b,ahat);
endp ;

proc (5) = adjust(x,ny,pt,z,yy,pick,qsel);
    local dep,zhat,bhat,zz,res,sig2,fev,alag,pred,ferror,nnn,q;
    q=qsel;
    dep = trimr(yy,1,0)-trimr(lagn(yy,1),1,0) ;
    dep = trimr(dep,rows(dep)-rows(z),0);
    if q > 0;
        if pt > -1;
            z = z[., 1:pt+1 pt+3:cols(z)];
            zhat = dep/z;
            bhat = zhat[1:pt+1]|1.00|zhat[pt+2:rows(zhat)];
            zz = z'z;
            res = dep - z*zhat;
            sig2 = res'res/(rows(res)-cols(z));
            { z,ferror,pred,nnn } = ferr(x,ny,pt,pick,bhat,q);
            z = z[., 1:pt+1 pt+3:cols(z)];
            alag = inv(zz);
            fev = 1 + z[nnn,.]*alag*z[nnn,.]';
        else;                @ pt = -1 @
            z = z[.,2:cols(z)];
            zz = z'z;
            zhat = dep/z;
            res = dep - z*zhat;
            sig2 = res'res/(rows(res)-cols(z));
            bhat = 1.00|zhat[1:rows(zhat)];
            { z,ferror,pred,nnn } = ferr(x,ny,pt,pick,bhat,q);
            z = z[.,2:cols(z)];
            alag = inv(zz);
            fev = 1 + z[nnn,.]*alag*z[nnn,.]';
        endif;
    else;             @  q = 0  @
        if pt > -1;
            if pick > 1.00;
                z = z[., 1:pt+1 pt+3:cols(z)];
                zhat = dep/z;
                bhat = zhat[1:pt+1]|1.00|zhat[pt+2:rows(zhat)];
            elseif pick==1;
                z = z[.,1:pt+1];
                zhat = dep/z;
                bhat = zhat[1:pt+1]|1.00;
            endif;
            zz = z'z;
            res = dep - z*zhat;
            sig2 = res'res/(rows(res)-cols(z));
            { z,ferror,pred,nnn } = ferr(x,ny,pt,pick,bhat,q);
            if pick > 1.00;
                z = z[., 1:pt+1 pt+3:cols(z)];
            elseif pick==1;
                z = z[.,1:pt+1];
            endif;
            alag = inv(zz);
            fev = 1 + z[nnn,.]*alag*z[nnn,.]';
        else;                @ pt = -1 @
            if pick > 1.00;
                z = z[.,2:cols(z)];
                zz = z'z;
                zhat = dep/z;
                res = dep - z*zhat;
                sig2 = res'res/(rows(res)-cols(z));
                bhat = 1.00|zhat[1:rows(zhat)];
            elseif pick==1;
                sig2 = dep'dep/rows(dep);
                bhat = 1.00;
            else;              @ no regressors in this case @
                sig2 = dep'dep/rows(dep);
                bhat = 0;
            endif;
            { z,ferror,pred,nnn } = ferr(x,ny,pt,pick,bhat,q);
            if pick > 1.00;
                z = z[.,2:cols(z)];
                alag = inv(zz);
                fev = 1 + z[nnn,.]*alag*z[nnn,.]';
            else;
                fev = 1;
            endif;
        endif;
    endif;
retp(bhat,fev,pred,sig2,ferror);
endp;

proc(4) = ferr(x,ny,pt,pick,bhat,qsel);
    local dep,z,so,bic,postodd,b,ahat,res,nnn,pred,ferror,q;
    q=qsel;
    x = x[1:ny+1];
    if q==0;
        { dep,z,so,bic,postodd,b,ahat,res } = ppadfbic(x,pt,pick);
    else;
        { dep,z,so,bic,postodd,b,ahat,res } = ppadfbic(x,pt,pick);
        { dep,z,so,bic,postodd,b,ahat } = armamay(dep,res,pick,q,pt);
    endif;
    nnn = rows(z);
    pred = z[nnn,.]*bhat ;
    ferror = dep[nnn] - pred;
    retp(z,ferror,pred,nnn);
endp;

proc(4) = ferrfev(x,ny,pt,pick,qsel);
    local dep,z,b,so,bic,postodd,ahat,res;
    local pred,nnn,ferror,zz,alag,fev,q,nreg;
    q=qsel;
    x = x[1:ny+1];
    if q==0;
        { dep,z,so,bic,postodd,b,ahat,res } = ppadfbic(x,pt,pick);
    else;
        { dep,z,so,bic,postodd,b,ahat,res } = ppadfbic(x,pt,pick);
        { dep,z,so,bic,postodd,b,ahat } = armamay(dep,res,pick,q,pt);
    endif;
    nnn = rows(z);
    pred = z[nnn,.]*b ;
    ferror = dep[nnn] - pred;
    zz = z'z - z[nnn,.]'*z[nnn,.];
    nreg = pick + q + (pt+1);
    if nreg > 0;
        alag = inv(zz);
        fev = 1 + z[nnn,.]*alag*z[nnn,.]';
    else;         @ no regressor case where pt=-1 and p=q=0  @
        fev = 1;
    endif;
    retp(ferror,fev,pred,nnn);
endp;

proc (2) = ppmax(x);
local mc,jc,mm,jj;
  mc=maxc(x);
  jc=maxindc(x);
  mm=maxc(mc);
  jj=maxindc(mc);
  retp(jc[jj],jj);
endp;

proc(9) = armabic(y,pmax,qmax,tmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat;
   { zar,lsel,tsel,ehat,dep } = arbice(y,pmax,tmax);
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,tsel,pmax);
   zh = zeros(pmax+1,qmax+1);
   jp = 1;
   do until jp>pmax+1;
      jq = 1;
      do until jq>qmax+1;
        { dep2,z,so,bic,postodd,b,ahat }
        = armamayy(dep,ehat,jp-1,jq-1,tsel) ;
        zh[jp,jq] = bic;
        jq = jq+1;
      endo;
   jp = jp+1;
   endo;
   {psel,qsel} = ppmax(-zh);
    psel = psel - 1;
    qsel = qsel - 1;
    { b,st,trat,vmat,so }
    = armastat(dep,ehat,tsel,psel,qsel);
retp(zh,psel,qsel,tsel,b,st,trat,vmat,so);
endp;

proc(9) = armabi3(y,pmax,qmax,tmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat;
   { zar,lsel,tsel,ehat,dep } = arbice(y,pmax,tmax);
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,tsel,pmax);
   zh = zeros(pmax+1,qmax+1);
   jp = 1;
   do until jp>pmax+1;
      jq = 1;
      do until jq>qmax+1;
        { dep2,z,so,bic,postodd,b,ahat }
        = armamayy(dep,ehat,jp-1,jq-1,tsel) ;
        zh[jp,jq] = bic;
        jq = jq+1;
      endo;
   jp = jp+1;
   endo;
   {psel,qsel} = ppmax(-zh);
    psel = psel - 1;
    qsel = qsel - 1;
    { b,st,trat,vmat,sig2 }
    = armasta3(dep,ehat,tsel,psel,qsel);
retp(zh,psel,qsel,tsel,b,st,trat,vmat,sig2);
endp;

proc(9) = armabic3(y,pmax,qmax,tmax);
    retp(armabi3(y,pmax,qmax,tmax));
endp;

proc(9) = armabic2(y,pmax,qmax,tmax);
    retp(armabic(y,pmax,qmax,tmax));
endp;

proc(4) = armatr(y,p,q,t,pmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat;
   if q == 0;
      { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,p);
      {vmat,st,trat}  = sterr(b,z,sig2);
      retp(b,st,trat,vmat);
   endif; if pmax < p; pmax = p; endif;
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,pmax);
   { dep2,z,so,bic,postodd,b,ahat }
   = armamayy(dep,ehat,p,q,t) ;
   { b,st,trat,vmat,sig2 }
   = armasta3(dep,ehat,t,p,q);
retp(b,st,trat,vmat);
endp;

proc(4) = armatra(y,p,q,t,pmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat,aic;
   if q == 0;
      { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,p);
      {vmat,st,trat}  = sterr(b,z,sig2);
      retp(b,st,trat,vmat);
   endif;
   { aic,pmax,t }
   = araic(y,pmax,t); if pmax < p; pmax = p; endif;
   " Value of AR lag 'pmax' reset using AIC: " pmax;
   " Value of Tr trend degree reset using AIC to: " t;
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,pmax);
   { dep2,z,so,bic,postodd,b,ahat }
   = armamayy(dep,ehat,p,q,t) ;
   { b,st,trat,vmat,sig2 }
   = armasta3(dep,ehat,t,p,q);
retp(b,st,trat,vmat);
endp;

proc(4) = armatr2(y,p,q,t,pmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat,aic;
   if q == 0;
      { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,p);
      {vmat,st,trat}  = sterr(b,z,sig2);
      retp(b,st,trat,vmat);
   endif;
   { aic,pmax,t }
   = araic(y,pmax,t);
   " Value of AR lag 'pmax' reset using AIC to: " pmax;
   " Value of TR degree reset using AIC to: " t;
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,pmax);
   { dep2,z,so,bic,postodd,b,ahat }
   = armamay(dep,ehat,p,q,t) ;
   { b,st,trat,vmat,so }
   = armastat(dep,ehat,t,p,q);
retp(b,st,trat,vmat);
endp;

proc(2) = armatr2e(y,p,q,t,pmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat;
   if q == 0;
      { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,p);
      {vmat,st,trat}  = sterr(b,z,sig2);
      retp(ehat,sig2);
   endif;
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,pmax);
   { dep2,z,so,bic,postodd,b,ahat }
   = armamay(dep,ehat,p,q,t) ;
   { b,st,trat,vmat,sig2 }
   = armastat(dep,ehat,t,p,q);
retp(ehat,sig2);
endp;


proc(5) = armatrc(y,p,q,t,pmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,dep2,
      b,ahat,ehat,lsel,tsel,zar,so,psel,qsel,
      st,trat,vmat;
   if q == 0;
      { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,p);
      {vmat,st,trat}  = sterr(b,z,sig2);
      retp(b,st,trat,vmat,sig2);
   endif;
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,t,pmax);
   { dep2,z,sig2,bic,postodd,b,ahat }
   = armamay(dep,ehat,p,q,t) ;
   { b,st,trat,vmat,sig2 }
   = armastat(dep,ehat,t,p,q);
retp(b,st,trat,vmat,sig2);
endp;

proc(3) = arbic(y,lmax,tmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,
      b,ahat,ehat,lsel,tsel;
   zh = zeros(lmax+1,tmax+2);
   jp = 1;
   do until jp>lmax+1;
      jq = 1;
      do until jq>tmax+2;
        { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,jq-2,jp-1);
        zh[jp,jq] = bic;
        jq = jq+1;
       endo;
   jp = jp+1;
   endo;
   {lsel,tsel} = ppmax(-zh);
   lsel = lsel - 1;
   tsel = tsel - 2;
retp(zh,lsel,tsel);
endp;

proc(3) = arpic(y,lmax,tmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,
      b,ahat,ehat,lsel,tsel,aic,pic;
   zh = zeros(lmax+1,tmax+2);
   jp = 1;
   do until jp>lmax+1;
      jq = 1;
      do until jq>tmax+2;
        { aic,bic,pic } = pparord(y,jq-2,tmax,jp-1,lmax);
        zh[jp,jq] = pic;
        jq = jq+1;
       endo;
   jp = jp+1;
   endo;
   {lsel,tsel} = ppmax(zh);
   lsel = lsel - 1;
   tsel = tsel - 2;
retp(zh,lsel,tsel);
endp;

proc(3) = araic(x,pmax,tmax);
local aic,bic,pic,psel,tsel;
   { aic,bic,pic } = arord(x,pmax,tmax);
   {psel,tsel} = ppmax(-aic);
   psel = psel - 1;
   tsel = tsel - 2;
retp(aic,psel,tsel);
endp;

proc(5) = arbice(y,lmax,tmax);
local zh,jp,jq,dep,z,sig2,bic,postodd,
      b,ahat,ehat,lsel,tsel;
   zh = zeros(lmax+1,tmax+2);
   jp = 1;
   do until jp>lmax+1;
      jq = 1;
      do until jq>tmax+2;
        { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,jq-2,jp-1);
        zh[jp,jq] = bic;
        jq = jq+1;
       endo;
   jp = jp+1;
   endo;
   {lsel,tsel} = ppmax(-zh);
   lsel = lsel - 1;
   tsel = tsel - 2;
   { dep,z,sig2,bic,postodd,b,ahat,ehat } = ppadfbic(y,tsel,lsel);
retp(zh,lsel,tsel,ehat,dep);
endp;

proc(7) = arbc(x,pmax,tmax);
local bic,l,t,st,trat,vmat,b;
{ bic,l,t } = arbic(x,pmax,tmax);
if l>0 or t>-1;
 { b,st,trat,vmat } = arstat(x,t,l);
else;
 b    = 0;
 st   = 0;
 trat = 0;
 vmat = 0;
endif;
grfbic(pmax,tmax,bic);  @ graph bic surface  @
grfbicl(pmax,t,bic);    @ graph bic(.,that) @
grfbict(l,tmax,bic);    @ graph bic(lhat,.) @
retp(bic,l,t,b,st,trat,vmat);
endp;

proc(8) = armabc(x,pmax,qmax,tmax);
local bic,p,q,t,st,trat,vmat,b,so;
{ bic,p,t } = arbic(x,pmax,tmax);
{ bic,p,q,t,b,st,trat,vmat,so } = armabic3(x,pmax,qmax,tmax);
grfbicpq(pmax,qmax,bic);  @ graph bic surface  @
grfbicp(pmax,q,bic);      @ graph bic(.,qhat) @
grfbicq(p,qmax,bic);      @ graph bic(phat,.) @
retp(bic,p,q,t,b,st,trat,vmat);
endp;

proc(8) = arpc(x,pmax,tmax);
local pic,picu,picv,t,st,trat,vmat,b,dep,z,l,
      so,bic,postodd,ahat,res,picmax;
{ pic,l,t } = arpic(x,pmax,tmax);
if l>0 or t>-1;
 { b,st,trat,vmat } = arstat(x,t,l);
else;
 b    = 0;
 st   = 0;
 trat = 0;
 vmat = 0;
endif;
grfpic(pmax,tmax,pic);        @ graph pic surface  @
grfpicl(pmax,t,pic);          @ graph pic(.,that) @
picmax =pic[l+1,t+2];
if l>0;
{ dep,z,so,bic,postodd,b,ahat,res } =
  ppadfbit(x,t,l);
picu = 1/postodd;
if picu > 0;
   picv = picmax + 2*ln(picu);
else;
   picv = picmax;
endif;
grfpiclu(pmax,t,pic,picv);    @ graph pic(.,that) @
elseif l==0;
picu = 0.0; @ set odds of unit root to zero if lag choice = 0 @
endif;
grfpict(l,tmax,pic);          @ graph pic(lhat,.) @
if l == 0 and t == -1;
retp(pic,picu,l,t,b,0,0,0);
endif;
retp(pic,picu,l,t,b,st,trat,vmat);
endp;

proc(5) = armastat(x,ehat,pt,p,q);
local dep,z,so,bic,postodd,b,ahat,res,vmat,st,trat;
   { dep,z,so,bic,postodd,b,ahat }
   = armamay(x,ehat,p,q,pt) ;
if rows(b) >= 1;
   { vmat,st,trat } = sterr(b,z,so);
else;
   retp(0,0,0,0);
endif;
retp(b,st,trat,vmat,so);
endp;

proc(5) = armasta3(x,ehat,pt,p,q);
local dep,z,so,sig2,bic,postodd,d,etilde,ahat,res,vmat,st,trat,
   a,b,c,chek3;
   { dep,z,so,bic,postodd,d,ahat }
   = armamayy(x,ehat,p,q,pt) ;
   if q >= 1;
      chek3 = chekarma(d,p,q,pt);
      if chek3 == 1;
        { dep,z,so,bic,postodd,d,ahat }
        = armamay(x,ehat,p,q,pt) ;
        { vmat,st,trat } = sterr(d,z,so);
         retp(d,st,trat,vmat,so);
      endif;
      { sig2,etilde } = ppso(x,p,q,pt,d);
      { d,vmat,st,trat,sig2,etilde }
      = han3(x,etilde,ehat,p,q,pt,d);
   elseif q == 0;
      sig2 = so;
      { vmat,st,trat } = sterr(d,z,so);
   endif;
retp(d,st,trat,vmat,sig2);
endp;

proc(4) = arstat(x,pt,l);
local dep,z,so,bic,postodd,b,ahat,res,vmat,st,trat;
   { dep,z,so,bic,postodd,b,ahat,res } = ppadfbic(x,pt,l);
if rows(b) >= 1;
   { vmat,st,trat } = sterr(b,z,so);
else;
   retp(0,0,0,0);
endif;
retp(b,st,trat,vmat);
endp;

proc(3) = sterr(bhat,z,sig2);
local vmat,st,trat;
  vmat  = sig2*invpd(z'z);
  st    = diag(vmat)^0.5;
  trat  = bhat./st;
retp(vmat,st,trat);
endp;

proc(0) =  grfbic(lmax,tmax,bic);
local x1,x2;
  graphset;
  x1=seqa(0,1,lmax+1);
  x2=seqa(-1,1,tmax+2);
  _pdate = "";
  title("BIC values for (p,t) array");
  _ptitlht = 0.34;
  _pframe = {0,0};
  _pnum = 1;
  _pzpmax = 0;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  volume(6,6,3);
  viewxyz(6.1,6.1,3.95);
  xtics(0,lmax+1,1,2);
  ytics(-1,tmax+2,1,2);
  xlabel("AR lag");
  ylabel("Trend");
  zlabel("BIC value");
  surface(x1',x2,bic');
endp;

proc(0) =  grfpic(lmax,tmax,pic);
local x1,x2,ztop,zmin,pick,zscale,kk;
  graphset;
  zscale = 0.0001;
  x1=seqa(0,1,lmax+1);
  x2=seqa(-1,1,tmax+2);
  _pdate = "";
  title("PIC values for (p,t) array");
  _ptitlht = 0.34;
  _pframe = {0,0};
  _pnum = 1;
  _pzpmax = 0;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  ztop = maxc(maxc(pic));
  pick = selif(pic,(pic[.,1].>0));
  x1   = selif(x1,pic[.,1].>0);
  volume(6,6,3);
  viewxyz(6.1,6.1,zscale*ztop);
  xtics(0,lmax+1,1,2);
  ytics(-1,tmax+2,1,2);
  zmin =  minc(minc(pick));
  ztics(zmin,ztop,(ztop-zmin)/3,2);
  xlabel("AR lag");
  ylabel("Trend");
  zlabel("PIC value");
  surface(x1',x2,pick');
  kk = 0;
  do until kk == 2;
  if kk == 0;
"***************************************************************";
"*******    type any key to continue and then:               ***";
"*******    type  1 at ? prompt to change viewpoint of graph ***";
"*******    type -1 at ? prompt to go back to last graph     ***";
"*******    type  2 at ? prompt to move on                   ***" ;
"*******    now type any key to continue                     ***";
"***************************************************************";
     wait;
  elseif kk == 1;  @ keyboard entry = "1" @
     zscale = 0.50 + zscale;
     viewxyz(6.1,6.1,zscale*ztop);
     zlabel("PIC value");
     surface(x1',x2,pick');
  elseif kk == -1;  @ keyboard entry = "-1" @
     zscale = -0.50 + zscale;
     viewxyz(6.1,6.1,zscale*ztop);
     zlabel("PIC value");
     surface(x1',x2,pick');
  endif;
  kk = con(1,1);
  endo;
endp;

proc(0) =  grfbicl(lmax,t,bic);
local x1;
  graphset;
  x1=seqa(0,1,lmax+1);
  _pdate = "";
  title("BIC values for (p,t_hat)");
  _ptitlht = 0.34;
  _pnum = 1;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  xtics(0,lmax+1,1,2);
  xlabel("AR lag");
  ylabel("BIC value");
  xy(x1,bic[.,t+2]);
endp;

proc(0) =  grfbicp(pmax,q,bic);
local x1;
  graphset;
  x1=seqa(0,1,pmax+1);
  _pdate = "";
  title("BIC values for (p,q_hat)");
  _ptitlht = 0.34;
  _pnum = 1;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  xtics(0,pmax+1,1,2);
  xlabel("AR lag");
  ylabel("BIC value");
  xy(x1,bic[.,q+1]);
endp;

proc(0) =  grfpicl(lmax,t,pic);
local x1;
  graphset;
  x1=seqa(0,1,lmax+1);
  _pdate = "";
  title("PIC values for (p,t_hat):\lselect maximum for lag order");
  _ptitlht = 0.32;
  _pnum = 1;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  xtics(0,lmax+1,1,2);
  xlabel("AR lag");
  ylabel("PIC value");
  xy(x1,pic[.,t+2]);
endp;


proc(0) =  grfpiclu(lmax,t,pic,picu);
local x1,x11,pick,xs,ys,n1;
  graphset;
  margin(0,0,0.0,1.0);
  _paxes = 1;
  x1   = seqa(0,1,lmax+1);
  x11  = x1;
  _pdate = "";
  title("PIC values for (p,t_hat):\lselect maximum for lag order");
  _ptitlht = 0.25;
  _pnum   = 1;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.18;
  _pnumht = 0.20;
  pick = selif(pic,(pic[.,t+2].>0));
  pick = pick[.,t+2];
  x1   = selif(x1,pic[.,t+2].>0);
  if rows(x1)==rows(x11)-1;
     x1   = 0|(-pic[1,t+2]/(pick[1]-pic[1,t+2]))|x1;
     pick = 0|0|pick;
  endif;
  picu = ones(rows(x1),1)*picu;
  xtics(0,lmax+1,1,2);
  xlabel("AR lag");
  ylabel("PIC value");
  _plegctl = { 2 4.9 1.15 0.20 } ;
  n1 = "PIC values for various p given t_hat";
  _plegstr = n1  $+  "\000PIC value for (phat,that) with a unit root";
   xy(x1,pick~picu);
endp;

proc(0) =  grfbict(l,tmax,bic);
local x2;
  graphset;
  x2=seqa(-1,1,tmax+2);
  _pdate = "";
  title("BIC values for (p_hat,t)");
  _ptitlht = 0.34;
  _pnum = 1;
  _pxpmax = 2;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  xtics(-1,tmax+2,1,2);
  xlabel("Trend degree");
  ylabel("BIC value");
  xy(x2,bic[l+1,.]');
endp;

proc(0) =  grfbicq(p,qmax,bic);
local x2;
  graphset;
  x2=seqa(0,1,qmax+1);
  _pdate = "";
  title("BIC values for (p_hat,q)");
  _ptitlht = 0.34;
  _pnum = 1;
  _pxpmax = 2;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  xtics(0,qmax+1,1,2);
  xlabel("MA lag");
  ylabel("BIC value");
  xy(x2,bic[p+1,.]');
endp;

proc(0) =  grfpict(l,tmax,pic);
local x2;
  graphset;
  x2=seqa(-1,1,tmax+2);
  _pdate = "";
  title("PIC values for (p_hat,t):\lselect maximum for trend degree");
  _ptitlht = 0.31;
  _pnum = 1;
  _pxpmax = 2;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  xtics(-1,tmax+2,1,2);
  xlabel("Trend degree");
  ylabel("PIC value");
  xy(x2,pic[l+1,.]');
endp;

proc(0) =  grfbicpq(pmax,qmax,bic);
local x1,x2,zmin,zscale,kk,zmax,kc,kz;
  zscale = 0.5;
  kc     = -1;
  graphset;
  x1=seqa(0,1,pmax+1);
  x2=seqa(0,1,qmax+1);
  _pdate = "";
  title("BIC values for (p,q) array");
  _ptitlht = 0.34;
  _pframe = {0,0};
  _pnum = 1;
  _pzpmax = 1;
  _pxpmax = 1;
  _pypmax = 2;
  _paxht  = 0.22;
  _pnumht = 0.20;
  volume(6,6,3);
  zmin =  minc(minc(bic));
  zmax =  maxc(maxc(bic));
  viewxyz(6.1,6.1,zmin);
  xtics(0,pmax+1,1,2);
  ytics(0,qmax+1,1,2);
  ztics(zmin,zmax,(zmax-zmin)/3,2);
  xlabel("AR lag");
  ylabel("MA lag");
  zlabel("BIC value");
  surface(x1',x2,bic');
  kk = 0;
  do until kk == 2;
  if kk == 0;
     goto hhx;
  elseif kk == 1;  @ keyboard entry = "1" @
     zscale = 0.50 + zscale;
     viewxyz(6.1,6.1,zscale*zmax);
     zlabel("BIC value");
     surface(x1',x2,bic');
"***************************************************************";
"*******    type any key to continue and then:               ***";
"*******    type  5 at ? prompt to rotate viewpoint of graph ***";
"*******    type  2 at ? prompt to move on                   ***" ;
"*******    now type any key to continue                     ***";
"***************************************************************";
     wait;
     kz = con(1,1);
     if kz == 5;
     viewxyz(-6.1,6.1,zscale*zmax);
     surface(x1',x2,bic');
     endif;
  elseif kk == -1;  @ keyboard entry = "-1" @
     zscale = -0.50 + zscale;
     viewxyz(6.1,6.1,zscale*zmax);
     zlabel("BIC value");
     surface(x1',x2,bic');
  endif;
  hhx:
"***************************************************************";
"*******    type any key to continue and then:               ***";
"*******    type  1 at ? prompt to raise viewpoint of graph  ***";
"*******    type -1 at ? prompt to go back to last graph     ***";
"*******    type  2 at ? prompt to move on                   ***" ;
"*******    now type any key to continue                     ***";
"***************************************************************";
  wait;
  kk = con(1,1);
  endo;
endp;

proc (3) = pparord(x,p,ptmax,l,lmax) ;
     local b,k,z,res,so,var_cov,xx,
           m,xmat,nobs,dep,ch,
           blr,blrodds,hr,vv,ll,aic,bic,pic,
           timep,t,cn,pick,picm,nreg,el,
           nr,zzinv,zqz,b2,nx,rfso,pic4,zz11,
           qv,qf,detall,det1,det2,det3,det4,det5,det6,
           tfso,t1so,kfso,k2so,kx,pred,predm,
           nt,nk,nk2,nbx,bhat,za,zz,ss,btilde,
           bb,nex,bx,b1,a1,a2,a3,a4,a5,a6,a7;
     if (p < -1);
         "Error: p cannot be < -1";
         retp(0,0,0);
     endif ;
     nobs    = rows(x);
     if (nobs - (2*lmax) + 1 < 1) ;
        "Error: l is too large; negative degrees of freedom.";
        retp(0,0,0);
     endif ;
     { a1,za,ss,a2,a3,bhat,a6,a7 } = ppadfbit(x,ptmax,lmax);
     zz        = za'za;
     cn        = ones(nobs,1) ;
     if p > 0 ;
       timep    = zeros(nobs,p) ;
       t        = seqa(1,1,nobs) ;
       m        = 1 ;
       do while m <= p ;
          timep[.,m] = t^m ;
          m = m + 1 ;
       endo ;
       xmat     = cn~timep ;
     else ;
       xmat = cn ;
     endif ;
     dep     = trimr(x,1,0);
     xmat    = trimr(xmat,1,0) ;
     ch      = trimr(x,1,0)-trimr(lagn(x,1),1,0) ;
     z       = trimr(lagn(x,1),1,0) ;
     if l > 1;
        k=2 ;
        do until k > l ;
           kx=k-1;
       z = z~lagn(ch,kx) ;
           k = k + 1 ;
        endo ;
        if p >= 0;
           z       = z~xmat ;
        endif;
        z       = trimr(z,k-2,0) ;
        dep     = trimr(dep,k-2,0) ;
     elseif l==1;
          if p >= 0;
             z       = z~xmat ;
          endif;
     else;
          if p == -1;
             goto hhh;
          else;
             z  = xmat;
          endif;
     endif;
     b       = dep/z ;
     res     = dep - z*b ;
     nreg    = cols(z);
     so      = (res'res)/(rows(dep)-nreg);
     zz11    = z'z;
     { nex,btilde } = picsplit(bhat,zz,ptmax,lmax,b,p,l);
     pic     = llnpic(bhat,ss,zz,btilde,zz11,nex);
     aic     = ln(so) + 2*nreg/rows(dep);
     bic     = ln(so) + nreg*ln(rows(dep))/rows(dep);
     goto hhx;
     hhh:
     res    = dep;
     so     = res'res/(rows(dep));
     bic    = ln(so);
     aic    = bic;
     b      = 0;
     zz11   = 0;
     { nex,btilde } = picsplit(bhat,zz,ptmax,lmax,b,p,l);
     pic     = llnpic(bhat,ss,zz,btilde,zz11,nex);
     hhx:
retp(aic,bic,pic);
endp ;

proc(3) = arord(x,pmax,tmax);
local zha,zhb,zhp,jp,jq,bic,
   aic,pic;
   if pmax == 0 and tmax == -1;
     " Error: either pmax > 0 or tmax > -1 ";
     retp(0,0,0);
   endif;
   zha = zeros(pmax+1,tmax+2);
   zhb = zeros(pmax+1,tmax+2);
   zhp = zeros(pmax+1,tmax+2);
   jp = 1;
   do until jp>pmax+1;
      jq = 1;
      do until jq>tmax+2;
        { aic,bic,pic } = pparord(x,jq-2,tmax,jp-1,pmax);
        zha[jp,jq] = aic;
        zhb[jp,jq] = bic;
        zhp[jp,jq] = pic;
        jq = jq+1;
       endo;
   jp = jp+1;
   endo;
retp(zha,zhb,zhp);
endp;

proc(2) = picsplit(bhat,zz,ptmax,pmax,bx,pt,p);
local el,nreg,nex,nbx,b1,bb,btilde,b;
     el     =  bhat;
     nreg   =  pt+1+p;
     nex    =  rows(el)-nreg;
     nbx    =  rows(bx);
     if pt == -1 and p == 0;
        goto hzz;
     endif;
     if ptmax > pt;
            if pt > -1;
               b1 = bx[nbx-pt:nbx]|zeros(ptmax-pt,1);
            else;
               b1 = zeros(ptmax-pt,1);
            endif;
     else;
            if pt > -1;
               b1 = bx[nbx-pt:nbx];
            endif;
     endif;
     if ptmax == pt and pt == -1;
            if nex > 0;
               bb  =  bx'~zeros(nex,1)';
               b   =  bb';
            else;
               b   = bx;
            endif;
     elseif ptmax ne pt and pt == -1;
            bb  =  bx'~zeros(nex,1)';
            b   =  bb';
     else;
            if pmax > p;
               if pt > -1;
                  if p > 0;
                     b   = bx[1:nbx-(pt+1)]|zeros(pmax-p,1)|b1;
                  elseif p == 0;
                     b   = zeros(pmax,1)|b1;
                  endif;
               else;
                  if p > 0;
                     b   = bx[1:nbx]|zeros(pmax-p,1)|b1;
                  elseif p == 0;
                     b   = zeros(pmax,1)|b1;
                  endif;
               endif;
            else;
                if p > 0;
                   if pt > -1;
                      b   = bx[1:nbx-(pt+1)]|b1;
                    else;
                      b   = bx[1:nbx]|b1;
                   endif;
                elseif p == 0;
                   if pt > -1;
                      b   = b1;
                   endif;
                endif;
            endif;
     endif;
     btilde = b;
     goto hzza;
     hzz:
     btilde = zeros(rows(bhat),1);
     hzza:
retp(nex,btilde);
endp;

proc  llnpic(bhat,ss,zz,btilde,zz11,nex);
local qf,detall,det11,det3,pic,b;
     b      = bhat - btilde;
     qf     = b'zz*b;
     detall = det(zz);
     if zz11 == 0;
        det11 = 1;
     else;
        det11  = det(zz11);
     endif;
     det3   = (detall/det11)/ss^nex;
     pic    = qf/ss - ln(det3);
retp(-pic);
endp ;
