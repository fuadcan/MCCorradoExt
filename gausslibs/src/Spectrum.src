/*         SPECTRUM.SRC             RAINER SCHLITTGEN  & THOMAS NOACK; 5.1.1998
**
**
**      Programs for time series analysis
**
**   Procedure                                                          Line
**   ________________________________________________________________________
**   ACOVFPER     :  autocovariance function from periodogram
**   FOURIER      :  fouriercoefficients of a  time series               31
**   FOURINV      :  recovering a time seriessfrom the fourier inverse
**   PERIODO1     :  periodogram at choosen frequencies                  47
**   PERIODO2     :  periodogram at equally spaced frequencies           65
**   PERIODO3     :  periodogram at choosen frequencies via acov         86
**   PERIODO4     :  periodogram at equally spaced frequencies via acov 102
**   LAGWINPA     :  Parzen's lag window                                141
**   LAGWINBA     :  Bartlett's lag window                              154
**   LAGWINTU     :  Tukey's lag window                                 165
**   PERWINPA     :  Parzen's periodogram window                        176
**   PERWINBA     :  Bartlett's periodogram window                      199
**   PERWINTU     :  Tukey's periodogram window                         221
**   PERWINTP     :  truncated periodogram window                       245
**   SPECESTD     :  direct spectrum estimation                         273
**   SPECESTI     :  indirect spectrum estimation                       297
**   SPECARMA     :  spectral density of an arma process                318
**   WNTEST       : Bartlett's Kolmogorov test for white noise          331
**
**
*/


/*
**  {per} = acovfper(per,m) determines the periodogram using the acf
**     Input :  per = (n,1) vector, the periodogram at frequencies 
**                          0 <= k/(2*n-1) < 1/2
**                m = scalar, maximum lag
**     Output : acf = (k,1) vector, acf at lags 0,1,...,m
**
*/


PROC (1) = acovfper(per,m);       
                                   
  LOCAL acf,n,n2;                    
  n = ROWS(per);                   
  n2 = 2*n-1;                            
  acf =  (2/n2)*COS(2*PI*SEQA(0,1,m+1)*SEQA(1/n2,1/n2,n2/2)')*TRIMR(per,1,0);
  acf = per[1]/n2 + acf;
  RETP(acf);
ENDP;

/*
**  {fc}  = fourier(y);
**        input : y = (n,1) vector, the time series
**        output: fc = ((n+2)/2,2) matrix, the fouriercoefficients
**                     at  frequencies k/n,  0 <= k/n <= 1/2
**
*/

PROC (1) = fourier(y);
  LOCAL fc,ind,n,u;
  n = ROWS(y);
  ind = 2*PI*SEQA(0,1/n,1+n/2)*SEQA(1,1,n)';
  fc = ((COS(ind)*y)~(SIN(ind)*y))/n;
 RETP(fc);
ENDP;


/*
**   {x} = fourinv(fcoef,n); reconstructing time series x of length n from
**                           fourier-coefficients fcoef at freq k/n
**
*/


PROC (1) = fourinv(fcoef,n);

  LOCAL x,ind;
  ind=2*PI*SEQA(0,1,n)*SEQA(1/n,1/n,(n-1)/2)';
  x = fcoef[1,1] + 2*COS(ind)*fcoef[2:1+(n-1)/2,1];
  x = x + 2*SIN(ind)*fcoef[2:1+(n-1)/2,2];
  IF 1-n%2;
     x = x + ((-1)^SEQA(0,1,n))*fcoef[1+n/2,1];
  ENDIF;
 RETP( x[2:n 1] );
ENDP;


/*
**  {per} = periodo1(y,freq,c) determines the periodogram of the ts y
**                           at given frequencies   
**     Input :    y = (n,1) vector, the time series
**             freq = (k,1) vector, the frequencies
**                c = scalar; if c=1, with mean correction,
**                    else no mean correction
**     Output : per = (k,1) vector, the periodogram
**
*/

PROC (1) = periodo1(y,freq,c);
   LOCAL per,n ;
   n = ROWS(y); 
   y = MISSRV(y,tsmean(y));
   IF c==1;
    y = y - tsmean(y);
   ENDIF;
   per = EXP(COMPLEX(0,1)*2*PI*freq*SEQA(1,1,n)')*y;
 RETP( (ABS(per)^2)/n);
ENDP;


/*
**  {per,f} = periodo2(y,nf) direct determines the periodogram of the
**                           ts y at frequencies 0/(2*nf-1), 1/(2*nf-1),...,nf/(2*nf-1)
**     Input :     y = (n,1) vector, the time series
**             nfreq = scalar, the number of equally spaced frequencies
**     Output :    f = (nf,1) vector, the frequencies  
**               per = (nf,1) vector, the periodogram
*/

PROC (2) = periodo2(y,nf);
   LOCAL f,n,per;
   IF ROWS(y) == 1; y = y'; ENDIF;
   n = ROWS(y); 
   y = y - tsmean(y);
   y = MISSRV(y,0);
   f = SEQA(0,1,nf)/(2*nf-1);
   per = EXP(COMPLEX(0,1)*2*PI*f*SEQA(1,1,n)')*y;
 RETP((ABS(per)^2)/n,f);
ENDP;


/*
**  {per} = periodo3(acf,freq) determines the periodogram at  
**                             given frequencies using the acf
**     Input :  acf = (n,1) vector, acf at lags 0,1,...,n-1
**             freq = (k,1) vector, the frequencies
**     Output : per = (k,1) vector, the periodogram
**
*/

PROC (1) = periodo3(acf,freq);
    LOCAL n, mat;
    n = ROWS(acf);
    mat = ONES(ROWS(freq),1)~(2*COS(2*PI*freq*SEQA(1,1,n-1)'));
    RETP(mat*acf);
ENDP;


/*
**  {per,f} = periodo4(acf,nf) determines the periodogram using the acf
**     Input :   acf = (n,1) vector, acf at lags 0,1,...,n-1
**                nf = scalar, the number of equally spaced frequencies
**     Output :  per = (nf+1,1) vector, the periodogram at frequencies f
**                 f = (nf+1,1) vector, the frequencies 0,1/(2*nf),..nf/(2*nf)
*/


PROC (2) = periodo4(acf,nf);
    LOCAL freq,mat,n;
    IF ROWS(acf) == 1; acf = acf'; ENDIF;
    n = ROWS(acf);
    freq = SEQA(0,1,nf+1)/(2*nf);
    mat = ONES(nf+1,1)~(2*COS(2*PI*freq*SEQA(1,1,n-1)'));
  RETP(mat*acf,freq);
ENDP;



/*
**  Parzen's Lag-window for indirect spectrum-estimation
**  Input T = number of lags used for estimation
*/

PROC (1) = LAGWINPA(T);
  LOCAL k;
  T=T+1;
  k = SEQA(1,1,T);
  k = 1|(1-6*(k[1:T/2]/T)^2 + 6*(k[1:T/2]/T)^3)|(2*(1-k[(1+T/2):T-1]/T)^3);
  RETP(k);
ENDP;

/*
**  Bartlett's Lag-window for indirect spectrum-estimation
**  Input T = number of lags used for estimation
*/

PROC (1) = LAGWINBA(T);
  LOCAL k;
  T=T+1;
  RETP(1-SEQA(0,1,T)/T);
ENDP;

/*
**  Tukey's Lag-window for indirect spectrum-estimation
**  Input T = number of lags used for estimation
*/

PROC (1) = LAGWINTU(T);
  LOCAL k;
  RETP(0.54 + 0.46*COS(PI*SEQA(0,1,T+1)/(T+1)));
ENDP;


/*
**  {w} = PERWINPA(e,n) Parzen's window for direct spectral estimation
**      Input :  n = length of time series
**               e : equal bandwidth  (at most n frequencies are
**                   used for averaging)
**      Output : w = weights (symmetric)
*/

PROC (1) = PERWINPA(e,n);
  LOCAL q,w;
  if e >= 0.5 or e < 0; print "e must be 0<=e<0.5"; stop; ENDIF;
  q = 1;
  w = 1;
  DO WHILE (1/(n*SUMC(w^2)) < e) and (q < n/2);
    q = q+1;
    w = SEQA(1,1,q)/q;
    w = (1-6*(w[1:q/2])^2 + 6*(w[1:q/2])^3)|(2*(1-w[(1+q/2):q-1])^3);
    w = REV(w)|1|w;
    w = w/SUMC(w);
  ENDO;
RETP(w);
ENDP;

/*
**  {w} = PERWINBA(e,n) Bartlett's window for direct spectral estimation
**      Input :  n = length of time series
**               e : equal bandwidth  (at most n frequencies are
**                   used for averaging)
**      Output : w = weights (symmetric)
*/

PROC (1) = PERWINBA(e,n);
  LOCAL q,t,w;
  if e >= 0.5 or e < 0; print "e must be 0 <=e <0.5"; stop; ENDIF;
  q = 1;
  w = 1;
  DO WHILE (1/(n*SUMC(w^2)) < e) and (q < n/2);
    q = q+1;
    w = 1-SEQA(1,1,q)/q;
    w = REV(w)|1|w;
    w = w/SUMC(w);
  ENDO;
RETP(w);
ENDP;

/*
**  {w} = PERWINTU(e,n)  Tukey's window as periodogram window
**                       for direct spectrum-estimation
**  Input :  n = length of time series
**           e : equal bandwidth  (at most n frequencies are
**               used for averaging)
**  Output : w = weights (symmetric)
*/

PROC (1) = PERWINTU(e,n);
  LOCAL q,w;
  IF e >= 0.5 OR e < 0; PRINT "e must be 0<=e<0.5"; STOP; ENDIF;
  q = 1;
  w = 1;
  DO WHILE (1/(n*SUMC(w^2)) < e) and (q < n/2);
    q = q+1;
    w = 0.54 + 0.46*COS(PI*SEQA(0,1,q+1)/(q+1));
    w = w[q+1:2]|w;
    w = w/SUMC(w);
  ENDO;
RETP(w);
ENDP;


/*
**  {w} = PERWINTP(e,n) truncated periodogam-window for direct
**                      spectral estimation
**      Input :  n = length of time series
**               e : equal bandwidth  (at most n frequencies are
**                   used for averaging)
**      Output : w = weights (symmetric)
*/

PROC (1) = PERWINTP(e,n);
  LOCAL q,t,w;
  if e >= 0.5 or e < 0; print "e must be 0 <=e <0.5"; stop; ENDIF;
    q = n*e;
    w = ONES(MAXC(q|1),1);
RETP(w/SUMC(w));
ENDP;


/*
**  {s,f} = SPECESTD(y,e,&win,alpha); direct spectral estimation of series y
**                              using periodogram window win
**       input : y = (n,1) vector, the ts
**               e  : equal bandwidth
**               win = periodogramwindow
**                     (possible: perwinba, perwinpa, perwinda)
**               conf = scalar, the level for confidence intervals 
**       output : s = (m+1,3)-matrix, the estimated spectrum at 
**                     fourierfrequencies 0,1/n,.., m/n and the
**                    confidence bounds
**                f =  frequencies 0, 1/n, 2/n, ..., m/n
*/


PROC (2) = SPECESTD(y,e,&win,conf);

  LOCAL f,m,n,p,w,nu,uo,win:PROC;
  n = ROWS(y);
  w = win(e,n);
  m = (ROWS(w)-1)/2;
  {p,f} = periodo2(y,n);
  p = p[m:1]|p[1]|p|REV(take(p,-(m+1)));
  p = CONV(p,w,2*m+1,2*m+1+ROWS(f));
  IF (conf > 0) AND (conf < 1);
   nu = 2/(w'*w);
   uo = p.*nu./CDFCHII((conf+(1-conf)/2)~((1-conf)/2),nu);
   p = p~uo;
  ENDIF;
 RETP(p,(0|f));
ENDP;

/*
**> SPECESTI
**
**  Purpose: indirect spectral estimation of series y using lagwindow win
**  
**  Format: {s,f} = SPECESTI(y,q,&win); 
**                              
**  Input : y = (n,1) vector, the ts
**               q  : number of covariances used for averaging
**               win = lawindow  (possible: lagwinba , lagwinpa, lagwinptu)
**  Output : s = estimated spectrum at fourierfrequencies 0,1/n,..
**           f = frequencies 0, 1/n, 2/n, ...
*/


PROC (2) = SPECESTI(y,q,&win);

  LOCAL a,f,s,win:PROC;
  a = acove(y,q).*win(q);
  {s,f} = PERIODO4(a,ROWS(y));
 RETP(s,f);
ENDP;

/*
**> SPECESTAR
**
**  Purpose: autoregessive spectral estimation with simultaneous confidence bands
**
**  Format :{fdach,bound,freq}=specestar(y,p,nf,conf)
**  
**  Input: y = (n,1) vector the time series
**         p = scalar, order of ar-model used for the estimation   
**         nf = scalar, number of eqally spaced frequencies where the 
**              spectrum is estimated   
**         conf= scalar, the confidence level for the bounds 
**  Output: fdach (nf+1,1) vector, theestimated spectrum
**          bound (nf+1,2) matrix, lower bound in the first column,
**                                 upper bound in the second column
**          freq (nf+1,1) vector, the frequencies
**  References : Newton, H.J. and Pagano, M. (1984): Simultaneous confidence 
**                bands for autoregressive spectra; Biometrika, 71, 197-202
**               Newton, H.J. (1988): Timeslab, a time series laboratory;
**                Belmont, CA. : Wadsworth & Brooks/Cole
*/

PROC (3) = specestar(y,p,nf,conf);

 LOCAL n,alpha,res,freq,fdach,sigma2,gam,u,v,sa,c,b,b1,b2,d,ind,s2,j,bound,h;
 y = y-tsmean(y);
 n = ROWS(y); 
 alpha = arest(y,p,"yw");
 res = armaresid(y,alpha,0); 
 sigma2 = res'*res/(n-p); 
 freq = SEQA(0,1,nf+1)/(2*nf);
 gam = (1/sigma2)*UPMAT(TOEPLITZ(1|-alpha))*(1|-alpha);
 u = LOWMAT(TOEPLITZ(1|-alpha[1:p-1]));
 v = LOWMAT(TOEPLITZ(-alpha[p:1]));
 sa = u*u'-v*v';
 c = ZEROS(p+1,p+1);
 c[1:p,1:p]= sa;
 c[p+1,p+1] = 2/sigma2^2;
 b1 = SHIFTR(RESHAPE(-alpha,p+1,p),seqa(0,-1,p+1),0);
 b2 = SHIFTR(RESHAPE(1|-alpha[1:p-1],p,p),seqa(0,1,p),0);
 b2 = (-alpha')|b2;
 b = (b1+b2)/sigma2;
 b = b~(gam*sigma2);
 d = b*c*b';
 ind = 2*PI*SEQA(1,1,p);
 s2 = MISS(ZEROS(ROWS(freq),1),0);
 h = ZEROS(ROWS(freq),1);
 j=0;
 DO WHILE j<ROWS(freq); 
   j=j+1;   
   h[j] =  (1~(2*COS(freq[j]*ind')))*gam;
   s2[j] = (1~(2*COS(freq[j]*ind')))*d*(1|(2*COS(freq[j]*ind)));
 ENDO;
 fdach = h^-1;
 IF conf > 0;
  s2 = SQRT(CDFCHII(conf,p+1)*s2/n);
  bound = (h+s2)~(h-s2);
  bound = bound.*(bound.>0);
  bound = MISS(bound,0)^-1;  
 ENDIF;
RETP(fdach,bound,freq);
ENDP; 



/*
**> SPECARMA
**
**  Purpose: compute the theoretical spectral density for an arma model     
**  Format : {sp,fr} = SPECARMA(a,b,s,n); 
**  Input  : a = (p,1)-vector, ar-coefficients
**           b = (p,1)-vector, ma-coefficients
**           s = scalar, variance of error process
**           n = scalar >= 0, number of frequency points
**  Output:  sp = (n+1,1)-vector, the spectral density ordinates             
**           fr = (n+1,1)-vector, the frequencies
*/

PROC (2) = SPECARMA(a,b,s,n);
  LOCAL c,p,q,u;
  p=ROWS(a);
  q=ROWS(b);
  u= (2*PI*SEQA(0,1/(2*n),1+n)).*.SEQA(1,1,MAXC(p|q))' ;
  c= (1-COS(u[.,1:q])*b)^2 + (SIN(u[.,1:q])*b)^2;
  c = s*c./( (1-COS(u[.,1:p])*a)^2 + (SIN(u[.,1:p])*a)^2 );
RETP(c,(u[.,1]/(2*PI)));
ENDP;


/*
**> WNTEST
**
**  Purpose: graphical test for white noise for a time series
**           or a series of regression residuals 
**  Format: wntest(e,alpha,k); 
**  Input  : e     = (n*1) vector, the time series or residuals
**           alpha = scalar, level of significance
**           k     = scalar >= 0, number of regressors
**                   if k = 0, e is interpreted as time series without reg.
*/

PROC (0) = wntest(e,a,k);
    LOCAL c,cc,c0,i,k1,k2,k12,k11,k22,k21,m,mm,n,nen,p,s,t,x;

    IF a<0 OR a>1; 
      PRINT "Error probability must be inside (0,1)"; STOP; 
    ENDIF; 
    n=ROWS(e);   m=TRUNC(n/2);    s=ZEROS(m,1);
    c = acove(e,n-1);
    c0 = c[1]; c = c[2:n];
    s[1] = c0 + 2*SUMC(c.*COS(2*PI*SEQA(1,1,n-1)/n));
    i = 1;
    DO WHILE i < m;
       i = i+1;
       s[i] = s[i-1] + c0 + 2*SUMC(c.*COS(2*PI*i*SEQA(1,1,n-1)/n));
    ENDO;
    s = 0|s/s[m];
    if k == 0;
       nen = SQRT(m-1) + 0.2 + 0.68/SQRT(m-1);
       c=SQRT(-ln(a/2)/2)/nen - 0.4/(m-1);
       x=SEQA(0,1/m,m+1);
       t=MAXC(ABS(s-x));
       p=MINC(1|(2*EXP(-2*(t+0.4/(m-1))*(t+0.4/(m-1))*nen*nen)));
       k1=x-c; k1=MISS(k1.*(k1.>=0),0);
       k2=x+c; k2=MISS(k2.*(k2.<=1),0);
   
        p = FTOS(p,"%*.*lf",10,8);
        t = FTOS(t,"%*.*lf",10,8);
        _pdate="";
        _pltype={6,6,1,1};
        _plwidth=4;
        _pmcolor = zeros(8,1)|15;
        _pcolor={0,1,4,4};
        SCALE(0|1,0|1);
        _pnumht=.19;
        _paxht=.2;
        _ptitlht=.2;
        TITLE("Bartletts Kolmogorov Test for White Noise" );
        XLABEL("test statistic: " $+ t $+ ",  p-value : " $+ p);
       XY(x,s~x~k1~k2);
       
    ELSEIF k > 0;
       c=SQRT(-ln(a/2)/2)/(SQRT(m-1) + 0.2 + 0.68/SQRT(m-1)) - 0.4/(m-1);
       x=SEQA(0,1/m,m+1);
       t=MAXC(ABS(s-x));
       mm=(n-k)/2;
       cc=c-(k-1)/(2*mm);
       k11=SEQA(0,1/mm,m+1) + cc; k12=k11 + (c-cc);
       k21=SEQA(0,mm/m^2,m+1) - cc*mm/m;  k22=k21 - (c-cc)*mm/m;
       k11=MISS(k11.*(k11.<=1),0);
       k12=MISS(k12.*(k12.<=1),0);
       k21=MISS(k21.*(k21.>=0),0);
       k22=MISS(k22.*(k22.>=0),0);

        
       t = FTOS(t,"%*.*lf",10,8);
       _pdate = "";
       _pltype = {6,6,1,1,1,1};
       _plwidth=4;
       _pmcolor = zeros(8,1)|15;
        _pcolor={0,1,1,1,1,1};
        SCALE(0|1,0|1);
        _pnumht=.19;
        _paxht=.2;
        _ptitlht=.2;
        title("Bartletts Kolmogorov Test for White Noise
               \L with "$+FTOS(k,"%*.*lf",3,1)$+" regressors");
        xlabel("test statistic: " $+ t);

       xy(x,s~x~k11~k12~k21~k22);
       GRAPHSET;
    ENDIF;
ENDP;





