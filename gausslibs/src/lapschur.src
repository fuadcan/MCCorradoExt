/*
** lapack.src - LAPACK procedures
**
** (C) Copyright 2002  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
*/




/*
** >proc lapgschur
**
**  Purpose:  compute the generalized Schur form of a pair of
**              real or complex general matrices
**
**  Format:   { sa, sb, q, z } = lapgschur(A,B);
**
**  Input:    A     NxN matrix, real or complex general matrix
**
**            B     NxN matrix, real or complex general matrix
**
**  Output:  sa     NxN matrix, Schur form of A
**
**           sb     NxN matrix, Schur form of B
**
**            q     NxN matrix, left Schur vectors
**
**            z     NxN matrix, right Schur vectors
**
**  Remarks:  The pair of matrices A and B are in generalized real
**            Schur form when B is upper triangular with non-negative
**            diagonal, and A is block upper triangular with 1x1 and
**            2x2 blocks.  The 1x1 blocks correspond to real generalized
**            eigenvalues and the 2x2 blocks to pairs of complex conjugate
**            eigenvalues.  The real generalized eigenvalues can be
**            computed by dividing the diagonal element of sa by the
**            corresponding diagonal element of sb.  The complex
**            generalized eigenvalues are computed by first constructing
**            two complex conjugate numbers from 2x2 block where the
**            real parts are on the diagonal of the block and the
**            imaginary part on the off-diagonal.  The eigenvalues are
**            then computed by dividing the two complex conjugate values
**            by their corresponding diagonal elements of sb.
**
**            The generalized Schur vectors q and z are orthogonal
**            matrices that reduce A and B to Schur form:
**
**                   sa = q' * A * z
**                   sb = q' * B * z
**
**            This procedure calls the LAPACK routines DGEGS and ZGEGS.
*/



proc(4)=lapgschur(a,b);

     local n,s,ind,e1,e2,q,z,e,info;
     n = cols(a);
     if rows(a) /= n;
         if not trapchk(4);
             errorlog "lapgschur: first matrix not square";
             end;
         else;
             retp(error(0),error(0),error(0),error(0));
         endif;
     endif;
     if rows(b) /= cols(b);
         if not trapchk(4);
             errorlog "lapgschur: second matrix not square";
             end;
         else;
             retp(error(0),error(0),error(0),error(0));
         endif;
     endif;
     if rows(b) /= n;
         if not trapchk(4);
             errorlog "lapgschur: arguments not conformable";
             end;
         else;
             retp(error(0),error(0),error(0),error(0));
         endif;
     endif;

     ind = 1;
     info = 0;
     if not iscplx(a) and not iscplx(b);

         s = zeros(n,1);
         e1 = zeros(n,1);
         e2 = zeros(n,1);
         z = zeros(n,n);
         q = zeros(n,n);
         dllcall _dgegs(n,a,b,e1,e2,s,q,z,info,ind);
         e = complex(e1,e2);

     else;

         e = complex(zeros(n,1),zeros(n,1));
         s = complex(zeros(n,1),zeros(n,1));
         q = complex(zeros(n,n),zeros(n,n));
         z = complex(zeros(n,n),zeros(n,n));
         if not iscplx(a);
             a = complex(a,zeros(n,n));
         endif;
         if not iscplx(b);
             b = complex(b,zeros(n,n));
         endif;
         dllcall _zgegs(n,a,b,e,s,q,z,info,ind);

     endif;

     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapgschur:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapgschur:  failure to converge";
                 end;
             endif;
         else;
             retp(error(abs(info)),error(0),error(0),error(0));
         endif;
     endif;

     retp(a,b,q,z);
endp;








