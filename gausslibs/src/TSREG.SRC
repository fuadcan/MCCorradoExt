/*
** tsreg.src - Time Series Modelling.
** (C) Copyright 1996 by Global Design/Thierry Roncalli.
** All Rights Reserved.
**
**  Format                        Purpose                                 Line
** ============================================================================
**  {beta,stderr,u,RSS}
**             = RLS(y,x);        Recursive Least Squares                  26
**
**  {beta,u,r2M,r2D}
**             = FLS(y,x,mu);     Flexible Least Squares                   45
**
**  {a,u,as,us} = GFLS(y,&H,&m,&MM,&F,&d,&DD,Q0,p0,mu);
**                                Generalized Flexible Least Squares
**                                of Kalaba and Tesfatsion [1996]          66
**
**  {beta,u,SSE} =
**    GFLS2(y,x,mu,s,B,C,D,F);    Generalized Flexible Least Squares
**                                of Lutkepohl and Herwartz [1996]         99
**
*/


/*
** RLS
**
** Purpose: Recursive Least Squares
**
** Format:  {beta,stderr,u,RSS} = RLS(y,x);
**
** Input:   y - Nobs*1 vector, endogenous data
**          x - Nobs*K matrix, exogenous data
**
** Output: beta - Nobs*K matrix, recursive least squares coefficients
**       stderr - Nobs*K matrix, standard errors
**    residuals - Nobs*1 vector, u[.,1] -> LS residuals u(n)
**                            u[.,2] -> innovations v(n)
**                            u[.,3] -> standardized innovations w(n)
**          RSS - Nobs*1 vector, residuals sum of squared RSS(t)
*/


/*
** FLS
**
** Purpose: Flexible Least Squares
**
** Format:  {beta,u,r2M,r2D} = FLS(y,x,mu);
**
** Input:   y - Nobs*1 vector, endogenous data
**          x - Nobs*K matrix, exogenous data
**         mu - scalar, mu-weight parameter
**
** Output: beta - Nobs*K matrix, flexible least squares coefficients
**            u - Nobs*1 vector, residuals
**          r2M - Sum of squared residual measurement errors
**          r2D - Sum of squared residual dynamic errors
**
** Globals: _print - scalar 1 (default), print the statistics
**                   scalar 0, do not print the statistics
*/


/*
** GFLS
**
** Purpose: Generalized Flexible Least Squares of Kalaba and Tesfatsion [1990]
**
** Format:  {a,u,as,us} = GFLS(y,&H,&m,&MM,&F,&d,&DD,Q0,p0,mu);
**
** Input:   y - Nobs*m vector, data
**         &H - pointer to a procedure which returns the H(t) matrix
**         &m - pointer to a procedure which returns the m(t) matrix
**        &MM - pointer to a procedure which returns the M(t) matrix
**         &F - pointer to a procedure which returns the F(t) matrix
**         &d - pointer to a procedure which returns the d(t) matrix
**        &DD - pointer to a procedure which returns the D(t) matrix
**         Q0 - n*n matrix, the initial Q0 matrix
**         p0 - n*1 vector, the initial p0 vector
**         mu - scalar, mu parameter
**
** Output:  a - Nobs*n matrix, the filtered estimates
**          u - Nobs*m matrix, the filtered residuals
**         as - Nobs*n matrix, the smoothed estimates
**         us - Nobs*m matrix, the smoothed residuals
**
**
** Globals: _print - scalar 1 (default), print the statistics
**                   scalar 0, do not print the statistics
**           _cost - 2*1 vector, the cost values
**                   _cost[1] -> measurement cost C2M
**                   _cost[2] -> dynamic cost C2D
**
*/


/*
** GFLS2
**
** Purpose: Generalized Flexible Least Squares of Lutkepohl and Herwartz [1996]
**
** Format:  {beta,u,SSE} = GFLS2(y,x,mu,s,B,C,D,F);
**
** Input:   y - Nobs*1 vector, endogenous data
**          x - Nobs*K matrix, exogenous data
**         mu - 2*1 vector, mu-weight parameters
**          s - scalar, the seasonal period
**          B - K*K matrix, the B matrix
**          C - K*K matrix, the C matrix
**          D - K*K matrix, the D matrix
**          F - K*K matrix, the F matrix
**
** Output: beta - Nobs*K matrix, generalized flexible least squares coefficients
**            u - Nobs*1 vector, residuals
**          SSE - Sum of squared errors
**
** Globals: _print - scalar 1 (default), print the statistics
**                   scalar 0, do not print the statistics
*/


/*
** _LS_comp
*/

proc (1) = _LS_comp(y,x);

  if (cols(y) /= 1) or (rows(x) /= rows(y));

    ERRORLOG "error: Wrong size format of the X and Y matrices.";
    call pause(2);
    retp(1);

  elseif (cols(x) >= rows(y));

    ERRORLOG "error: Not enough observations.";
    call pause(2);
    retp(1);

  else;

    retp(0);

  endif;

endp;


/*
** RLS: Recursive Least Squares
*/

proc (4) =  RLS(y,x);
  local err,K,Nobs,data,retcode,y_,x_,N;
  local beta,stderr,residuals,RSS,tt,st,rc;

  tt = hsec;

  err = _LS_comp(y,x);

  if err == 1;
    retp(error(0),error(0),error(0),error(0));
  endif;


  K = cols(x); Nobs = rows(y);
  data = y~x;
  {data,retcode} = MISSING(data,0);
  y_ = data[.,1]; x_ = data[.,2:K+1]; N = rows(y_);
  {beta,stderr,residuals,RSS} = _RLS(y_,x_);

  if beta == error(0);
    retp(error(0),error(0),error(0),error(0));
  endif;

  {beta,rc} = MISSING(beta,retcode);
  {stderr,rc} = MISSING(stderr,retcode);
  {residuals,rc} = MISSING(residuals,retcode);
  {RSS,rc} = MISSING(RSS,retcode);

  tt = (hsec-tt)/100;

  if _print == 1;

    print;
    print "----------------------------------------------------------------";
    print "                Recursive Least Squares (RLS)                   ";
    print "----------------------------------------------------------------";
    print;
    st = "Total observations:                              %*.*lf  ";
    print ftos(Nobs,st,15,0);
    st = "Usable observations:                             %*.*lf  ";
    print ftos(N,st,15,0);
    st = "Number of regressors:                            %*.*lf  ";
    print ftos(K,st,15,0);
    print;
    st = "Computation time: %lf seconds";
    print ftos(tt,st,10,4);

  endif;

  retp(beta,stderr,residuals,RSS);
endp;


proc (4) =  _RLS(y,x);
  local N,K,ddl,xn,XX,XXinv,Xy,bn,RSSn,nn;
  local dn,vn,wn,un,Lambda,STDn;
  local beta,stderr,RSS,residuals,sigma,sum1,sum2,oldtrap;

  N = rows(y);
  K = cols(x);
  ddl = N-K;

  beta = miss(zeros(N,K),0);
  stderr = miss(zeros(N,K),0);
  RSS = miss(zeros(N,1),0);
  residuals = miss(zeros(N,3),0);

  xn = x[1:K,.]';
  XX = xn*xn';

  oldtrap = trapchk(1);
  trap 1,1;
  XXinv = invpd(XX);
  trap oldtrap,1;
  if scalerr(XXinv);
    ERRORLOG "error: XX is not a positive definite matrix.";
    call pause(2);
    retp(error(0),error(0),error(0),error(0));
  endif;
  Xy = xn*y[1:k];
  bn = XXinv*Xy;
  RSSn = 0;

  beta[K,.] = bn';
  stderr[K,.] = zeros(1,K);
  RSS[K] = RSSn;

  sum1 = 0; sum2 = 0;

  nn = K+1;
  do until nn>N;

    xn = x[nn,.]';
    Lambda = XXinv*xn;
    dn = sqrt(1+xn'Lambda);
    vn = y[nn] - bn'xn;
    wn = vn/dn;
    bn = bn + XXinv*xn*(wn/dn);
    un = y[nn] - bn'xn;

    XX = XX + xn*xn';
    Xy = Xy + xn*y[nn];
    XXinv = XXinv - (lambda*lambda')/(dn^2);

    RSSn = RSSn + (wn^2);

    sigma = sqrt(RSSn/(nn-K));
    STDn = sigma*sqrt(diag(XXinv));

    beta[nn,.] = bn';
    stderr[nn,.] = STDn';
    RSS[nn] = RSSn;
    residuals[nn,.] = un~vn~wn;

    nn = nn+1;

  endo;

  retp(beta,stderr,residuals,RSS);

endp;


/*
** FLS: Flexible Least Squares
*/

proc (4) = FLS(y,x,mu);
  local err,K,Nobs,data,retcode,rc,y_,x_,N;
  local beta,u,r2M,r2D,tt,st,cn;
  local name,fmt,omat;

  tt = hsec;

  err = _LS_comp(y,x);

  if err == 1;
    retp(error(0),error(0),error(0),error(0));
  endif;

  K = cols(x); Nobs = rows(y);

  if rows(mu) == 1;
    cn = 1;
  else;
    if (rows(mu) == K) and (cols(mu) == 1);
      cn = 0;
    else;
      ERRORLOG "error: Wrong size format of the mu vector.";
      call pause(2);
      retp(error(0),error(0),error(0),error(0));
    endif;
  endif;

  if minc(mu) < 0;
    ERRORLOG "error: The elements of mu must be positive.";
    call pause(2);
    retp(error(0),error(0),error(0),error(0));
  endif;

  data = y~x;
  {data,retcode} = MISSING(data,0);
  y_ = data[.,1]; x_ = data[.,2:K+1]; N = rows(y_);
  {beta,u,r2M,r2D} = _FLS(y_,x_,mu);

  if beta == error(0);
    retp(error(0),error(0),error(0),error(0));
  endif;

  {beta,rc} = MISSING(beta,retcode);
  {u,rc} = MISSING(u,retcode);

  tt = (hsec-tt)/100;
  if _print == 1;

    print;
    print "----------------------------------------------------------------";
    print "                Flexible Least Squares (FLS)                    ";
    print "----------------------------------------------------------------";
    print;

    if cn == 1;

      st = "mu-weight parameter:                             %*.*lf  ";
      print ftos(mu,st,15,4);

    else;

        print "mu-weight parameter:";
        name = 0$+"  P"$+ftocv(seqa(1,1,K),2,0);

        omat = name~mu;
        omat = vecr(omat);
        if K%3 /= 0;
          omat = omat|miss(zeros(6-2*(K%3),1),0);
        endif;

        omat = reshape(omat,rows(omat)/6,6);
        let fmt[6,3] =  " -*.*s" 7 6  "*.*lE   " 12 5
                        " -*.*s" 7 6  "*.*lE   " 12 5
                        " -*.*s" 7 6  "*.*lE   " 12 5;
        call printfm(omat,0~1~0~1~0~1,fmt); print;

    endif;

    print;
    st = "Total observations:                              %*.*lf  ";
    print ftos(Nobs,st,15,0);
    st = "Usable observations:                             %*.*lf  ";
    print ftos(N,st,15,0);
    st = "Number of regressors:                            %*.*lf  ";
    print ftos(K,st,15,0);
    st = "Sum of squared residual measurement errors:      %*.*lf  ";
    print ftos(r2M,st,15,4);
    st = "Sum of squared residual dynamic errors:          %*.*lf  ";
    print ftos(r2D,st,15,4);
    print;
    st = "Computation time: %lf seconds";
    print ftos(tt,st,10,4);

  endif;

  retp(beta,u,r2M,r2D);
endp;


proc (4) = _FLS(y,x,mu);
  local N,K,I,M1,M2,Gy,A,xn,An,M,nn,indx,beta;
  local bn,yhat,u,r2M,r2D,diff,oldtrap;

  N = rows(y);
  K = cols(x);
  I = eye(K);
  M1 = -mu.*I;
  M2 = 2*mu.*I;

  Gy = vec(x').*(y.*.ones(K,1));

  indx = seqa(K-1,-1,K);

  /* Band compact form matrix of A(mu,N) */

  A = zeros(N*K,2*K);

  /* A1(mu) */

  xn = x[1,.];
  An = xn'xn + mu.*I;
  M = zeros(K,K)~An;
  A[1:K,.] = shiftr(M,indx,0);

  /* An(mu) for n = 2,...,N */

  nn = 2;
  do until nn>(N-1);
    xn = x[nn,.];
    An = xn'xn + M2;
    M = M1~An;
    A[1+(nn-1)*K:nn*K,.] = shiftr(M,indx,0);
    nn = nn+1;
  endo;

  /* AN(mu) */

  xn = x[N,.];
  An = xn'xn + mu.*I;
  M = M1~An;
  A[1+(N-1)*K:N*K,.] = shiftr(M,indx,0);

  /* B(FLS) (equation 4.4) */

  oldtrap = trapchk(1);
  trap 1,1;
  beta = bandsolPD(Gy,A);
  trap oldtrap,1;
  if scalerr(beta);

    ERRORLOG "error: A(mu) is not a positive definite matrix.";
    call pause(2);
    retp(error(0),error(0),error(0),error(0));

  endif;

  beta = reshape(beta,N,K);

  /* Residuals */

  bn = beta';

  yhat =  sumc(x'.*bn);
  u = y - yhat;

  /* r2D and r2M */

  r2M = sumc(u^2);

  diff = beta[2:N,.]-beta[1:N-1,.];
  r2D = sumc(sumc(diff^2));

  retp(beta,u,r2M,r2D);
endp;


/*
** GFLS: Generalized Flexible Least Squares of Kalaba and Tesfatsion [1990]
*/

proc (4) = GFLS(y,H,m,MM,F,d,DD,Q0,p0,mu);

  local H:proc,m:proc,MM:proc,F:proc,d:proc,DD:proc;

  local tt,Nobs,m_,n,I;
  local a,u,as,us,s,G;
  local Qt,pt,t,Ht,mt,MMt,Ft,dt,DDt,yt,ut,FDD,Vt,zt,Gt_,st,at,u_t,ast;
  local oldtrap,c2M,c2D,at_1,Ft_1,dt_1,DDt_1;

  tt = hsec;

  {Nobs,m_,n} = _gfls(y,&H,&m,&MM,&F,&d,&DD,Q0,p0,mu);

  I = eye(n);

  a = zeros(Nobs,n);
  u = zeros(Nobs,m_);
  as = zeros(Nobs,n);
  us = zeros(Nobs,m_);

  s = zeros(Nobs,n);
  G = zeros(Nobs,n*(n+1)/2);

  /* c2M and c2D initilisation */

  c2M = 0; c2D = 0;

  /* Q(0) and p(0) initialisation */

  Qt = Q0;
  pt = P0;

  /* GFLS filter */

  t = 1;
  do until t > Nobs;

    Ht = H(t);
    mt = m(t);
    MMt = MM(t);
    Ft = F(t);
    dt = d(t);
    DDt = DD(t);

    yt = y[t,.]';

    /* U(t), equation 28 */

    Ut = Ht'*MMt*Ht + Qt;

    /* V(t), equation 17 */

    FDD = Ft'DDt;
    oldtrap = trapchk(1);
    trap 1,1;
    Vt = invpd(mu*FDD*Ft + Ut);
    trap oldtrap,1;
    if scalerr(Vt);

      ERRORLOG "error: V(t) is not a positive definite matrix.";
      call pause(2);
      retp(error(0),error(0),error(0),error(0));

    endif;

    /* z(t), equation 29 */

    zt = Ht'MMt*(yt-mt) + pt;

    /* G(t), equation 20 */

    Gt_ = mu*Vt*FDD;
    G[t,.] = vech(Gt_)';

    /* Q(t), equation 24 */

    Qt = mu*DDt*(I-Ft*Gt_);

    /* pt, equation 26 */

    pt = Gt_'*zt + Qt'*dt;

    /* st, equation 19 */

    st = Vt*(zt-mu*FDD*dt);
    S[t,.] = St';

    /* a(t), equation 30 */

    oldtrap = trapchk(1);
    trap 1,1;
    at = invpd(Ut)*zt;
    trap oldtrap,1;
    if scalerr(at);

      ERRORLOG "error: U(t) is not a positive definite matrix.";
      call pause(2);
      retp(error(0),error(0),error(0),error(0));

    endif;

    u_t = yt - Ht*at - mt;
    a[t,.] = at';
    u[t,.] = u_t';

    /* Cost functions */

    c2M = c2M + u_t'MMt*u_t;

    if t > 1;
      u_t = at - Ft_1*at_1 -dt_1;
      c2D = c2D + u_t'DDt_1*u_t;
    endif;

    at_1 = at;
    Ft_1 = Ft;
    dt_1 = dt;
    DDt_1 = DDt;

    t = t + 1;
  endo;

  /* GFLS smoother */

  /* Initial condition, Equation 33b */

  ast = at;
  as[Nobs,.] = ast';

  t = Nobs-1;
  do while t >= 1;

    /* Equation 33a */

    Gt_ = xpnd(G[t,.]');
    st = s[t,.]';
    yt = y[t,.]';
    Ht = H(t);
    mt = m(t);

    ast = st + Gt_*ast;
    as[t,.] = ast';

    u_t = yt - Ht*ast - mt;
    us[t,.] = u_t';

    t = t - 1;
  endo;

  tt = (hsec-tt)/100;

  if _print == 1;

    print;
    print "----------------------------------------------------------------";
    print "          Generalized Flexible Least Squares (GFLS)             ";
    print "----------------------------------------------------------------";
    print;

    st = "mu-weight parameter:                             %*.*lf  ";
    print ftos(mu,st,15,4);
    print;
    st = "Total observations:                              %*.*lf  ";
    print ftos(Nobs,st,15,0);
    st = "Dimension of the measured vector:                %*.*lf  ";
    print ftos(m_,st,15,0);
    st = "Dimension of the state vector:                   %*.*lf  ";
    print ftos(n,st,15,0);
    st = "Measurement cost:                                %*.*lf  ";
    print ftos(c2M,st,15,4);
    st = "Dynamic cost:                                    %*.*lf  ";
    print ftos(c2D,st,15,4);
    print;
    st = "Computation time: %lf seconds";
    print ftos(tt,st,10,4);

  endif;

  _cost = c2M|c2D;

  retp(a,u,as,us);
endp;


proc (3) = _gfls(y,H,m,MM,F,d,DD,Q0,p0,mu);

  local H:proc,m:proc,MM:proc,F:proc,d:proc,DD:proc;
  local Nobs,m_,n,J;

  if ismiss(y);
    ERRORLOG "error: Not implemented with missing values.";
    end;
  endif;

  Nobs = rows(y);
  m_ = cols(y);
  J = H(1);
  n = cols(J);

  if rows(J) /= m_;
    ERRORLOG "error: Wrong size format of the H(t) matrices.";
    end;
  endif;

  J = m(1);
  if (rows(J) /= m_) or (cols(J) /= 1);
    ERRORLOG "error: Wrong size format of the m(t) vectors.";
    end;
  endif;

  J = MM(1);
  if (rows(J) /= m_) or (cols(J) /= m_);
    ERRORLOG "error: Wrong size format of the M(t) matrices.";
    end;
  endif;

  J = F(1);
  if (rows(J) /= n) or (cols(J) /= n);
    ERRORLOG "error: Wrong size format of the F(t) matrices.";
    end;
  endif;

  J = d(1);
  if (rows(J) /= n) or (cols(J) /= 1);
    ERRORLOG "error: Wrong size format of the d(t) vectors.";
    end;
  endif;

  J = DD(1);
  if (rows(J) /= n) or (cols(J) /= n);
    ERRORLOG "error: Wrong size format of the D(t) matrices.";
    end;
  endif;

  J = Q0;
  if (rows(J) /= n) or (cols(J) /= n);
    ERRORLOG "error: Wrong size format of the Q0 matrix.";
    end;
  endif;

  J = p0;
  if (rows(J) /= n) or (cols(J) /= 1);
    ERRORLOG "error: Wrong size format of the p0 vector.";
    end;
  endif;

  if (rows(mu) /= 1) or (cols(mu) /= 1) or (mu <= 0);
    ERRORLOG "error: mu must be a positive scalar.";
    end;
  endif;

  retp(Nobs,m_,n);
endp;


/*
** GFLS: Generalized Flexible Least Squares of Lutkepohl and Herwartz [1996]
*/

proc (3) = GFLS2(y,x,s,mu,B,C,D,F);
  local err,K,Nobs,data,retcode,rc,y_,x_,N;
  local beta,u,SSE,tt,st;

  tt = hsec;

  err = _LS_comp(y,x);

  if err == 1;
    retp(error(0),error(0),error(0));
  endif;

  if (s < 2) or (trunc(s) /= s);
    ERRORLOG "error: The seasonal period is an integer greater than 1.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  K = cols(x); Nobs = rows(y);

  if (rows(B) /= K) or (cols(B) /= K);
    ERRORLOG "error: Wrong size format of the B matrix.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  if (rows(C) /= K) or (cols(C) /= K);
    ERRORLOG "error: Wrong size format of the C matrix.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  if (rows(D) /= K) or (cols(D) /= K);
    ERRORLOG "error: Wrong size format of the D matrix.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  if (rows(F) /= K) or (cols(F) /= K);
    ERRORLOG "error: Wrong size format of the F matrix.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  if (rows(mu) /= 2) or (cols(mu) /= 1);
    ERRORLOG "error: Wrong size format of the mu vector.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  if minc(mu) < 0;
    ERRORLOG "error: The elements of mu must be positive.";
    call pause(2);
    retp(error(0),error(0),error(0));
  endif;

  data = y~x;
  {data,retcode} = MISSING(data,0);
  y_ = data[.,1]; x_ = data[.,2:K+1]; N = rows(y_);
  {beta,u,SSE} = _GFLS2(y_,x_,s,mu,B,C,D,F);

  if beta == error(0);
    retp(error(0),error(0),error(0));
  endif;

  {beta,rc} = MISSING(beta,retcode);
  {u,rc} = MISSING(u,retcode);

  tt = (hsec-tt)/100;
  if _print == 1;

    print;
    print "----------------------------------------------------------------";
    print "           Generalized Flexible Least Squares (GFLS)            ";
    print "----------------------------------------------------------------";
    print;

    st = "mu-weight parameter (dynamic):                   %*.*lf  ";
    print ftos(mu[1],st,15,4);
    print;

    st = "mu-weight parameter (seasonal):                  %*.*lf  ";
    print ftos(mu[2],st,15,4);
    print;

    st = "Total observations:                              %*.*lf  ";
    print ftos(Nobs,st,15,0);
    st = "Usable observations:                             %*.*lf  ";
    print ftos(N,st,15,0);
    st = "Number of regressors:                            %*.*lf  ";
    print ftos(K,st,15,0);
    st = "Sum of squared errors:                           %*.*lf  ";
    print ftos(SSE,st,15,4);
    print;
    st = "Computation time: %lf seconds";
    print ftos(tt,st,10,4);

  endif;

  retp(beta,u,SSE);
endp;


proc (3) = _GFLS2(y,x,s,mu,B,C,D,F);
  local N,K,Gy,indx,A,beta,xn,An,Mn,M,t;
  local mu1,mu2,Dtilde,Ftilde;
  local BDB,CFC,BD,DB,CF,FC;
  local M1,M2,M3,M4,M5,M6,M7;
  local oldtrap,bn,u,yhat,SSE;

  mu1 = mu[1];
  mu2 = mu[2];

  N = rows(y);
  K = cols(x);

  Dtilde = mu1*D;
  Ftilde = mu2*F;

  BDB = B'*Dtilde*B;
  CFC = C'*Ftilde*C;
  BD = -B'*Dtilde;
  DB = -Dtilde*B;
  CF = -C'*Ftilde;
  FC = -Ftilde*C;

  M1 = BDB + CFC;
  M2 = Dtilde + BDB + CFC;
  M3 = Dtilde + BDB + CFC + Ftilde;
  M4 = Dtilde + BDB + Ftilde;
  M5 = Dtilde + Ftilde;

  M6 = zeros(K,s*K);
  M6[.,1:K] = FC;
  M6[.,1+(s-1)*K:s*K] = DB;

  Gy = vec(x').*(y.*.ones(K,1));

  indx = seqa(K-1,-1,K);

  /* Band compact form matrix of A(mu,N) */

  A = zeros(N*K,(s+1)*K);

  Mn = zeros(K,s*K);
  Mn[.,1:K] = FC;
  Mn[.,1+(s-1)*K:s*K] = DB;

  /* A1.(mu) */

  xn = x[1,.];
  An = xn'xn + M1;
  M = zeros(K,s*K)~An;
  A[1:K,.] = shiftr(M,indx,0);

  /* An.(mu) for n = 2,...,s */

  t = 2;
  do until t > s;
    xn = x[t,.];
    An = xn'xn + M2;
    M = zeros(K,(s+1)*K);
    M[.,1+(s-t+1)*K:(s+1)*K] = Mn[.,1+(s-t+1)*K:s*K]~An;
    A[1+(t-1)*K:t*K,.] = shiftr(M,indx,0);
    t = t+1;
  endo;


  /* An.(mu) for n = s,...,N-s */

  do until t > (N-s);

    xn = x[t,.];
    An = xn'xn + M3;
    M = Mn~An;
    A[1+(t-1)*K:t*K,.] = shiftr(M,indx,0);
    t = t+1;
  endo;

  /* An.(mu) for n = N-s+1,...,N-1 */

  do until t > (N-1);

    xn = x[t,.];
    An = xn'xn + M4;
    M = Mn~An;
    A[1+(t-1)*K:t*K,.] = shiftr(M,indx,0);

    t = t+1;
  endo;

  /* An.(mu) for n = N */

  xn = x[N,.];
  An = xn'xn + M5;
  M = Mn~An;
  A[1+(N-1)*K:N*K,.] = shiftr(M,indx,0);

  /* B(FLS) (equation 4.4) */

  oldtrap = trapchk(1);
  trap 1,1;
  beta = bandsolpd(Gy,A);
  trap oldtrap,1;
  if scalerr(beta);

    ERRORLOG "error: A(mu) is not a positive definite matrix.";
    call pause(2);
    retp(error(0),error(0),error(0));

  endif;

  beta = reshape(beta,N,K);

  /* Residuals */

  bn = beta';

  yhat =  sumc(x'.*bn);
  u = y - yhat;

  /* sum of squared errors (SSE) */

  SSE = u'u;

  retp(beta,u,SSE);
endp;
