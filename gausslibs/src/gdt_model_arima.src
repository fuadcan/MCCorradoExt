/*
** gdt_model_arima.src
**
**
** (C) Copyright 2003  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
**-------------------**------------------**-------------------**-----------**
**-------------------**------------------**-------------------**-----------**
**
**
**> _gdt_model_arima
**
**  Purpose:    generates simulated data based on an arima model
**
**  Format:     { r,s } = _gdt_model_arima(args);
**
**  Input:      args    string array, keywords for simulation options
**
**                         file   output file name, default = "arima"
**                      depname   name of dependent variable, default = "Y"
**                       indvar   list of names of independent variables,
**                                   default is no independent variables
**                     constant   value of constant, default = 0.
**                         beta   list of values of coefficients in mean equation,
**                                default is no coefficients
**                          vcx   covariance matrix of exogenous variables, default = identity.
**                           ar   list of values of auto-regressive coefficients,
**                                     default is no coefficients
**                           ma   list of values of moving average coefficients,
**                                     default is no coefficients
**                            d   value of level of integration
**                       normal   variance.  Normally distributed error term with
**                                     specified variance.  Default is 1.
**                            t   df,variance.  Student's t distributed error term with
**                                     specified df parameter and variance.  Default is 1.
**                       numobs   number of observations, default = 100
**                         seed   random number generator seed. Default = 345678
**                         open   resulting dataset opened in Data Tool. Default
**                                  is closed
**
**
**  Output:     r           scalar, return code.  Normal return = 0.
**
**              s           string, return message.  Normal return = "".
**
**  Remarks:  For null input argument, args = "", serially uncorrelated
**            standard Normal observations are generated.
**
**  Example:
**
**         sa1 = "file test"      $|
**               "depvar YY"      $|
**               "constant .5"    $|
**               "ar .5"          $|
**               "ma .5"          $|
**               "d  1"           $|
**               "numobs 10000"   $|
**
**               call _gdt_model_arima(sa1);
**
*/


#include gdttools.ext


proc(2) = _gdt_model_arima(args);

    local fp,fname,depname,indnames,b0,beta,s1,s2,s3,kmin,
           ar,ma,h,r,_p,_q,_d,g,k,phi,theta,cov,e,rmax,c,a,
           lbl,y,x,u,distType,distPars,eps,sd,pr,z,nobs,
           openf,w,covc,oldt,vc,df,vcx,numx;

    fname = "arima";
    depname = "Y";
    indnames = "";
    b0 = 1;
    beta = error(0);
    ar = .5;
    ma = .5;
    _d = 0;
    _p = 0;
    _q = 0;
    distType = 1;
    nobs = 100;
    sd = 345678;
    vcx = 1;
    df = 5;
    openf = 0;
    vc = 1;

    for i(1,rows(args),1);

        if args[1] $/= "";

            { s1,s2 } = token(args[i]);
            if lower(s1) $== "file";
                 fname = s2;
            elseif lower(s1) $== "depvar";
                 depname = s2;
            elseif lower(s1) $== "indvar";
                 indnames = strsplit(s2)';
            elseif lower(strsect(s1,1,5)) $== "const";
                 b0 = stof(s2);
            elseif lower(s1) $== "beta";
                 beta = strtof(strsplit(s2))';
            elseif lower(s1) $== "vcx";
                 vcx = strtof(strsplit(s2))';
            elseif lower(s1) $== "ar";
                 ar = strtof(strsplit(s2))';
                 _p = rows(ar);
            elseif lower(s1) $== "ma";
                 ma = strtof(strsplit(s2))';
                 _q = rows(ma);
            elseif lower(s1) $== "d";
                 _d = stof(s2);
            elseif lower(s1) $== "numobs";
                 nobs = stof(s2);
            elseif lower(s1) $== "normal";
                 distType = 1;
                 distPars = strtof(strsplit(s2))';
                 if scalmiss(distPars[1]);
                     vc = 1;
                 endif;
            elseif lower(s1) $== "t";
                 distType = 2;
                 distPars = strtof(strsplit(s2))';
                 if scalmiss(distPars[1]);
                     df = 5;
                     vc = 1;
                 else;
                     df = distPars[1];
                 endif;
                 if rows(distPars) > 1;
                     if distPars[2] > 0;
                         vc = distPars[2];
                     else;
                         vc = 1;
                     endif;
                 else;
                     vc = 1;
                 endif;
            elseif lower(s1) $== "seed";
                 sd = stof(s2);
            elseif lower(s1) $== "open";
                openf = 1;
            endif;

        endif;

    endfor;

    open fp = ^fname;
    if fp /= -1;
        errorlog "dataset already exists, choose a different name";
        fp = close(fp);
        retp(-1,"",);
    endif;
    fp = close(fp);

     if scalmiss(beta) and indnames[1] $/= "";
         beta = .2 * ones(rows(indnames),1);
         numx = rows(indnames);
     elseif not scalmiss(beta) and indnames[1] $== "";
         numx = rows(beta);
         indnames = ftostrC(seqa(1,1,numx),"X%1.0lf");
     elseif not scalmiss(beta) and indnames[1] $/= "";
         if rows(beta) /= rows(indnames);
             errorlog "number of coefficients inconsistent with\n"\
                      "list of names of independent variables";
             retp(-1,"");
         else;
             numx = rows(indnames);
         endif;
     else;
         numx = 0;
     endif;

     if numx > 0;
        if rows(vcx) > 1 and not (vcx == 1);
            if rows(vcx) /= 0.5*numx*(numx+1);
                errorlog "size of variance-covariance matrix inconsistent\n"\
                         "with number of independent variables";
                retp(-1,"");
            endif;
            vcx = xpnd(vcx);
            oldt = trapchk(1);
            trap 1,1;
            vcx = chol(vcx);
            trap oldt,1;
            if scalmiss(vcx);
                errorlog "covariance matrix of independent variables is\n"\
                         " singular, identity matrix will be used";
                vcx = 1;
            endif;
        endif;
     endif;

    if numx > 0;
        { x,sd } = rndKMn(nobs,rows(beta),sd);
        x = x * vcx;
    endif;

    if distType == 1;
        { e,sd } = rndKMn(nobs+_p+_q,1,sd);
    elseif distType == 2;
        { e,sd } = rndKMu(nobs+_p+_q,1,sd);
        e = cdftci(1-e,df);
    endif;

    e = e * sqrt(vc);

    if _q == 0 and _p > 0;
        if _p == 1;
            y = trimr(recserar(e[1:nobs+1,.],sqrt(1/(1-ar^2)).*e[1,.],ar),_p,0);
        else;
            g = _gdt_model_tautocov(ar,ma);
            e[1:_p,.] = chol(toeplitz(g[1:_p]))'e[1:_p,.];
            y = trimr(recserar(e,e[1:_p,.],ar.*ones(_p,1)),_p,0);
        endif;
    elseif _p == 0 and _q > 0;
        y = conv(1|-ma,e,_q+1,nobs+_q);
    elseif _p > 0 and _q > 0;
        g = _gdt_model_tautocov(ar,ma);
        cov = zeros(_p+_q,_p+_q);
        phi = -1|ar;
        theta = -1|ma;
        rmax = maxc(_p|_q);
        c = zeros(_q+1,1);
        a = zeros(rmax+1,rmax+1);
        c[1] = 1;
        k = 1;
        for h(1,_q,1);
            kmin = minc(_p|h);
            if (_p gt 0) and (h le _p);
                c[h+1] = -theta[h+1] + phi[2:kmin+1]'rev(c[1:kmin]);
            elseif (_p gt 0) and (h gt _p);
                c[h+1] = -theta[h+1] + phi[2:kmin+1]'rev(c[k+1:kmin+k]);
                k = k + 1;
            elseif (_p == 0);
                c[h+1] = -theta[h+1];
            endif;
        endfor;
        for i(1,_p+_q,1);
            for j(i,_p+_q,1);
                if i == j;
                    if i le _p;
                        cov[i,j] = g[1];
                    else;
                        cov[i,j] = 1;
                    endif;
                else;
                    if (i le _p) and (j le _p);
                        cov[i,j] = g[j-i+1];
                    else;
                        if (i-_p le 0) and (i-_p ge j-_p-_q);
                            cov[i,j] = c[i-j+_q+1];
                        endif;
                    endif;
                endif;
           endfor;
        endfor;
        oldt = trapchk(1);
        trap 1,1;
        covc = chol(cov);
        trap oldt,1;
        if scalmiss(covc);
            errorlog "ARIMA: infeasible ar/ma parameters";
            retp(-1,"");
        else;
           e[1:_p+_q] = covc'e[1:_p+_q,.];
        endif;
        e[1+_p:nobs+_p] = conv(1|-ma,e[_p+1:nobs+_p+_q],1+_q,nobs+_q);
        y = trimr(recserar(zeros(_p,1)|e[1+_p:nobs+_p,.],e[1:_p,.],ar.*ones(_p,1)),_p,0);
    else;
        y = e;
    endif;
    y = y + b0[1];
    if not scalmiss(beta);
        y = y + x * beta;
    endif;
    for i(1,_d,1);
        y = cumsumc(y);
    endfor;

    if scalmiss(beta);
        lbl = depname;
    else;
        lbl = depname $| indnames;
    endif;

    create fp = ^fname with ^lbl,0,8;
    if scalmiss(beta);
        call writer(fp,y);
    else;
        call writer(fp,y~x);
    endif;
    fp = close(fp);

    if openf;
        retp(1,fname);
    else;
        retp(0,"");
    endif;

endp;








proc _gdt_model_tautocov(phi,theta);
    local rmax,c,b,a,k,kmin,g,j,i,t1,t2,p,q;

    if scalmiss(phi);
        p = 0;
    else;
        p = rows(phi);
    endif;
    if scalmiss(theta);
        q = 0;
    else;
        q = rows(theta);
    endif;

    if p gt 0;
        phi = -1|phi;
    endif;
    if q == 0;
        theta = -1;
    else;
        theta = -1|theta;
    endif;
    rmax = maxc(p|q);
    c = zeros(q+1,1);
    b = zeros(rmax+1,1);
    a = zeros(rmax+1,rmax+1);
    c[1] = 1;
    k=1; j=1; do while k <= q;
        kmin = minc(p|k);
        if (p gt 0) and (k le p);
            c[k+1] = -theta[k+1] + phi[2:kmin+1]'rev(c[1:kmin]);
        elseif (p gt 0) and (k gt p);
            c[k+1] = -theta[k+1] + phi[2:kmin+1]'rev(c[j+1:kmin+j]);
            j=j+1;
        elseif (p == 0);
            c[k+1] = -theta[k+1];
        endif;
    k=k+1; endo;
    k=1; do while k <= q+1;
        b[k] = -theta[k:q+1]'c[1:q+2-k];
    k=k+1; endo;
    if p == 0;
        g = b;
    else;
        a[1:p+1,1] = phi;
        j=2; do while j <= rmax+1;
            i=1; do while i <= rmax+1;
                t1=i-j+1;
                t2=i+j-1;
                if t1 > 0 and t1 <= p+1;
                    if t2 > 0 and t2 <= p+1;
                        a[i,j] = phi[t1]+phi[t2];
                    else;
                        a[i,j] = phi[t1];
                    endif;
                else;
                    if t2 > 0 and t2 <= p+1;
                        a[i,j] = phi[t2];
                    endif;
                endif;
            i=i+1; endo;
        j=j+1; endo;
        g = -b/a;
    endif;
retp(g);
endp;











    proc(0) = _gdt_model_arima_help;

       local s1;

       s1 = "
Purpose: generates arima simulation

Format:  model arima
         [options]
         
Example: model arima
         file arsim
         depvar y
         ar .1
         ma .3
         open
         
Options: file      output file name, default = arima
         depvar    name of dependent variable, default = Y
         indvar    list of names of independent variables, 
                       default is no independent variables
         constant  value of constant, default = 1
         beta      list of values of regression coefficients, 
                       default is no coefficients
         vcx       covariance matrix of exogenous variables, 
                       default = identity
         ar        list of values of autoregression coefficients,
                       default is no coefficients
         ma        list of values of moving average coefficients,
                       default is no coefficients
         d         value of level of integration
         numobs    number of observations, default = 100
         normal    variance.  Normally distributed error term with
                       specified variance.  Default is 1
         t         df,variance.  Student's t distributed error term with
                       specified df parameter and variance  Default is 5,1
         seed      random number generator seed. Default = 345678
         open      resulting dataset opened in Data Tool. Default is closed";

       print s1;

    endp;
