/*
** QProgmt - Quadratic Programming
**
** (C) Copyright 2005-2006  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
*/

/*
**> QProgmt
**
**  Purpose:  solves the quadratic programming problem
**
**  Format:
**            { qpo1 } = QProgmt( qpi1 );
**
**
**  Input:  qpi1   an instance of a qprogMTIn structure containing the
**                 following members:
** 
**					qpi1.start -- Kx1 vector,  starting values.
**
**					qpi1.q -- KxK matrix, model coefficient matrix.
**
**					qpi1.r -- Kx1 vector, model constant vector.
**
**					qpi1.a -- MxK matrix, equality constraint 
**							coefficient matrix if no equality constraints 
**							in model, set to zero.
**
**					qpi1.b -- Mx1 vector, equality constraint constant 
**							vector if set to zero and M > 1, b is set to 
**							Mx1 vector of zeros.
**
**					qpi1.c -- NxK matrix, inequality constraint 
**							coefficient matrix if no inequality 
**							constraints in model, set to zero.
**
**					qpi1.d -- Nx1 vector, inequality constraint constant 
**							vector if set to zero and N > 1, d is set to 
**							Mx1 vector of zeros.
**
**					qpi1.bnds -- Kx2 vector, bounds on x, the first 
**							column contains the lower bounds on x, and 
**							the second column the upper bounds, if zero 
**							bounds for all elements of x are set to the 
**							plus and minus 1e200. 
**
**					qp1.maxit -- scalar, maximum number of iterations,
**							default = 1000.
**
**  Output: qpo1   an instance of a qprogMTOut structure containing the
**                 following members:
** 
**					qpo1.x -- Kx1 vector, coefficients at the minimum 
**							of the function.
**
**					qpo1.lagrange -- an instance of a qprogMTLagrange
**							structure containing the following members:
**
**							qpo1.lagrange.lineq --  Mx1 vector, 
**								Lagrangian coefficients of equality 
**								constraints.
**
**							qpo1.lagrange.linineq -- Nx1 vector, 
**								Lagrangian coefficients of inequality 
**								constraints.
**
**							qpo.1.lagrange.bounds -- Kx2 vector, 
**								Lagrangian coefficients of lower and 
**								upper bounds.
**
**					qpo1.ret -- return code, if 0, successful 
**							termination, else:
**
**							if 1, max iterations exceeded,
**							if 2, machine accuracy is insufficient to
**								maintain decreasing function values,
**							if 3, model matrices not conformable,
**							if < 0, active constraints inconsistent.
**
**  Remarks:  QProgmt solves the standard quadratic programming problem:
**
**         minimize  0.5 * x'Qx - x'R
**
**         subject to constraints,
**
**             Ax  = B
**             Cx >= D
**
**         and bounds,
**
**             bnds[.,1] <= x <= bnds[.,2]
**
*/

#include qprogmt.sdf

proc QProgmt(struct qprogMTIn qpi0);

local m, n, ret, u, w, lw, iact, c1, maxit, numeq,
      isa, isc, eps, xl, xu, lql, x, q, r, a, b,
		c, d, bnds;
struct qprogMTOut qpo0;

	x = qpi0.start;
	q = qpi0.q;
	r = qpi0.r;

	if qpi0.a == error(0);
		a = 0;
	else;
		a = qpi0.a;
	endif;

	if qpi0.b == error(0);
		b = 0;
	else;
		b = qpi0.b;
	endif;

	if qpi0.c == error(0);
		c = 0;
	else;
		c = qpi0.c;
	endif;

	if qpi0.d == error(0);
		d = 0;
	else;
		d = qpi0.d;
	endif;

	bnds = qpi0.bounds;
	maxit = qpi0.maxit;


    if rows(bnds) == 1 and cols(bnds) == 1;
        xl = -1e200*ones(rows(x),1);
        xu = 1e200*ones(rows(x),1);
    elseif rows(bnds) == 1 and cols(bnds) == 2;
        xl = bnds[1,1]*ones(rows(x),1);
        xu = bnds[1,2]*ones(rows(x),1);
    else;
        if rows(bnds) /= rows(R);
            errorlog "QProgmt: bounds not conformable";
			qpo0.x = error(0);
			qpo0.lagrange.lineq = error(0);
			qpo0.lagrange.linineq = error(0);
			qpo0.lagrange.bounds = error(0);
			qpo0.ret = 3;
            retp(qpo0);
        endif;
        xl = bnds[.,1];
        xu = bnds[.,2];
    endif;

    isa = rows(a) /= 1 or cols(a) /= 1 or a /= 0;
    isc = rows(c) /= 1 or cols(c) /= 1 or c /= 0;
    if isa and isc;
        numeq = rows(a);
        if cols(c) /= cols(a);
            if not trapchk(1);
                errorlog "QProgmt:  constraints not conformable";
                end;
            endif;
			qpo0.x = error(0);
			qpo0.lagrange.lineq = error(0);
			qpo0.lagrange.linineq = error(0);
			qpo0.lagrange.bounds = error(0);
			qpo0.ret = 3;
            retp(qpo0);
        else;
            a = a|c;
        endif;
        if rows(c) /= rows(d);
            if rows(b) == 1 and cols(b) == 1 and b == 0;
                b = b | zeros(rows(c),1);
            else;
                if not trapchk(1);
                    errorlog "QProgmt: equality constraint matrices not"\
                             " consistent";
                    end;
               endif;
				qpo0.x = error(0);
				qpo0.lagrange.lineq = error(0);
				qpo0.lagrange.linineq = error(0);
				qpo0.lagrange.bounds = error(0);
				qpo0.ret = 3;
               retp(qpo0);
           endif;
        else;
            b = b | d;
            d = 0;
        endif;
    elseif isa and not isc;
        numeq = rows(a);
        if rows(a) /= rows(b);
            if rows(b) == 1 and cols(b) == 1 and b == 0;
                b = zeros(rows(a),1);
            else;
                if not trapchk(1);
                    errorlog "QProgmt: equality constraint matrices not"\
                             " consistent";
                    end;
                endif;
				qpo0.x = error(0);
				qpo0.lagrange.lineq = error(0);
				qpo0.lagrange.linineq = error(0);
				qpo0.lagrange.bounds = error(0);
				qpo0.ret = 3;
                retp(qpo0);
           endif;
       endif;
    elseif isc and not isa;
       numeq = 0;
       a = c;
       if rows(c) /= rows(d);
           if rows(b) == 1 and cols(b) == 1 and b == 0;
               b = zeros(rows(c),1);
           else;
               if not trapchk(1);
                   errorlog "QProgmt: equality constraint matrices not"\
                            " consistent";
                   end;
               endif;
				qpo0.x = error(0);
				qpo0.lagrange.lineq = error(0);
				qpo0.lagrange.linineq = error(0);
				qpo0.lagrange.bounds = error(0);
				qpo0.ret = 3;
               retp(qpo0);
           endif;
       else;
          b = d;
       endif;
   else;
       numeq = 1;
       a = zeros(1,rows(x));
   endif;
   c = 0;
   d = 0;

   if rows(q) /= cols(q);
       if not trapchk(1);
           errorlog "QProgmt:  model matrix not square";
           end;
       endif;
		qpo0.x = error(0);
		qpo0.lagrange.lineq = error(0);
		qpo0.lagrange.linineq = error(0);
		qpo0.lagrange.bounds = error(0);
		qpo0.ret = 3;
       retp(qpo0);
   endif;
   if rows(q) /= rows(r);
       if not trapchk(1);
           errorlog "QProgmt:  model matrices not consistent";
           end;
       endif;
		qpo0.x = error(0);
		qpo0.lagrange.lineq = error(0);
		qpo0.lagrange.linineq = error(0);
		qpo0.lagrange.bounds = error(0);
		qpo0.ret = 3;
       retp(qpo0);
   endif;
   if rows(x) /= rows(q);
       if not trapchk(1);
           errorlog "QProgmt:  starting vector not conformable to model matrix";
           end;
       endif;
		qpo0.x = error(0);
		qpo0.lagrange.lineq = error(0);
		qpo0.lagrange.linineq = error(0);
		qpo0.lagrange.bounds = error(0);
		qpo0.ret = 3;
       retp(qpo0);
   endif;

   { b,xl,xu,x,ret }=
               _intqpsolvfcn01(q,r,a,b,xl,xu,x,numeq,maxit,1);

   local u1, u2;
   if isa and not isc;
       u1 = b;
       u2 = 0;
   elseif not isa and isc;
       u1 = 0;
       u2 = b;
   elseif not isa and not isc;
       u1 = 0;
       u2 = 0;
   else;
       u1 = b[1:numeq];
       u2 = b[numeq+1:rows(b)];
   endif;

	qpo0.x = x;
	qpo0.lagrange.lineq = u1;
	qpo0.lagrange.linineq = u2;
	qpo0.lagrange.bounds = xl~xu;
	qpo0.ret = ret;
   retp(qpo0);

endp;


proc qprogMTInCreate;
	struct qprogMTIn qpi0;

	qpi0.maxit = 1000;
	
	retp(qpi0);
endp;

