/*
** hypotest.src  -  procedures for testing hypotheses with constraints
**
**
** (C) Copyright 2006 Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** if you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
******************************************************************************
**
**
**> ConScore
**
**  Purpose:  compute the local score statistic and its probability for
**             an hypothesis regarding parameters under constraints
**
**  Format:   { SL, Slprob  } = ConScore(H,G,grad,a,b,c,d,bounds,psi)
**
**
**  Input:     H   KxK matrix, Hessian of loglikelihood with respect to parameters
**
**             G   KxK matrix, cross-product matrix of the first derivatives by
**                 observation.  If not available set to H.
**
**             grad  Kx1 vector, gradient of loglikelihood with respect to parameters
**
**             A            MxK matrix, linear equality constraint coefficients
**             B            Mx1 vector, linear equality constraint constants
**
**                      These arguments specify the linear equality
**                      constraints of the following type:
**
**                         A * X = B
**
**                      where X is the Kx1 parameter vector.
**
**             C        MxK matrix, linear inequality constraint coefficients
**             D        Mx1 vector, linear inequality constraint constants
**
**                       These arguments specify the linear inequality
**                       constraints of the following type:
**
**                            C * X >= D
**
**                       where X is the Kx1 parameter vector.
**
**             bounds    Kx2 matrix, bounds on parameters.  The first column
**                       contains the lower bounds, and the second column the
**                       upper bounds.  
**
**             psi       indices of the set of parameters in the hypothesis.
**
**  Output:    SL        scalar, local score statistic of hypothesis.
**
**             SLprob    scalar, probability of SL
**
**
**  Remarks:  ConScore computes the local score statistic for the hypothesis
**            H(theta) = 0 vs. H(theta) >= 0, where theta is the vector of
**            estimated parameters, and H() is a constraint function of the parameters.
**              
**            First, the model with H(theta) = 0 is estimated and the Hessian and,
**            optionally the cross-product of the derivatives is computed.  Also,
**            the gradient vector is computed.    
**
**            Next, the constraint arguments are set to H(theta) >= 0.  
**
**  Example:         
**
**  This example is from Silvapulle and Sen, _Constrained_
**  _Statistical_Inference_, page 181-3.  It computes
**  the local score statistic and probability for an arch
**  model.  It tests the null hypothesis of no arch
**  effects against the alternative of arch effects 
**  subject to their being constrained to be positive.
**
**  The Hessian, H, cross-product matrix, G, and the
**  gradient vector, Grad, are generated by an
**  estimation using Sqpsolvemt where the model is
**  an ARCH model with the arch parameters constrained
**  to be zero. 
**  
**  
**  #include sqpsolvemt.sdf
**  
**  /* data */
**  
**  struct DS d0;
**  d0 = reshape(dsCreate,2,1);
**  
**  load z0[] = aoi.asc;
**  z = packr(lagn(251*ln(trimr(z0,1,0)./trimr(z0,0,1)),0|1|2|3|4));
**  d0[1].dataMatrix = z[.,1];
**  d0[2].dataMatrix = z[.,2:5];
**  
**  
**  /* control structure */
**  
**  struct sqpsolvemtControl c0;
**  c0 = sqpSolveMTcontrolCreate;
**  
**  // constraints setting arch parameter equal to zero
**  // for H(theta) = 0
**    
**  c0.A = zeros(3,6) ~ eye(3); 
**  c0.B = zeros(3,1);
**  
**  c0.covType = 2;  // causes cross-product of Jacobian
**                   // to be computed which is needed for 
**                   // conscore
**  
**  struct PV p0;
**  p0 = pvPack(pvCreate,.08999,"constant");
**  p0 = pvPack(p0,.25167|-.12599|.09164|.07517,"phi");
**  p0 = pvPack(p0,3.22713,"omega");
**  p0 = pvPack(p0,0|0|0,"arch");
**  
**  
**  struct sqpsolvemtOut out0;
**  out0 = sqpsolvemt(&lpr,p0,d0,c0);
**  
**  
**  // set up constraints for H(theta) >= 0
**  
**  
**  bounds = { -1e256 1e256,
**             -1e256 1e256,
**             -1e256 1e256,
**             -1e256 1e256,
**             -1e256 1e256,
**             -1e256 1e256,
**                0 1e256,
**                0 1e256,
**                0 1e256 };
**  
**  
**  psi = { 7, 8, 9 };
**  
**  { sl, slprob } = conscore(out0.hessian,out0.xproduct,-out0.gradient,0,0,0,0,bounds,psi);
**  
**  
**  print;
**  print;
**  print "-------------------------------------------";
**  print "  test of H(arch) = 0 vs. H(arch) >= 0";
**  print;
**  print "    constrained score statistic " sl;
**  print "                    probability " slprob;
**  
**  
**  
**  // procedure for computing ARCH log-likelihood
**    
**  proc lpr(struct PV p, struct DS d);
**      local series,b,omega,arch,const,phi,u2,q,n,h,v,logl;
**      
**  
**      omega = pvUnpack(p,"omega");
**      arch = pvUnpack(p,"arch");
**      const = pvUnpack(p,"constant");
**      phi = pvUnpack(p,"phi");
**  
**      u2 = (d[1].dataMatrix - d[2].dataMatrix * phi - const)^2;
**  
**      q = rows(arch);
**      n = rows(u2);
**      h = ones(n,1);
**      v = seqa(1,1,q)' + seqa(0,1,n-q);
**      h[q+1:rows(h)] = omega + reshape(u2[v],n-q,q) * arch;
**      h[1:q] = ones(q,1)*meanc(h[q+1:rows(h)]);
**  
**      logl = -0.5*( (u2 ./ h) + ln(2 * pi) + ln(h) );
**      retp(-logl);
**  
**  endp;
**               
*/                 
                 




proc(2) = conscore( H0, G0, Grad, A, B, C, D, Bounds, psi );

      local seq1,lambda,oldt,w,h,cinv,wv,qp_a,qp_b,numeq,
	        qp_xl,qp_xu,ainv,u,chainv,invcha,invchainv,
			qp_maxit,tail,ncase,state,qp_d,dd,qp_ret,sl,slprob,r,sl1;
			 
      if rows(H0) != rows(G0) or rows(H0) != rows(Grad) or rows(G0) != rows(Grad);
          errorlog "CONSCORE: input matrices not conformable";
          retp(error(0),error(0));
      endif;
      if not(psi == 0);
          seq1 = seqa(1,1,rows(H0));
	      lambda = selif(seq1,1 - sumc(seq1' .== psi));

          oldt = trapchk(1);
          trap 1,1;
          W = solpd(H0[lambda,psi],G0[lambda,lambda])';
          oldt = trapchk(1);
          if scalmiss(W);
             errorlog "CONSCORE: Gx = H solve failed";
             retp(error(0),error(0));
          endif;

          H = H0[psi,psi] - W * H0[lambda,psi];

          oldt = trapchk(1);
          trap 1,1;
          U = solpd( (Grad[psi] - W * Grad[lambda]), H );
          oldt = trapchk(1);
          if scalmiss(U);
              errorlog "CONSCORE: Hx = G solve failed";
              retp(error(0),error(0));
          endif;
     
          oldt = trapchk(1);
          trap 1,1;
          WV = W * H0[lambda,psi];

          Cinv = invpd(G0[psi,psi] - WV - WV' + W*G0[lambda,lambda]*W');
          oldt = trapchk(1);
          if scalmiss(Cinv);
              errorlog "CONSCORE: G inverse failed";
              retp(error(0),error(0));
          endif;

      else;

          H = H0;
          oldt = trapchk(1);
          trap 1,1;
          U = solpd(Grad, H );
          oldt = trapchk(1);
          if scalmiss(U);
              errorlog "CONSCORE: Gx = H solve failed";
              retp(error(0),error(0));
          endif;

          oldt = trapchk(1);
          trap 1,1;
          Cinv = invpd(G0);
          oldt = trapchk(1);
          if scalmiss(Cinv);
              errorlog "CONSCORE: G inverse failed";
              retp(error(0),error(0));
          endif;
          psi = seqa(1,1,rows(H));

     endif;

      qp_a = {};
      qp_b = {};
      numEq = 0;
      if not scalmiss(A) and not(rows(A) == 1 and cols(A) == 1 and A[1,1] == 0);
          qp_a = qp_a | A[.,psi];
          qp_b = qp_b | B;
          numEq = numEq + rows(A);
      endif;
 
      if not scalmiss(C) and not(rows(C) == 1 and cols(C) == 1 and C[1,1] == 0);
          qp_a = qp_a | C[.,psi];
          qp_b = qp_b | D;
      endif;

      if scalmiss(qp_a);
          qp_a =  zeros(1,rows(psi)-1)~1;
          qp_b = -1e256;
          numeq = 0;
      endif;
      if not scalmiss(bounds) and not(rows(bounds) == 1 and cols(bounds) == 1 and bounds[1,1] == 0);
          qp_xl = bounds[psi,1];
          qp_xu = bounds[psi,2];
      else;
          qp_xl = -1e+256*ones(rows(psi),1);
          qp_xu = -qp_xl;
      endif;
      Ainv = H*Cinv*H;
      chAinv = chol(Ainv);
	  invchainv = utrisol(eye(rows(ainv)),chainv);
      invChA = utrisol(eye(rows(ainv)),chol(invchainv*invchainv'));

      qp_maxit = 1000;
      qp_d = .01*ones(rows(U),1);

      { dd,dd,dd,qp_d,qp_ret } = _intqpsolvfcn01(chAinv,Ainv*U,qp_a,qp_b,qp_xl,qp_xu,qp_d,numeq,qp_maxit,0);

      if qp_ret < 0;
          if not trapchk(4);
             errorlog "constraint no. "$+ftos(-qp_ret,"%*.*lf",1,0)$+" incon"\
                      "sistent";
          endif;
          retp(error(0));
      elseif qp_ret == 1;           
          if not trapchk(4);
              errorlog "maximum iterations exceeded in QPSOLVE";
          endif;
      elseif qp_ret == 2;
          if not trapchk(4);
              errorlog "quadratic program iterations halted due to lack"\
                       " of precision";
          endif;
      endif;

      sl = 2*qp_d'*Ainv*U - qp_d'*Ainv*qp_d;


      tail = 0;
      ncase = 0;
      state = 3245356;

      for i(1,1e5,1);

          { R, state } = rndKMn(rows(U),1,state);   
          
          { dd,dd,dd,qp_d,qp_ret } = _intqpsolvfcn01(chAinv,invChA*R,qp_a,qp_b,qp_xl,qp_xu,qp_d,numeq,qp_maxit,0);
   
          sl1 = 2*qp_d'invChA*R - qp_d'*Ainv*qp_d;

          if qp_ret == 0;
              tail = tail + (sl1 > sl);
              ncase = ncase + 1;
          endif;
          
       endfor;

       slprob = tail/ncase;
     
      retp(sl,slprob);
endp;



/*
**> chiBarSquare
**
**  Purpose:   Compute the probability for a chi bar square statistic
**             from an hypothesis regarding parameters under constraints
**
**  Format:    SLprob = chiBarSquare(SL,H,a,b,c,d,bounds,psi)
**
**
**  Input:     SL      scalar, chi bar square statistic 
**            
**             H       KxK matrix, positive definite covariance matrix
**
**             A            MxK matrix, linear equality constraint coefficients
**             B            Mx1 vector, linear equality constraint constants
**
**                      These arguments specify the linear equality
**                      constraints of the following type:
**
**                         A * X = B
**
**                      where X is the Kx1 parameter vector.
**
**             C        MxK matrix, linear inequality constraint coefficients
**             D        Mx1 vector, linear inequality constraint constants
**
**                       These arguments specify the linear inequality
**                       constraints of the following type:
**
**                            C * X >= D
**
**                       where X is the Kx1 parameter vector.
**
**             bounds    Kx2 matrix, bounds on parameters.  The first column
**                       contains the lower bounds, and the second column the
**                       upper bounds.  
**
**  Output:   SLprob    scalar, probability of SL
**
**
**  Remarks:  See SilvaPulle and Sen, _Constrained_Statistical_Inference_ 
**        page 75 for further details.  Let Z ~ N(0,V).  Define 
**        chi2(V,C) = Z' V^-1 Z - min((Z - T)' V^-1 (Z - T)) where T is in C.
**        Then chiBarSquare computes the probability of the statistic chi2
**        for V and C where C is a set of linear constraints.
**
**  Example:
**
**          V = {
**          0.0005255598    -0.0006871606    -0.0003191342,    
**         -0.0006871606     0.0037466205     0.0012285813,    
**         -0.0003191342     0.0012285813     0.0009081412 }; 
**         
**          SL = 3.860509;
**         
**          Bounds = { 0 200, 0 200, 0 200 };
**         
**          vi = invpd(v);
**         
**          SLprob = chiBarSquare(SL,Vi,0,0,0,0,bounds);
**
*/



proc chiBarSquare(SL,V,A,B,C,D,bounds);
     
      local H,chv,invchV,Vinv,chVinv,qp_a,qp_b,numeq,qp_xl,qp_xu;

      Vinv = invpd(v);
      chVinv = chol(Vinv);
      chV = chol(v);
      invchV = utrisol(eye(rows(chv)),chV);

      qp_a = {};
      qp_b = {};
      numEq = 0;
      if not scalmiss(A) and not(rows(A) == 1 and cols(A) == 1 and A[1,1] == 0);
          qp_a = qp_a | A;
          qp_b = qp_b | B;
          numEq = numEq + rows(A);
      endif;
 
      if not scalmiss(C) and not(rows(C) == 1 and cols(C) == 1 and C[1,1] == 0);
          qp_a = qp_a | C;
          qp_b = qp_b | D;
      endif;

      if scalmiss(qp_a);
          qp_a =  zeros(1,rows(V)-1)~1;
          qp_b = -1e256;
          numeq = 0;
      endif;
      if not scalmiss(bounds) and not(rows(bounds) == 1 and cols(bounds) == 1 and bounds[1,1] == 0);
          qp_xl = bounds[.,1];
          qp_xu = bounds[.,2];
      else;
          qp_xl = -1e+256*ones(rows(V),1);
          qp_xu = -qp_xl;
      endif;

	  local tail,ncase,state,r,dd,qp_ret,sl1,qp_d,qp_maxit;

      tail = 0;
      ncase = 0;
      state = 3245356;
      qp_maxit = 1000;
      qp_d = .01*ones(rows(chVinv),1);

      for i(1,1e5,1);

          { R, state } = rndKMn(rows(V),1,state);   
          
          { dd,dd,dd,qp_d,qp_ret } = _intqpsolvfcn01(chVinv,invchV*R,qp_a,qp_b,qp_xl,qp_xu,qp_d,numeq,qp_maxit,0);
   
          sl1 = 2*qp_d'invChV*R - qp_d'*Vinv*qp_d;

          if qp_ret == 0;
              tail = tail + (sl1 > sl);
              ncase = ncase + 1;
          endif;
          
       endfor;

       retp(tail/ncase);
endp;

