/*
** lapsvd.src - LAPACK svd procedures
**
** (C) Copyright 2002  Aptech Systems, Inc.
** All Rights Reserved.
**
** This Software Product is PROPRIETARY SOURCE CODE OF APTECH
** SYSTEMS, INC.    This File Header must accompany all files using
** any portion, in whole or in part, of this Source Code.   In
** addition, the right to create such files is strictly limited by
** Section 2.A. of the GAUSS Applications License Agreement
** accompanying this Software Product.
**
** If you wish to distribute any portion of the proprietary Source
** Code, in whole or in part, you must first obtain written
** permission from Aptech Systems.
**
**
**
**  Format                           Purpose                             Line
** -----------------------------------------------------------------------------
**  s = lapsvds(X);                  singular value decomposition         37
**  { u,s,v } = lapsvdcusv(X);       singular value decomposition        132
**  { u,s,v } = lapsvdusv(X);        singular value decomposition,
**                                                compact U              235
**
**  { c,s,r } = lapgsvds(A,B)           generalized singular values      340
**  { c,s,r,u,v,q } = lapgsvdcst(A,B)   generalized singular values/
**                                        vectors                        515
**  { d1,d2,z,u,v,q } = lapgsvdst(A,B)  generalized singularvalues/
**                                        vectors, full matrix output    696
*/



/*
** >proc lapsvds
**
**  Purpose:   computes the singular values of a real or complex
**             rectangular matrix
**
**  Format:    s = lapsvds(x);
**
**  Input:     x   mxn matrix, real or complex rectangular matrix
**
**  Output:    s   min(m,n)x1 vector, singular values
**
**  Remarks:   lapsvd computes the singular values of a real or
**             complex rectangular matrix.  The svd is
**
**               x = u * s * v'
**
**             where v is the matrix of right singular vectors.  For
**             the computation of the singular vectors, see lapsvdcusv and
**             lapsvdusv.
**                lapsvd is based on the LAPACK drivers DGESVD and ZGESVD.
**             Further documentation of these functions may be found in
**             the LAPACK User's Guide.
**
**  Example:
**
**               x = { 2.143 4.345 6.124,
**                     1.244 5.124 3.412,
**                     0.235 5.657 8.214 };
**
**               va = lapsvd(x);
**               print va;
**
**                      13.895868
**                      2.1893939
**                      1.4344261
**
**
**               xi = { 4+1 3+1 2+2,
**                      1+2 5+3 2+2,
**                      1+1 2+1 6+2 };
**
**               ve = lapsvds(xi);
**               print ve;
**
**                      10.352877
**                      4.0190557
**                      2.3801546
**
**             See also lapsvdcusv, lapsvdusv.
*/

proc(1)=lapsvds(x);

     local s, u, v, m, n, info, ind1, ind2, w, mm;
     ind1 = 0;
     ind2 = 0;
     info = 0;
     m = rows(x);
     n = cols(x);
     mm = minc(m|n);
     u = 0;
     v = 0;

     if not iscplx(x);

         s = zeros(mm,1);
         dllcall _dgesvd(m,n,x,s,u,v,info,ind1,ind2);

     else;

         s = complex(zeros(mm,1),zeros(mm,1));
         dllcall _zgesvd(m,n,x,s,u,v,info,ind1,ind2);

     endif;

     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapsvd:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapsvd:  failure to converge";
             endif;
             end;
         else;
            retp(error(abs(info)));
         endif;
     endif;

     retp(s);
endp;




/*
** >proc lapsvdcusv
**
**  Purpose:   computes the singular value decomposition a real or complex
**             rectangular matrix, returns compact u and v
**
**  Format:    { u,s,v } = lapsvdcusv(x);
**
**  Input:     x    M x N matrix, real or complex rectangular matrix
**
**  Output:    u    M x min(M,N) matrix, left singular vectors
**
**             s    min(M,N) x N matrix, singular values
**
**             v    N x N matrix, right singular values
**
**  Remarks:   lapsvdcusv computes the singular value decomposition of a real or
**             complex rectangular matrix.  The SVD is
**
**               x = u * s * v'
**
**             where v is the matrix of right singular vectors.
**
**             lapsvdcusv is based on the LAPACK drivers DGESVD and ZGESVD.
**             Further documentation of these functions may be found in
**             the LAPACK User's Guide.
**
**  Example:
**               x = { 2.143 4.345 6.124,
**                     1.244 5.124 3.412,
**                     0.235 5.657 8.214 };
**
**               { u,s,v }  = lapsvdusv(x);
**
**               print s;
**
**
**                    -0.55531277      0.049048431       0.83019394
**                    -0.43090168       0.83684123      -0.33766923
**                    -0.71130266      -0.54524400      -0.44357356
**
**
**               print s;
**
**                      13.895868        0.0000000        0.0000000
**                      0.0000000        2.1893939        0.0000000
**                      0.0000000        0.0000000        1.4344261
**
**               print v;
**
**                    -0.13624432      -0.62209955      -0.77099263
**                     0.46497296       0.64704876      -0.60425826
**                     0.87477862      -0.44081748       0.20110275
**
**
**             See also lapsvds, lapsvdusv.
*/



proc(3)=lapsvdcusv(x);

     local s, u, v, m, n, info, ind1, ind2, w, mm;
     ind1 = 2;  /* compact u */
     ind2 = 1;  /* full v */
     info = 0;
     m = rows(x);
     n = cols(x);
     mm = minc(m|n);

     if not iscplx(x);
         s = zeros(mm,1);
         u = zeros(m,mm);
         v = zeros(n,n);

         dllcall _dgesvd(m,n,x,s,u,v,info,ind1,ind2);

     else;

         s = zeros(mm,1);
         u = complex(zeros(m,mm),zeros(m,mm));
         v = complex(zeros(n,n),zeros(n,n));

         dllcall _zgesvd(m,n,x,s,u,v,info,ind1,ind2);
     endif;
     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapsvd1:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapsvd1:  failure to converge";
                 end;
             endif;
         else;
            retp(error(0),error(abs(info)),error(0));
         endif;
     endif;
     retp(u,diagrv(zeros(mm,n),s),v);
endp;




/*
** >proc lapsvdusv
**
**  Purpose:   computes the singular value decomposition a real or complex
**             rectangular matrix
**
**  Format:    { u,s,v } = lapsvdusv(x);
**
**  Input:     x    M x N matrix, real or complex rectangular matrix
**
**  Output:    u    M x M matrix, left singular vectors
**
**             s    M x N matrix, singular values
**
**             v    N x N matrix, right singular values
**
** Remarks:   lapsvdusv computes the singular value decomposition of a real or
**            complex rectangular matrix.  The SVD is
**
**               x = u * s * v'
**
**            where v is the matrix of right singular vectors.
**
**            lapsvdusv is based on the LAPACK drivers DGESVD and ZGESVD.
**            Further documentation of these functions may be found in
**            the LAPACK User's Guide.
**
**  Example:
**               x = { 2.143 4.345 6.124,
**                     1.244 5.124 3.412,
**                     0.235 5.657 8.214 };
**
**               { u,s,v } = lapsvdusv(x);
**
**               print u;
**
**
**               -0.5553    0.0490    0.8302
**               -0.4309    0.8368   -0.3377
**               -0.7113   -0.5452   -0.4436
**
**               print s;
**
**                13.8959   0.0000    0.0000
**                0.0000    2.1894    0.0000
**                0.0000    0.0000    1.4344
**
**               print v;
**
**               -0.1362    0.4650    0.8748
**                0.6221    0.6470   -0.4408
**               -0.7710   -0.6043    0.2011
**
**
**            See also lapsvds, lapsvdcusv.
*/



proc(3)=lapsvdusv(x);

     local s, u, v, m, n, info, ind1, ind2, w, mm;
     ind1 = 1;  /*  full u */
     ind2 = 1;  /*  full v */
     info = 0;
     m = rows(x);
     n = cols(x);
     mm = minc(m|n);

     if not iscplx(x);
         s = zeros(mm,1);
         u = zeros(m,m);
         v = zeros(n,n);

         dllcall _dgesvd(m,n,x,s,u,v,info,ind1,ind2);

     else;
         s = zeros(mm,1);
         u = complex(zeros(m,m),zeros(m,m));
         v = complex(zeros(n,n),zeros(n,n));

         dllcall _zgesvd(m,n,x,s,u,v,info,ind1,ind2);
     endif;
     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapsvdusv:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapsvdusv:  failure to converge";
             endif;
             end;
         else;
            retp(error(abs(info)),error(0),error(0));
         endif;
     endif;
     retp(u,diagrv(zeros(m,n),s),v);
endp;








/*
** >proc lapgsvds
**
**  Purpose:  compute the generalized singular value decomposition
**            of a pair of real or complex general matrices
**
**  Format:  { C,S,R } = lapgsvds(A,B);
**
**  Input:   A   MxN real or complex matrix
**
**           B   PxN real or complex matrix
**
**  Output:  C   Lx1 vector, singular values for A
**
**           S   Lx1 vector, singular values for B
**
**           R   (K+L)x(K+L) upper triangular matrix
**
**  Remarks:
**     (1) The generalized singular value decomposition of A and B is
**
**             U'*A*Q = D1*Z
**             V'*B*Q = D2*Z
**
**         where U, V, and Q are orthogonal matrices (see lapgsvd1 and
**         lapgsvd2). Letting K+L = the rank of A|B then R is a (K+L)x(K+L)
**         upper triangular matrix, D1 and D2 are Mx(K+L) and Px(K+L)
**         matrices with entries on the diagonal, Z = [0 R], and
**
**         if M-K-L >= 0
**
**                           K  L
**              D1 =     K [ I  0 ]
**                       L [ 0  C ]
**                   M-K-L [ 0  0 ]
**
**                           K  L
**              D2 =     L [ 0  S ]
**                     P-L [ 0  0 ]
**
**                          N-K-L  K    L
**         [ 0 R ] =     K [  0   R11  R12 ]
**                       L [  0    0   R22 ]
**
**
**         or if M-K-L < 0
**
**                           K M-K K+L-M
**              D1 =     K [ I  0    0   ]
**                     M-K [ 0  C    0   ]
**
**                           K M-K K+L-M
**              D2 =   M-K [ 0  S    0  ]
**                   K+L-M [ 0  0    I  ]
**                     P-L [ 0  0    0  ]
**
**                          N-K-L  K   M-K  K+L-M
**         [ 0 R ] =     K [ 0    R11  R12  R13  ]
**                     M-K [ 0     0   R22  R23  ]
**                   K+L-M [ 0     0    0   R33  ]
**
**
**
**     (2) Form the matrix
**
**               X = Q * [ I  0      ]
**                       [ 0  R^(-1) ]
**         then
**
**               A = U^(-1)'*E1*X^(-1)
**               B = V^(-1)'*E2*X^(-1)
**
**         where E1 = [0 D1] and E2 = [0 D2].
**
**     (3) The generalized singular value decomposition of A and B
**         implicitly produces the singular value decomposition of
**         A*B^(-1):
**
**               A*B^(-1) = U*(D1*D2^(-1))*V'
**
**
**           This procedure calls the LAPACK routines DGGSVD and ZGGSVD.
*/





proc(3)=lapgsvds(a,b);

     local m,n,p,k,l,c,s,ind,e,w,u,v,q,r,info;
     m = rows(a);
     n = cols(a);
     p = rows(b);
     if cols(b) /= n;
         if not trapchk(4);
             errorlog "lapgsvd: arguments not conformable";
             end;
         else;
             retp(error(0),error(0),error(0));
         endif;
     endif;

     ind = 0;
     info = 0;
     k = 0;
     l = 0;
     u = 1;
     v = 1;
     q = 1;
     if not iscplx(a) and not iscplx(b);

         e = zeros(n,1);
         w = zeros(n,1);

         dllcall _dggsvd(m,n,p,k,l,a,b,e,w,u,v,q,info,ind);

         if m - k - l >= 0;
             c = e[k+1:k+l];
             s = w[k+1:k+l];
             r = a[1:k+l,n-k-l+1:n];
         else;
             c = e[k+1:m];
             s = w[k+1:m];
             r = a[1:m,n-k-l+1:n] | (zeros(k+l-m,m)~b[m-k+1:l,n+m-k-l+1:n]);
         endif;

     else;

         e = zeros(n,1);
         w = zeros(n,1);

         if not iscplx(a);
             a = complex(a,zeros(n,n));
         endif;
         if not iscplx(b);
             b = complex(b,zeros(n,n));
         endif;
         dllcall _zggsvd(m,n,p,k,l,a,b,e,w,u,v,q,info,ind);

     endif;

     if m - k - l >= 0;
         c = e[k+1:k+l];
         s = w[k+1:k+l];
         r = a[1:k+l,n-k-l+1:n];
     else;
         c = e[k+1:m];
         s = w[k+1:m];
         r = a[1:m,n-k-l+1:n] | (zeros(k+l-m,m)~b[m-k+1:l,n+m-k-l+1:n]);
     endif;


     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapgsvds:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapgsvds:  failure to converge";
                 end;
             endif;
         else;
             retp(error(abs(info)),error(0),error(0));
         endif;
     endif;

     retp(c,s,r);
endp;







/*
** >proc lapgsvdcst
**
**  Purpose:  compute the generalized singular value decomposition
**            of a pair of real or complex general matrices
**
**  Format:  { C,S,R,U,V,Q } = lapgsvdcst(A,B);
**
**  Input:   A   MxN matrix
**
**           B   PxN matrix
**
**  Output:  C   Lx1 vector, singular values for A
**
**           S   Lx1 vector, singular values for B
**
**           R   (K+L)x(K+L) upper triangular matrix
**
**           U   MxM matrix, orthogonal transformation matrix
**
**           V   PxP matrix, orthogonal transformation matrix
**
**           U   NxN matrix, orthogonal transformation matrix
**
**  Remarks:
**     (1) The generalized singular value decomposition of A and B is
**
**             U'*A*Q = D1*Z
**             V'*B*Q = D2*Z
**
**         where U, V, and Q are orthogonal matrices (see lapgsvdcst and
**         lapgsvdst). Letting K+L = the rank of A|B then R is a (K+L)x(K+L)
**         upper triangular matrix, D1 and D2 are Mx(K+L) and Px(K+L)
**         matrices with entries on the diagonal, Z = [0 R], and
**
**         if M-K-L >= 0
**
**                           K  L
**              D1 =     K [ I  0 ]
**                       L [ 0  C ]
**                   M-K-L [ 0  0 ]
**
**                           K  L
**              D2 =     L [ 0  S ]
**                     P-L [ 0  0 ]
**
**                          N-K-L  K    L
**         [ 0 R ] =     K [  0   R11  R12 ]
**                       L [  0    0   R22 ]
**
**
**         or if M-K-L < 0
**
**                           K M-K K+L-M
**              D1 =     K [ I  0    0   ]
**                     M-K [ 0  C    0   ]
**
**                           K M-K K+L-M
**              D2 =   M-K [ 0  S    0  ]
**                   K+L-M [ 0  0    I  ]
**                     P-L [ 0  0    0  ]
**
**                          N-K-L  K   M-K  K+L-M
**         [ 0 R ] =     K [ 0    R11  R12  R13  ]
**                     M-K [ 0     0   R22  R23  ]
**                   K+L-M [ 0     0    0   R33  ]
**
**
**
**     (2) Form the matrix
**
**               X = Q * [ I  0      ]
**                       [ 0  R^(-1) ]
**         then
**
**               A = U^(-1)'*E1*X^(-1)
**               B = V^(-1)'*E2*X^(-1)
**
**         where E1 = [0 D1] and E2 = [0 D2].
**
**     (3) The generalized singular value decomposition of A and B
**         implicitly produces the singular value decomposition of
**         A*B^(-1):
**
**               A*B^(-1) = U*(D1*D2^(-1))*V'
**
**
**           This procedure calls the LAPACK routines DGGSVD and ZGGSVD.
*/








proc(6)=lapgsvdcst(a,b);

     local m,n,p,k,l,c,s,ind,e,w,u,v,q,r,info;
     m = rows(a);
     n = cols(a);
     p = rows(b);
     if cols(b) /= n;
         if not trapchk(4);
             errorlog "lapgsvd: arguments not conformable";
             end;
         else;
             retp(error(0),error(0),error(0),error(0),error(0),error(0));
         endif;
     endif;

     ind = 1;
     info = 0;
     k = 0;
     l = 0;

     if not iscplx(a) and not iscplx(b);

         e = zeros(n,1);
         w = zeros(n,1);
         u = zeros(m,m);
         v = zeros(p,p);
         q = zeros(n,n);

         dllcall _dggsvd(m,n,p,k,l,a,b,e,w,u,v,q,info,ind);

     else;

         e = zeros(n,1);
         w = zeros(n,1);
         u = complex(zeros(m,m),zeros(m,m));
         v = complex(zeros(p,p),zeros(p,p));
         q = complex(zeros(n,n),zeros(n,n));

         if not iscplx(a);
             a = complex(a,zeros(n,n));
         endif;
         if not iscplx(b);
             b = complex(b,zeros(n,n));
         endif;
         dllcall _zggsvd(m,n,p,k,l,a,b,e,w,u,v,q,info,ind);

     endif;

     if m - k - l >= 0;
         c = e[k+1:k+l];
         s = w[k+1:k+l];
         r = a[1:k+l,n-k-l+1:n];
     else;
         c = e[k+1:m];
         s = w[k+1:m];
         r = a[1:m,n-k-l+1:n] | (zeros(k+l-m,m)~b[m-k+1:l,n+m-k-l+1:n]);
     endif;


     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapgsvds:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapgsvds:  failure to converge";
                 end;
             endif;
         else;
             retp(error(abs(info)),error(0),error(0),error(0),error(0),error(0));
         endif;
     endif;

     retp(c,s,r,u,v,q);
endp;










/*
** >proc lapgsvdst
**
**  Purpose:  compute the generalized singular value decomposition
**            of a pair of real or complex general matrices
**
**  Format:  { D1,D2,Z,U,V,Q } = lapgsvdst(A,B);
**
**  Input:   A   MxN matrix
**
**           B   PxN matrix
**
**  Output:  D1  Mx(K+L) matrix, with singular values for A on diagonal
**
**           D2  Px(K+L) matrix, with singular values for B on diagonal
**
**           Z   (K+L)xN matrix, partitioned matrix composed of a zero
**                        matrix and upper triangular matrix
**
**           U   MxM matrix, orthogonal transformation matrix
**
**           V   PxP matrix, orthogonal transformation matrix
**
**           U   NxN matrix, orthogonal transformation matrix
**
**  Remarks:
**     (1) The generalized singular value decomposition of A and B is
**
**             U'*A*Q = D1*Z
**             V'*B*Q = D2*Z
**
**         where U, V, and Q are orthogonal matrices (see lapgsvdcst and
**         lapgsvdst). Letting K+L = the rank of A|B then R is a (K+L)x(K+L)
**         upper triangular matrix, D1 and D2 are Mx(K+L) and Px(K+L)
**         matrices with entries on the diagonal, Z = [0 R] where R is
**         (K+L)x(K+L) upper triangular matrix, and C and S are LxL
**         diagonal matrices of singular values from A and B, and then
**
**         if M-K-L >= 0
**
**                           K  L
**              D1 =     K [ I  0 ]
**                       L [ 0  C ]
**                   M-K-L [ 0  0 ]
**
**                           K  L
**              D2 =     L [ 0  S ]
**                     P-L [ 0  0 ]
**
**                          N-K-L  K    L
**         [ 0 R ] =     K [  0   R11  R12 ]
**                       L [  0    0   R22 ]
**
**
**         or if M-K-L < 0
**
**                           K M-K K+L-M
**              D1 =     K [ I  0    0   ]
**                     M-K [ 0  C    0   ]
**
**                           K M-K K+L-M
**              D2 =   M-K [ 0  S    0  ]
**                   K+L-M [ 0  0    I  ]
**                     P-L [ 0  0    0  ]
**
**                          N-K-L  K   M-K  K+L-M
**         [ 0 R ] =     K [ 0    R11  R12  R13  ]
**                     M-K [ 0     0   R22  R23  ]
**                   K+L-M [ 0     0    0   R33  ]
**
**
**
**     (2) Form the matrix
**
**               X = Q * [ I  0      ]
**                       [ 0  R^(-1) ]
**         then
**
**               A = U^(-1)'*E1*X^(-1)
**               B = V^(-1)'*E2*X^(-1)
**
**         where E1 = [0 D1] and E2 = [0 D2].
**
**     (3) The generalized singular value decomposition of A and B
**         implicitly produces the singular value decomposition of
**         A*B^(-1):
**
**               A*B^(-1) = U*(D1*D2^(-1))*V'
**
**
**           This procedure calls the LAPACK routines DGGSVD and ZGGSVD.
*/




proc(6)=lapgsvdst(a,b);

     local m,n,p,k,l,ind,e,w,u,v,q,d1,d2,z,info;
     m = rows(a);
     n = cols(a);
     p = rows(b);
     if cols(b) /= n;
         if not trapchk(4);
             errorlog "lapgsvd: arguments not conformable";
             end;
         else;
             retp(error(0),error(0),error(0),error(0),error(0),error(0));
         endif;
     endif;

     ind = 1;
     info = 0;
     k = 0;
     l = 0;

     if not iscplx(a) and not iscplx(b);

         e = zeros(n,1);
         w = zeros(n,1);
         u = zeros(m,m);
         v = zeros(p,p);
         q = zeros(n,n);

         dllcall _dggsvd(m,n,p,k,l,a,b,e,w,u,v,q,info,ind);

     else;

         e = zeros(n,1);
         w = zeros(n,1);
         u = complex(zeros(m,m),zeros(m,m));
         v = complex(zeros(p,p),zeros(p,p));
         q = complex(zeros(n,n),zeros(n,n));

         if not iscplx(a);
             a = complex(a,zeros(m,n));
         endif;
         if not iscplx(b);
             b = complex(b,zeros(p,n));
         endif;
         dllcall _zggsvd(m,n,p,k,l,a,b,e,w,u,v,q,info,ind);

     endif;

     if m - k - l >= 0;
         if k > 0;
             d1 = (eye(k)|zeros(m-k,k))~(zeros(k,l)|diagrv(eye(l),e[k+1:k+l])|zeros(m-k-l,l));
             if p > l;
                 d2 = zeros(p,k)~(diagrv(eye(l),w[k+1:k+l])|zeros(p-l,l));
             else;
                 d2 = diagrv(eye(l),w[k+1:k+l]);
             endif;
             z = zeros(k+l,n-k-l)~a[1:k+l,n-k-l+1:n];
         else;
             if m > l;
                 d1 = diagrv(eye(l),e[1:l])|zeros(m-l,l);
             else;
                 d1 = diagrv(eye(l),e[1:l]);
             endif;
             if p > l;
                 d2 = diagrv(eye(l),w[1:l])|zeros(p-l,l);
             else;
                 d2 = diagrv(eye(l),w[1:l]);
             endif;
             if n > l;
                 z = zeros(l,n-l)~a[1:l,n-l+1:n];
             else;
                 z = a[1:l,1:n];
             endif;
         endif;
     else;
         if k > 0;
             d1 = (eye(k)~zeros(k,m-k)~zeros(k,k+l-m)) |
                      (zeros(m-k,k)~diagrv(eye(l),e[k+1:m])~zeros(m-k,k+l-m));
             if p > l;
                 d2 = (zeros(m-k,k)~diagrv(eye(l),w[k+1:m])~zeros(m-k,k+l-m)) |
                      (zeros(k+l-m,m)~eye(k+l-m)) | zeros(p-l,m);
             else;
                 d2 = (zeros(m-k,k)~diagrv(eye(l),w[k+1:m])~zeros(m-k,k+l-m)) |
                      (zeros(k+l-m,m)~eye(k+l-m));
             endif;
             z = ( zeros(m,n-k-l)~a[1:m,n-l+1:n] )|( zeros(k+l-m,m+n-k-l)~b[m+1:l,m+n-l+1:n] );
         else;
             if l > m;
                 d1 = diagrv(eye(m),e[1:m])~zeros(m,l-m);
             else;
                 d1 = diagrv(eye(m),e[1:m]);
             endif;
             if p > l;
                 d2 = (diagrv(eye(m),w[1:m])~zeros(m,l-m)) |
                      (zeros(l-m,m)~eye(l-m)) | zeros(p-l,m);
             else;
                 d2 = (diagrv(eye(m),w[1:m])~zeros(m,l-m)) |
                      (zeros(l-m,m)~eye(l-m));
             endif;
             if n > l;
                 z = ( zeros(m,n-l)~a[1:m,n-l+1:n] )|( zeros(l-m,m+n-l)~b[m+1:l,m+n-l+1:n] );
             else;
                 z = ( a[1:m,1:n] )|( zeros(l-m,m)~b[m+1:l,m+1:n] );
             endif;
         endif;
     endif;


     if info /= 0;
         if not trapchk(4);
             if info < 0;
                 errorlog "lapgsvds:  illegal value in argument";
             elseif info > 0;
                 errorlog "lapgsvds:  failure to converge";
                 end;
             endif;
         else;
             retp(error(abs(info)),error(0),error(0),error(0),error(0),error(0));
         endif;
     endif;

     retp(d1,d2,z,u,v,q);
endp;


























